<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Google Analytics (GA4) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NNWKQ6SSHN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-NNWKQ6SSHN');
    </script>
    <!-- Microsoft Clarity Analytics -->
    <script type="text/javascript">
        (function (c, l, a, r, i, t, y) {
            c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
            t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
            y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
        })(window, document, "clarity", "script", "ujzwruoqtu");
    </script>
    <!-- Environment Config (Generated at Build Time) -->
    <!-- Contains SHARED_CHATBOT_KEY for Direct API Calls -->
    <script src="js/env-config.js"></script>
    <!-- App Recovery: Detect and fix black screen issues -->
    <script>
        (function () {
            'use strict';

            // EMERGENCY: If page stuck, enable this URL param to force clear
            if (location.search.includes('forceclear')) {
                if ('caches' in window) caches.keys().then(n => n.forEach(c => caches.delete(c)));
                if ('serviceWorker' in navigator) navigator.serviceWorker.getRegistrations().then(r => r.forEach(s => s.unregister()));
                localStorage.clear();
                sessionStorage.clear();
                alert('Cache cleared! Page will reload.');
                location.href = location.origin + location.pathname;
                return;
            }

            // Recovery timeout - if app doesn't load in 5 seconds, try recovery
            const APP_LOAD_TIMEOUT = 5000;
            const RECOVERY_KEY = 'bunkit_last_recovery';
            const RECOVERY_COOLDOWN = 30000; // 30 seconds between recovery attempts

            // Check if we recently attempted recovery (prevent infinite loops)
            const lastRecovery = localStorage.getItem(RECOVERY_KEY);
            const now = Date.now();
            const recentRecovery = lastRecovery && (now - parseInt(lastRecovery)) < RECOVERY_COOLDOWN;

            // Set up recovery timer
            const recoveryTimer = setTimeout(async () => {
                // Check if body has content (app loaded)
                const body = document.body;
                const hasContent = body && body.innerHTML.trim().length > 500;

                if (!hasContent) {
                    console.warn('⚠️ App appears stuck - attempting recovery...');

                    if (!recentRecovery) {
                        // Mark recovery attempt
                        localStorage.setItem(RECOVERY_KEY, now.toString());

                        // Try to clear service worker cache
                        if ('caches' in window) {
                            try {
                                const cacheNames = await caches.keys();
                                await Promise.all(cacheNames.map(name => caches.delete(name)));
                                console.log('✅ Cleared all caches');
                            } catch (e) {
                                console.error('Cache clear failed:', e);
                            }
                        }

                        // Unregister service workers
                        if ('serviceWorker' in navigator) {
                            try {
                                const registrations = await navigator.serviceWorker.getRegistrations();
                                await Promise.all(registrations.map(r => r.unregister()));
                                console.log('✅ Unregistered service workers');
                            } catch (e) {
                                console.error('SW unregister failed:', e);
                            }
                        }

                        // Force hard reload
                        location.reload(true);
                    } else {
                        console.log('⏳ Recovery attempted recently, waiting...');
                    }
                }
            }, APP_LOAD_TIMEOUT);

            // Cancel recovery timer when app loads successfully
            window.addEventListener('load', () => {
                clearTimeout(recoveryTimer);
                localStorage.removeItem(RECOVERY_KEY);
                console.log('✅ App loaded successfully');
            });

            // Also cancel on DOMContentLoaded
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => clearTimeout(recoveryTimer), 3000);
            });
        })();
    </script>
    <!-- Anti-DevTools Protection (deters casual users) -->
    <script>
        (function () {
            'use strict';

            // Disable right-click context menu
            document.addEventListener('contextmenu', function (e) {
                e.preventDefault();
                console.log('🔒 Right-click disabled');
            });

            // Block common DevTools keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // F12
                if (e.key === 'F12') {
                    e.preventDefault();
                    console.log('🔒 F12 blocked');
                    return false;
                }
                // Ctrl+Shift+I (DevTools)
                if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                    e.preventDefault();
                    console.log('🔒 Ctrl+Shift+I blocked');
                    return false;
                }
                // Ctrl+Shift+J (Console)
                if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                    e.preventDefault();
                    console.log('🔒 Ctrl+Shift+J blocked');
                    return false;
                }
                // Ctrl+Shift+C (Element inspector)
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    console.log('🔒 Ctrl+Shift+C blocked');
                    return false;
                }
                // Ctrl+U (View source)
                if (e.ctrlKey && e.key === 'u') {
                    e.preventDefault();
                    console.log('🔒 Ctrl+U blocked');
                    return false;
                }
                // Ctrl+S (Save page)
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    console.log('🔒 Ctrl+S blocked');
                    return false;
                }
            });

            // DevTools detection (warns in console)
            let devToolsOpen = false;
            const threshold = 160;

            setInterval(function () {
                const widthThreshold = window.outerWidth - window.innerWidth > threshold;
                const heightThreshold = window.outerHeight - window.innerHeight > threshold;

                if (widthThreshold || heightThreshold) {
                    if (!devToolsOpen) {
                        devToolsOpen = true;
                        console.log('%c⚠️ DevTools detected - Welcome developer! 👋', 'font-size: 20px; color: #ff6b6b;');
                    }
                } else {
                    devToolsOpen = false;
                }
            }, 1000);

            // Disable text selection on double-click for UI elements
            document.addEventListener('selectstart', function (e) {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    // Allow selection in form elements
                    if (!e.target.isContentEditable) {
                        // Keep enabled for now - only block if needed
                    }
                }
            });

            console.log('%c🔒 Security measures active', 'color: #28a745; font-weight: bold;');
        })();
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunk it - Free Attendance Tracker App for College Students | 75% Calculator</title>

    <!-- Primary SEO Meta Tags -->
    <meta name="description"
        content="Bunk it is India's #1 free attendance tracker app for college & university students. Calculate how many classes you can skip, maintain 75% attendance, track subjects, and never get detained. Works offline! Used by 50,000+ students across IITs, NITs, and colleges.">
    <meta name="keywords"
        content="attendance tracker app, bunk calculator, college attendance app, 75 percent attendance calculator, how many classes can I skip, attendance manager app, student attendance tracker, proxy attendance, class attendance calculator, bunking classes calculator, college bunk app, attendance shortage calculator, minimum attendance calculator, engineering attendance, medical college attendance, university attendance tracker, class skip calculator, attendance percentage calculator, free attendance app, offline attendance app, best attendance app for students, attendance app India, IIT attendance, NIT attendance, VIT attendance, SRM attendance, college ka attendance, bunk kaise kare, kitni class bunk kar sakte hain, attendance kaise calculate kare">
    <meta name="author" content="Bunk it - Made for Indian Students">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="googlebot" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="bingbot" content="index, follow">
    <link rel="canonical" href="https://bunkitapp.in/">

    <!-- Geographic & Language Targeting for India -->
    <meta name="geo.region" content="IN">
    <meta name="geo.country" content="India">
    <meta name="geo.placename" content="India">
    <meta name="language" content="English, Hindi">
    <meta http-equiv="content-language" content="en-IN">
    <link rel="alternate" hreflang="en-IN" href="https://bunkitapp.in/">
    <link rel="alternate" hreflang="hi" href="https://bunkitapp.in/">
    <link rel="alternate" hreflang="x-default" href="https://bunkitapp.in/">

    <!-- Additional SEO Signals -->
    <meta name="rating" content="General">
    <meta name="distribution" content="Global">
    <meta name="revisit-after" content="3 days">
    <meta name="coverage" content="Worldwide">
    <meta name="target" content="all">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <!-- Open Graph / Facebook / LinkedIn / WhatsApp -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://bunkitapp.in/">
    <meta property="og:title" content="Bunk it - Free Attendance Tracker for College Students">
    <meta property="og:description"
        content="India's smartest attendance app! Calculate bunks, track 75% attendance, manage subjects. Used by 50,000+ students. Free & works offline!">
    <meta property="og:image" content="https://bunkitapp.in/icon-512x512.png">
    <meta property="og:image:secure_url" content="https://bunkitapp.in/icon-512x512.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="Bunk it - Attendance Tracker App Logo">
    <meta property="og:site_name" content="Bunk it">
    <meta property="og:locale" content="en_IN">
    <meta property="og:locale:alternate" content="hi_IN">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bunkitapp">
    <meta name="twitter:creator" content="@bunkitapp">
    <meta name="twitter:url" content="https://bunkitapp.in/">
    <meta name="twitter:title" content="Bunk it - Free Attendance Tracker for College Students">
    <meta name="twitter:description"
        content="Calculate how many classes you can bunk! Track 75% attendance. Used by 50,000+ Indian students. Free & offline!">
    <meta name="twitter:image" content="https://bunkitapp.in/icon-512x512.png">
    <meta name="twitter:image:alt" content="Bunk it App - Smart Attendance Manager">

    <!-- Additional SEO -->
    <meta name="application-name" content="Bunk it">
    <meta name="apple-mobile-web-app-title" content="Bunk it">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-TileColor" content="#667eea">
    <meta name="msapplication-TileImage" content="/icon-144x144.png">
    <meta name="msapplication-config" content="none">

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "@id": "https://bunkitapp.in/#webapp",
        "name": "Bunk it - Smart Attendance Manager",
        "alternateName": ["Bunk it", "Bunkit", "Bunk Calculator", "Attendance Tracker", "College Attendance App"],
        "description": "India's #1 free attendance tracker app for college students. Calculate how many classes you can skip, maintain 75% attendance, and never get detained.",
        "url": "https://bunkitapp.in/",
        "applicationCategory": "EducationalApplication",
        "applicationSubCategory": "Student Tools",
        "operatingSystem": "Any (Web, Android, iOS)",
        "browserRequirements": "Requires JavaScript. Works on Chrome, Firefox, Safari, Edge",
        "softwareVersion": "2.0",
        "datePublished": "2024-01-01",
        "dateModified": "2024-12-11",
        "inLanguage": ["en-IN", "hi-IN", "en"],
        "isAccessibleForFree": true,
        "isFamilyFriendly": true,
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "INR",
            "availability": "https://schema.org/InStock"
        },
        "author": {
            "@type": "Organization",
            "name": "Bunk it Team",
            "url": "https://bunkitapp.in/"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Bunk it",
            "logo": {
                "@type": "ImageObject",
                "url": "https://bunkitapp.in/icon-512x512.png"
            }
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.8",
            "bestRating": "5",
            "worstRating": "1",
            "ratingCount": "12500",
            "reviewCount": "3200"
        },
        "featureList": [
            "Attendance Percentage Calculator",
            "Bunk/Skip Class Calculator", 
            "75% Attendance Requirement Tracker",
            "Subject-wise Attendance Management",
            "Timetable Integration",
            "Offline Mode Support",
            "Smart Notifications",
            "Data Export/Import",
            "Multi-class Support",
            "Holiday Management",
            "OCR Screenshot Import",
            "AI-Powered Assistance"
        ],
        "keywords": "attendance tracker, bunk calculator, college attendance, 75% attendance, skip class calculator"
    }
    </script>

    <!-- Structured Data: FAQPage Schema (Major SEO Boost) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "How many classes can I bunk to maintain 75% attendance?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use Bunk it's bunk calculator to find out exactly how many classes you can skip while maintaining 75% attendance. Enter your current attendance and total classes, and the app will calculate your safe bunk limit instantly."
                }
            },
            {
                "@type": "Question",
                "name": "Is Bunk it free to use?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes, Bunk it is completely free! No ads, no subscriptions, no hidden charges. It's made by students for students."
                }
            },
            {
                "@type": "Question",
                "name": "Does Bunk it work offline?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Bunk it is a PWA (Progressive Web App) that works fully offline. Your attendance data is stored locally and you can track everything without internet."
                }
            },
            {
                "@type": "Question",
                "name": "How do I calculate my attendance percentage?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Bunk it automatically calculates your attendance percentage. Just log your daily attendance (present/absent), and it shows your percentage for each subject and overall attendance."
                }
            },
            {
                "@type": "Question",
                "name": "Which colleges is Bunk it designed for?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Bunk it works for all colleges and universities - IITs, NITs, VIT, SRM, engineering colleges, medical colleges, and any institution with attendance requirements."
                }
            }
        ]
    }
    </script>

    <!-- Structured Data: Organization -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "Bunk it",
        "url": "https://bunkitapp.in/",
        "logo": "https://bunkitapp.in/icon-512x512.png",
        "description": "Makers of India's #1 attendance tracking app for college students",
        "foundingDate": "2024",
        "areaServed": "Worldwide",
        "audience": {
            "@type": "EducationalAudience",
            "educationalRole": "student"
        }
    }
    </script>
    <!-- Microsoft Clarity Analytics -->
    <script type="text/javascript">
        (function (c, l, a, r, i, t, y) {
            c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
            t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
            y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
        })(window, document, "clarity", "script", "YOUR_CLARITY_ID");
    </script>
    <!-- Confetti Animation Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" defer></script>
    <!-- Google Identity Services for OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <!-- Google API for Drive -->
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea" />
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <link rel="icon" type="image/png" href="icon-192x192.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js');
                    console.log('ServiceWorker registration successful');

                    // === AUTO-REFRESH: Check for updates on every page load ===
                    registration.update(); // Force check for new SW version

                    // Listen for new service worker installing
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('New service worker found, installing...');

                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New content is available, refresh the page
                                console.log('New content available! Refreshing...');
                                // Skip waiting and activate immediately
                                newWorker.postMessage({ type: 'SKIP_WAITING' });
                            }
                        });
                    });

                    // Refresh page when new service worker takes control
                    let refreshing = false;
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        if (!refreshing) {
                            refreshing = true;
                            console.log('New service worker activated, reloading page...');
                            window.location.reload();
                        }
                    });

                    // Register for background sync if supported
                    if ('sync' in registration) {
                        // Register sync when going offline
                        window.addEventListener('offline', async () => {
                            console.log('App went offline, registering sync...');
                        });

                        // Trigger sync when coming back online
                        window.addEventListener('online', async () => {
                            console.log('App back online, triggering sync...');
                            try {
                                await registration.sync.register('sync-attendance');
                                await registration.sync.register('sync-settings');
                                console.log('Background sync registered');
                            } catch (e) {
                                console.log('Background sync registration failed:', e);
                            }
                        });
                    }

                    // === OPTIMIZATION: Request Periodic Background Sync (Chrome/Android) ===
                    if ('periodicSync' in registration) {
                        try {
                            const status = await navigator.permissions.query({
                                name: 'periodic-background-sync',
                            });

                            if (status.state === 'granted') {
                                await registration.periodicSync.register('check-notification', {
                                    minInterval: 12 * 60 * 60 * 1000 // 12 hours (browser minimum)
                                });
                                console.log('Periodic background sync registered');
                            }
                        } catch (e) {
                            console.log('Periodic sync registration failed:', e);
                        }
                    }

                    // === OPTIMIZATION: Keep-Alive Heartbeat ===
                    // Pings the SW every 25s to keep it from going idle while app is in background (but not closed)
                    setInterval(() => {
                        if (navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage({ type: 'KEEP_ALIVE' });
                        }
                    }, 25000);
                } catch (err) {
                    console.log('ServiceWorker registration failed: ', err);
                }
            });
        }
    </script>
    <style>
        /* --- MODERN UI & RESPONSIVENESS ENHANCEMENTS --- */
        :root {
            --primary-grad-start: #667eea;
            --primary-grad-end: #764ba2;
            --secondary-grad-start: #4facfe;
            --secondary-grad-end: #00f2fe;
            --success-grad-start: #28a745;
            --success-grad-end: #20c997;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #1abc9c;
            --body-bg: #f0f2f5;
            /* Light mode background */
            --light-bg: #f8f9fa;
            --dark-text: #2c3e50;
            --medium-text: #6c757d;
            --border-color: #dee2e6;
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            --border-radius-md: 12px;
            --border-radius-lg: 20px;
            --container-bg: #ffffff;
            /* Brighter light mode container */
            --card-bg: white;
            --header-text-color: white;
        }

        /* --- NEW: Dark Mode Theme --- */
        /* --- NEW: Dark Mode Theme (Glassmorphism 2.0) --- */
        body.dark-mode {
            --primary-grad-start: #7f8cfa;
            --primary-grad-end: #8e6ab4;
            --secondary-grad-start: #5faee3;
            --secondary-grad-end: #32c4cf;
            --success-grad-start: #30bf54;
            --success-grad-end: #29d9a6;
            --danger-color: #ff6b6b;
            --warning-color: #ffb142;
            --info-color: #25ccb0;
            --body-bg: #000000;
            --light-bg: #1e1e1e;
            --dark-text: #ecf0f1;
            --medium-text: #95a5a6;
            --border-color: rgba(255, 255, 255, 0.1);
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --container-bg: #121212;
            /* Glassmorphism: Semi-transparent backgrounds */
            --card-bg: rgba(30, 30, 30, 0.70);
            --header-text-color: #ecf0f1;
            --input-bg: rgba(255, 255, 255, 0.05);
            /* Glass inputs */
            --input-text: #ecf0f1;
            --input-border: rgba(255, 255, 255, 0.1);
            --warning-bg: rgba(255, 177, 66, 0.15);
            color-scheme: dark;
        }

        /* Glassmorphism Global Styles */
        body.dark-mode .card,
        body.dark-mode .modal-content,
        body.dark-mode .sidenav,
        body.dark-mode .fixed-ui-button {
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        /* --- MICRO-INTERACTIONS --- */

        /* 1. Button Click Effect */
        button:active,
        .fixed-ui-button:active {
            transform: scale(0.96);
        }

        /* 2. Card Hover Lift (Desktop only) */
        @media (hover: hover) {
            .card:hover {
                transform: translateY(-4px);
                transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.3s ease;
            }
        }

        /* 3. Input Focus Glow */
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-grad-start) !important;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
            transition: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--body-bg);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark-text);
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* --- CUSTOM SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(150, 150, 150, 0.4);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(150, 150, 150, 0.6);
        }

        /* --- REWRITTEN: Sidenav Hamburger Menu & Fixed UI Buttons --- */
        .fixed-ui-button {
            position: fixed;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            width: 50px;
            height: 50px;
            z-index: 1003;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .hamburger-btn-fixed {
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: var(--dark-text);
        }

        .theme-switch-wrapper {
            top: 20px;
            right: 20px;
        }

        .sidenav {
            height: 100%;
            width: 280px;
            position: fixed;
            z-index: 1002;
            top: 0;
            left: -300px;
            background-color: var(--card-bg);
            box-shadow: 5px 0 25px rgba(0, 0, 0, 0.15);
            overflow-x: hidden;
            overflow-y: auto;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding-top: 60px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidenav.active {
            left: 0;
        }

        .sidenav .close-btn {
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 36px;
            margin-left: 50px;
            color: var(--dark-text);
            text-decoration: none;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .sidenav .close-btn:hover {
            transform: rotate(90deg);
        }

        .sidenav-header {
            padding: 10px 20px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .sidenav a {
            padding: 12px 12px 12px 28px;
            text-decoration: none;
            font-size: 1.1rem;
            color: var(--dark-text);
            display: block;
            transition: all 0.3s ease;
            border-radius: 8px;
            margin: 2px 10px;
        }

        .sidenav a:hover {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.15), rgba(102, 126, 234, 0.05));
            padding-left: 32px;
        }

        .sidenav-dropdown-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .sidenav-dropdown-content {
            display: none;
            background-color: rgba(128, 128, 128, 0.05);
            padding-left: 20px;
        }

        .sidenav-dropdown-content a {
            font-size: 1rem;
            padding: 10px 10px 10px 35px;
        }

        .menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            z-index: 1001;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        .menu-overlay.active {
            display: block;
        }


        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: var(--border-radius-lg);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: background 0.3s ease;
        }

        .header {
            background: linear-gradient(135deg, var(--secondary-grad-start), var(--primary-grad-start), var(--secondary-grad-end));
            background-size: 200% 200%;
            animation: gradientShift 6s ease infinite;
            color: var(--header-text-color);
            padding: 40px 30px;
            text-align: center;
            position: relative;
            overflow: visible;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 60%);
            animation: float 8s ease-in-out infinite;
            pointer-events: none;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            animation: fadeInUp 0.8s ease-out;
            letter-spacing: 1px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.95;
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        .theme-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .theme-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .theme-switch .slider:before {
            position: absolute;
            content: "☀️";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .theme-switch input:checked+.slider {
            background-color: var(--light-bg);
        }

        .theme-switch input:checked+.slider:before {
            content: "🌙";
            transform: translateX(24px);
            background-color: var(--dark-text);
            color: white;
        }

        .class-selector-section {
            background: var(--card-bg);
            padding: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .class-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .class-selector-header h3 {
            font-size: 1.5rem;
            flex-grow: 1;
            text-align: center;
        }

        .class-selector-header .header-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            border: none;
            padding: 12px 28px;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            /* Apple Liquid Glass - Spring transition */
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
            position: relative;
            overflow: hidden;
            /* Liquid Glass base */
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            backdrop-filter: blur(12px) saturate(150%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* 3D depth with inner highlights */
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.15),
                0 1px 0 rgba(255, 255, 255, 0.25) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset;
            transform-style: preserve-3d;
        }

        /* Shimmer overlay - sweeps on hover */
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(105deg,
                    transparent 0%,
                    transparent 40%,
                    rgba(255, 255, 255, 0.5) 50%,
                    transparent 60%,
                    transparent 100%);
            background-size: 200% 100%;
            background-position: -200% center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: inherit;
        }

        /* Top edge highlight */
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 10%;
            right: 10%;
            height: 1px;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.5),
                    transparent);
            opacity: 0.6;
            pointer-events: none;
        }

        /* Hover: Grow + Shimmer + Enhanced Glow */
        .btn:hover {
            transform: translateY(-3px) scale(1.03);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 30px rgba(102, 126, 234, 0.25);
            border-color: rgba(255, 255, 255, 0.35);
        }

        .btn:hover::before {
            opacity: 1;
            animation: liquidGlassShimmer 1.2s ease-in-out;
        }

        /* Active: Quick responsive pop */
        .btn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.2),
                0 1px 0 rgba(255, 255, 255, 0.15) inset;
            transition: all 0.08s ease;
        }

        .btn.primary-btn {
            background: linear-gradient(135deg, var(--primary-grad-start) 0%, var(--primary-grad-end) 100%);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn.primary-btn:hover {
            box-shadow:
                0 8px 32px rgba(102, 126, 234, 0.4),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 40px rgba(102, 126, 234, 0.3);
        }

        .btn.secondary-btn {
            background: linear-gradient(135deg, rgba(120, 130, 140, 0.92), rgba(100, 110, 120, 0.92));
            box-shadow:
                0 4px 20px rgba(120, 130, 140, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.35) inset;
        }

        .btn.secondary-btn:hover {
            box-shadow:
                0 8px 32px rgba(108, 117, 125, 0.35),
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 0 30px rgba(108, 117, 125, 0.2);
        }

        .btn.warning-btn {
            background: linear-gradient(135deg, rgba(255, 180, 50, 0.92), rgba(255, 160, 30, 0.92));
            box-shadow:
                0 4px 20px rgba(255, 180, 50, 0.35),
                0 1px 0 rgba(255, 255, 255, 0.4) inset;
        }

        .btn.warning-btn:hover {
            box-shadow:
                0 8px 32px rgba(243, 156, 18, 0.45),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 40px rgba(243, 156, 18, 0.3);
        }

        .btn.info-btn {
            background: linear-gradient(135deg, rgba(60, 220, 180, 0.92), rgba(40, 200, 160, 0.92));
            box-shadow:
                0 4px 20px rgba(60, 220, 180, 0.35),
                0 1px 0 rgba(255, 255, 255, 0.4) inset;
        }

        .btn.info-btn:hover {
            box-shadow:
                0 8px 32px rgba(26, 188, 156, 0.45),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 40px rgba(26, 188, 156, 0.3);
        }

        .btn.danger-btn {
            background: linear-gradient(135deg, rgba(255, 120, 120, 0.92), rgba(255, 100, 100, 0.92));
            box-shadow:
                0 4px 20px rgba(255, 120, 120, 0.35),
                0 1px 0 rgba(255, 255, 255, 0.4) inset;
        }

        .btn.danger-btn:hover {
            box-shadow:
                0 8px 32px rgba(231, 76, 60, 0.45),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 40px rgba(231, 76, 60, 0.3);
        }

        .btn.success-btn {
            background: linear-gradient(135deg, rgba(100, 220, 120, 0.92), rgba(80, 210, 100, 0.92));
            box-shadow:
                0 4px 20px rgba(100, 220, 120, 0.35),
                0 1px 0 rgba(255, 255, 255, 0.4) inset;
        }

        .btn.success-btn:hover {
            box-shadow:
                0 8px 32px rgba(40, 167, 69, 0.45),
                0 1px 0 rgba(255, 255, 255, 0.35) inset,
                0 0 40px rgba(40, 167, 69, 0.3);
        }

        /* ========================================
           APPLE LIQUID GLASS UI EFFECTS
           iOS 26 / visionOS inspired design system
           ======================================== */

        /* Shimmer Animation - Light sweep across surface */
        @keyframes liquidGlassShimmer {
            0% {
                background-position: -200% center;
            }

            100% {
                background-position: 200% center;
            }
        }

        /* Edge Glow Animation */
        @keyframes edgeGlow {

            0%,
            100% {
                box-shadow:
                    0 0 0 1px rgba(255, 255, 255, 0.1),
                    0 4px 20px rgba(102, 126, 234, 0.2);
            }

            50% {
                box-shadow:
                    0 0 0 1px rgba(255, 255, 255, 0.3),
                    0 4px 30px rgba(102, 126, 234, 0.4),
                    0 0 20px rgba(118, 75, 162, 0.3);
            }
        }

        /* Subtle Float Animation */
        @keyframes subtleFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-2px);
            }
        }

        /* Liquid Glass Button Base */
        .btn-glass {
            position: relative;
            padding: 14px 32px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            color: white;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.15) 0%,
                    rgba(255, 255, 255, 0.05) 100%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.15),
                0 1px 0 rgba(255, 255, 255, 0.2) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        /* Glass Shimmer Overlay */
        .btn-glass::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0) 40%,
                    rgba(255, 255, 255, 0.4) 50%,
                    rgba(255, 255, 255, 0) 60%,
                    transparent 100%);
            background-size: 200% 100%;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: inherit;
        }

        /* Edge Highlight Overlay */
        .btn-glass::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: radial-gradient(ellipse at 50% 0%,
                    rgba(255, 255, 255, 0.3) 0%,
                    transparent 50%);
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        /* Hover State - Grow + Shimmer + Glow */
        .btn-glass:hover {
            transform: translateY(-3px) scale(1.03);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 0 40px rgba(102, 126, 234, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .btn-glass:hover::before {
            opacity: 1;
            animation: liquidGlassShimmer 1.5s ease-in-out;
        }

        .btn-glass:hover::after {
            opacity: 0.8;
        }

        /* Active/Press State - Responsive Pop */
        .btn-glass:active {
            transform: translateY(1px) scale(0.97);
            box-shadow:
                0 2px 12px rgba(0, 0, 0, 0.2),
                0 1px 0 rgba(255, 255, 255, 0.1) inset;
            transition: all 0.1s ease;
        }

        /* Glass Button Variants */
        .btn-glass.primary {
            background: linear-gradient(135deg,
                    rgba(102, 126, 234, 0.6) 0%,
                    rgba(118, 75, 162, 0.6) 100%);
        }

        .btn-glass.success {
            background: linear-gradient(135deg,
                    rgba(40, 167, 69, 0.6) 0%,
                    rgba(32, 201, 151, 0.6) 100%);
        }

        .btn-glass.danger {
            background: linear-gradient(135deg,
                    rgba(231, 76, 60, 0.6) 0%,
                    rgba(192, 57, 43, 0.6) 100%);
        }

        .btn-glass.warning {
            background: linear-gradient(135deg,
                    rgba(243, 156, 18, 0.6) 0%,
                    rgba(230, 126, 34, 0.6) 100%);
        }

        /* Dark Mode Glass Adjustments */
        .dark-mode .btn-glass {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.08) 0%,
                    rgba(255, 255, 255, 0.02) 100%);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.4),
                0 1px 0 rgba(255, 255, 255, 0.1) inset,
                0 -1px 0 rgba(0, 0, 0, 0.3) inset;
        }

        .dark-mode .btn-glass:hover {
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 1px 0 rgba(255, 255, 255, 0.15) inset,
                0 0 60px rgba(102, 126, 234, 0.2);
        }

        /* ========================================
           LIQUID GLASS CARDS
           ======================================== */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 1px 0 rgba(255, 255, 255, 0.2) inset;
            padding: 24px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent);
            transition: left 0.6s ease;
        }

        .glass-card:hover {
            transform: translateY(-5px);
            box-shadow:
                0 16px 48px rgba(0, 0, 0, 0.15),
                0 1px 0 rgba(255, 255, 255, 0.3) inset,
                0 0 50px rgba(102, 126, 234, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .glass-card:hover::before {
            left: 100%;
        }

        .dark-mode .glass-card {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.05) inset;
        }

        /* ========================================
           LIQUID GLASS INPUTS
           ======================================== */
        .glass-input {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--dark-text);
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow:
                0 2px 8px rgba(0, 0, 0, 0.05),
                0 1px 0 rgba(255, 255, 255, 0.2) inset;
        }

        .glass-input:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
            box-shadow:
                0 4px 16px rgba(102, 126, 234, 0.2),
                0 0 0 4px rgba(102, 126, 234, 0.1),
                0 1px 0 rgba(255, 255, 255, 0.3) inset;
        }

        .dark-mode .glass-input {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* ========================================
           FLOATING ACTION BUTTON - LIQUID GLASS
           ======================================== */
        .fab-glass {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: linear-gradient(135deg,
                    rgba(102, 126, 234, 0.7) 0%,
                    rgba(118, 75, 162, 0.7) 100%);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 8px 32px rgba(102, 126, 234, 0.4),
                0 2px 0 rgba(255, 255, 255, 0.3) inset;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: subtleFloat 3s ease-in-out infinite;
            z-index: 999;
        }

        .fab-glass:hover {
            transform: scale(1.1);
            animation: edgeGlow 2s ease-in-out infinite;
            box-shadow:
                0 12px 40px rgba(102, 126, 234, 0.5),
                0 2px 0 rgba(255, 255, 255, 0.4) inset,
                0 0 30px rgba(118, 75, 162, 0.4);
        }

        .fab-glass:active {
            transform: scale(0.95);
            animation: none;
        }

        /* ========================================
           LIQUID GLASS TOGGLE/SWITCH
           ======================================== */
        .glass-toggle {
            width: 52px;
            height: 28px;
            background: rgba(120, 120, 128, 0.3);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .glass-toggle::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            top: 1px;
            left: 2px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .glass-toggle.active {
            background: linear-gradient(135deg,
                    rgba(52, 199, 89, 0.8) 0%,
                    rgba(48, 209, 88, 0.8) 100%);
        }

        .glass-toggle.active::after {
            left: 25px;
        }

        /* ========================================
           PREMIUM MICRO-INTERACTIONS
           ======================================== */
        /* Ripple effect for touch feedback */
        .touch-ripple {
            position: relative;
            overflow: hidden;
        }

        .touch-ripple::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at var(--ripple-x, 50%) var(--ripple-y, 50%),
                    rgba(255, 255, 255, 0.4) 0%,
                    transparent 60%);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .touch-ripple:active::after {
            opacity: 1;
        }

        /* Glow pulse for attention */
        .glow-pulse {
            animation: edgeGlow 2s ease-in-out infinite;
        }


        .class-search-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto 15px auto;
        }

        .class-search,
        .class-dropdown {
            width: 100%;
            padding: 14px 22px;
            border: 2px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--dark-text);
            border-radius: 50px;
            font-size: 1.1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .class-search:focus,
        .class-dropdown:focus {
            outline: none;
            border-color: var(--primary-grad-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            background: var(--light-bg);
            border: 3px dashed var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 50px;
            text-align: center;
            margin-bottom: 30px;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .upload-section.dragover {
            background-color: #e9ecef;
            border-color: var(--primary-grad-start);
        }

        .upload-icon {
            font-size: 4rem;
            color: var(--medium-text);
            margin-bottom: 20px;
        }

        .upload-input {
            display: none;
        }

        .upload-section h3 {
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .upload-btn-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: var(--border-radius-md);
            box-shadow: var(--card-shadow);
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }

        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--secondary-grad-start);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* === PREMIUM MICRO-ANIMATIONS === */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(102, 126, 234, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 30px rgba(102, 126, 234, 0.4);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }

            50% {
                transform: scale(1.05);
            }

            70% {
                transform: scale(0.95);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Skeleton Loading Animation */
        .skeleton {
            background: linear-gradient(90deg, var(--light-bg) 25%, var(--border-color) 50%, var(--light-bg) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: var(--border-radius-md);
        }

        .skeleton-text {
            height: 16px;
            margin-bottom: 8px;
        }

        .skeleton-title {
            height: 24px;
            width: 60%;
            margin-bottom: 12px;
        }

        .skeleton-card {
            height: 150px;
            margin-bottom: 20px;
        }

        /* Enhanced Focus Ring */
        *:focus-visible {
            outline: 2px solid var(--primary-grad-start);
            outline-offset: 2px;
            border-radius: 4px;
        }

        .settings-section,
        .date-section {
            background: var(--light-bg);
            border-radius: var(--border-radius-lg);
            padding: 25px;
            animation: fadeInUp 0.5s ease-out;
            margin: 30px 0;
        }

        .settings-section h3,
        .date-section h3 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .grid-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-text);
        }

        .input-group input,
        .input-group select {
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            background-color: var(--card-bg);
            color: var(--dark-text);
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--primary-grad-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* Fix for Dark Mode Select Options */
        body.dark-mode option {
            background-color: #1e1e1e;
            color: white;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-group label {
            margin: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-grad-start);
        }

        input:checked+.slider:before {
            transform: translateX(24px);
        }

        .results-section {
            margin-top: 40px;
        }

        .subject-card {
            background: var(--card-bg);
            border-radius: var(--border-radius-lg);
            padding: 30px;
            margin: 25px 0;
            box-shadow: var(--card-shadow);
            border-left: 6px solid var(--secondary-grad-start);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.4s, border-color 0.3s;
            animation: fadeInUp 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }

        .subject-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.03), rgba(79, 172, 254, 0.03));
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .subject-card:hover::before {
            opacity: 1;
        }

        .subject-card:hover {
            transform: translateY(-8px) scale(1.01);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            border-left-color: var(--primary-grad-start);
        }

        .subject-card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .subject-card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .subject-card:nth-child(3) {
            animation-delay: 0.3s;
        }

        .subject-card:nth-child(4) {
            animation-delay: 0.4s;
        }

        .subject-card:nth-child(5) {
            animation-delay: 0.5s;
        }

        .subject-title {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--dark-text), var(--primary-grad-start));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
            border-radius: var(--border-radius-md);
            background: var(--light-bg);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-grad-start), var(--secondary-grad-start));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-grad-start);
        }

        .stat-item:hover::before {
            transform: scaleX(1);
        }

        .stat-label {
            font-size: 0.95rem;
            color: var(--medium-text);
            margin-top: 8px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--secondary-grad-start);
            transition: transform 0.3s ease;
        }

        .stat-item:hover .stat-value {
            transform: scale(1.05);
        }

        .info-icon {
            cursor: pointer;
            color: var(--medium-text);
            font-style: normal;
            font-weight: bold;
            border: 1px solid var(--medium-text);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 12px;
            line-height: 16px;
            position: relative;
        }

        .tooltip {
            visibility: hidden;
            width: 220px;
            max-width: 90vw;
            /* MODIFIED: Added for responsiveness */
            background-color: var(--dark-text);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            /* MODIFIED: Replaced margin-left */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            font-weight: 400;
        }

        body.dark-mode .tooltip {
            color: var(--dark-text);
            background-color: var(--light-bg);
        }

        .info-icon:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .stat-value-editable {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            color: var(--secondary-grad-start);
        }

        .stat-value-editable input {
            width: 70px;
            border: none;
            background: transparent;
            color: var(--secondary-grad-start);
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            border-bottom: 2px solid transparent;
            transition: border-color 0.3s;
        }

        .stat-value-editable input:focus {
            outline: none;
            border-bottom: 2px solid var(--secondary-grad-start);
        }

        .stat-value-editable input::-webkit-outer-spin-button,
        .stat-value-editable input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stat-value-editable input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .alert-message {
            padding: 18px;
            border-radius: var(--border-radius-md);
            margin: 20px 0 0 0;
            border-left: 5px solid;
        }

        .alert-message.warning {
            background: #fff3cd;
            color: #856404;
            border-left-color: #ffc107;
        }

        .alert-message.danger {
            background: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
        }

        .alert-message.success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }

        body.dark-mode .alert-message.warning {
            background: #4d432b;
            color: #ffeb99;
        }

        body.dark-mode .alert-message.danger {
            background: #4f2e32;
            color: #ffc2c7;
        }

        body.dark-mode .alert-message.success {
            background: #2a4b32;
            color: #bdecc8;
        }

        .calculate-btn {
            background: linear-gradient(135deg, var(--success-grad-start) 0%, var(--success-grad-end) 100%);
            display: block;
            margin: 30px auto;
            font-size: 1.2rem;
            padding: 15px 45px;
        }

        .manual-input {
            display: none;
            margin-top: 30px;
        }

        .manual-input h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .subjects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .subject-input {
            background: var(--card-bg);
            padding: 20px;
            border-radius: var(--border-radius-md);
            border: 2px solid var(--border-color);
        }

        .manual-input-fields {
            display: flex;
            gap: 10px;
        }

        .manual-input-fields input {
            width: 100%;
            min-width: 0;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            background-color: var(--light-bg);
            color: var(--dark-text);
        }

        /* ========================================
           UNIVERSAL BACKDROP OVERLAY
           Blocks all interactions when panels are open
           ======================================== */
        .app-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            z-index: 9998;
            opacity: 0;
            transition: opacity 0.3s ease;
            /* Block all interactions on the backdrop */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        .app-backdrop.active {
            display: block;
            opacity: 1;
        }

        /* When backdrop is active, prevent body scroll */
        body.backdrop-active {
            overflow: hidden;
            touch-action: none;
        }

        /* Modal Styles - iOS Spring Animation */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            z-index: 1005;
            overflow-y: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
            /* Layout properties moved here to persist during closing */
            align-items: center;
            justify-content: center;
            padding: 20px;
            /* Block all touch interactions on backdrop */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        .modal.active {
            display: flex !important;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 1;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 32px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            /* iOS-style spring animation: starts from scale 0.7 with slight rotation */
            transform: scale(0.7);
            opacity: 0;
            /* iOS spring curve - slight overshoot then settle */
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                opacity 0.3s ease-out;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            /* Re-enable touch inside modal content */
            touch-action: auto;
        }

        .modal.active .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        /* Closing animation */
        .modal.closing .modal-content {
            transform: scale(0.7);
            opacity: 0;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.2s ease-in;
        }

        .modal-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            background: var(--light-bg);
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--medium-text);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--border-color);
            transform: scale(1.1);
        }

        .modal-close:active {
            transform: scale(0.95);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .help-main-heading {
            font-size: 1.2rem;
            font-weight: 700;
            margin-top: 25px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--border-color);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-text);
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            background-color: var(--light-bg);
            color: var(--dark-text);
        }

        .form-group textarea {
            min-height: 150px;
            font-family: monospace;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .schedule-input {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            /* Reduced gap to fit small screens */
            margin-top: 10px;
        }

        .schedule-day label {
            font-size: 0.8rem;
            text-align: center;
            display: block;
            margin-bottom: 5px;
        }

        .schedule-day input {
            width: 100%;
            min-width: 32px;
            padding: 0;
            /* MAX space */
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 8px;
            /* Reduced to 10px */
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .schedule-day input::-webkit-outer-spin-button,
        .schedule-day input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .subject-entry,
        .holiday-section {
            background: var(--light-bg);
            padding: 15px;
            border-radius: var(--border-radius-md);
            margin-bottom: 15px;
            border: 2px solid var(--border-color);
        }

        .subject-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .remove-subject-btn,
        .remove-holiday-btn,
        .remove-leave-period-btn,
        .remove-compulsory-period-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .add-subject-btn,
        .add-holiday-btn,
        .add-leave-period-btn,
        .add-compulsory-period-btn {
            background: var(--success-grad-start);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }

        #holidayList {
            list-style: none;
            padding: 0;
            max-height: 150px;
            overflow-y: auto;
        }

        #holidayList li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: var(--card-bg);
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .add-holiday-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .add-holiday-form input {
            flex-grow: 1;
        }

        .leave-period-entry,
        .compulsory-period-entry {
            display: flex;
            flex-wrap: wrap;
            /* Allow wrapping on small screens */
            gap: 5px;
            align-items: center;
            margin-bottom: 15px;
            /* Increased bottom margin for wrapped items */
            transition: border-color 0.3s;
            border: 2px solid transparent;
            padding: 5px;
            border-radius: var(--border-radius-md);
        }

        .leave-period-entry.unsafe-leave {
            border-color: var(--danger-color);
            background-color: rgba(231, 76, 60, 0.1);
        }

        .leave-period-entry input[type="date"],
        .compulsory-period-entry input[type="date"] {
            flex-grow: 1;
            /* Default: Desktop (Inline) */
            flex-basis: auto;
            width: auto;
            min-width: 140px;
            padding: 10px 8px;
            margin-bottom: 0;
            font-size: 16px;
            color: var(--main-text) !important;
            /* Force visibility */
            background-color: var(--card-bg);
            /* Match card background */
            /* Force opacity */
            opacity: 1 !important;
            z-index: 1;
            position: relative;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Ensure date text is visible on mobile */
        .leave-period-entry input[type="date"]::-webkit-datetime-edit,
        .compulsory-period-entry input[type="date"]::-webkit-datetime-edit {
            color: var(--main-text);
        }

        .leave-period-entry input[type="date"]::-webkit-datetime-edit-fields-wrapper,
        .compulsory-period-entry input[type="date"]::-webkit-datetime-edit-fields-wrapper {
            color: var(--main-text);
        }

        /* Dark mode specific styling for leave planner dates */
        body.dark-mode .leave-period-entry input[type="date"],
        body.dark-mode .compulsory-period-entry input[type="date"] {
            color: #ecf0f1;
            background-color: #2c2c2c;
            border-color: #444444;
        }

        body.dark-mode .leave-period-entry input[type="date"]::-webkit-datetime-edit,
        body.dark-mode .compulsory-period-entry input[type="date"]::-webkit-datetime-edit,
        body.dark-mode .leave-period-entry input[type="date"]::-webkit-datetime-edit-fields-wrapper,
        body.dark-mode .compulsory-period-entry input[type="date"]::-webkit-datetime-edit-fields-wrapper {
            color: #ecf0f1;
        }

        /* Mobile responsive adjustments for leave planner */
        @media (max-width: 600px) {

            .leave-period-entry,
            .compulsory-period-entry {
                flex-wrap: wrap;
                gap: 8px;
            }

            .leave-period-entry label,
            .compulsory-period-entry label {
                font-size: 12px;
                min-width: 35px;
            }

            .leave-period-entry input[type="date"],
            .compulsory-period-entry input[type="date"] {
                flex: 1 1 40%;
                min-width: 100px;
                font-size: 13px;
                padding: 8px 6px;
            }
        }

        /* Mobile Layout: Stack Dates */
        @media (max-width: 768px) {

            .leave-period-entry input[type="date"],
            .compulsory-period-entry input[type="date"] {
                flex-basis: 100% !important;
                /* Force full width (new line) */
                width: 100% !important;
                min-width: unset;
                /* Allow it to shrink if container is small */
                margin-bottom: 5px;
                /* Add spacing between lines */
                display: block;
                /* Ensure block behavior */
            }

            .leave-period-entry,
            .compulsory-period-entry {
                flex-wrap: wrap !important;
            }
        }

        /* iOS-style Input Styling for All Form Elements */
        input[type="text"],
        input[type="date"],
        input[type="number"],
        input[type="time"],
        input[type="email"],
        select,
        textarea {
            background-color: var(--card-bg);
            color: var(--dark-text);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Dark mode specific input styling */
        body.dark-mode input[type="text"],
        body.dark-mode input[type="date"],
        body.dark-mode input[type="number"],
        body.dark-mode input[type="time"],
        body.dark-mode input[type="email"],
        body.dark-mode select,
        body.dark-mode textarea {
            background-color: var(--input-bg, #2c2c2c);
            color: var(--input-text, #ecf0f1);
            border-color: var(--input-border, #444444);
        }

        /* Date input calendar icon styling */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(0);
            opacity: 0.6;
            cursor: pointer;
        }

        body.dark-mode input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            opacity: 0.8;
        }

        /* Time input clock icon */
        input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(0);
            opacity: 0.6;
        }

        body.dark-mode input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            opacity: 0.8;
        }

        /* Select dropdown arrow */
        select {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%23333" d="M6 9L1 4h10z" /></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        body.dark-mode select {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%23ecf0f1" d="M6 9L1 4h10z" /></svg>');
        }

        /* Input focus state */
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-grad-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        body.dark-mode input:focus,
        body.dark-mode select:focus,
        body.dark-mode textarea:focus {
            border-color: var(--primary-grad-start);
            box-shadow: 0 0 0 3px rgba(127, 140, 250, 0.2);
        }

        .weekend-finder-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .modal-tabs {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 25px;
        }

        .modal-tabs button {
            flex: 1;
            padding: 15px;
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            color: var(--medium-text);
            border-bottom: 3px solid transparent;
        }

        .modal-tabs button.active {
            color: var(--secondary-grad-start);
            border-bottom-color: var(--secondary-grad-start);
        }

        .json-instructions {
            background: var(--light-bg);
            padding: 15px;
            border-radius: var(--border-radius-md);
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        /* Timetable Section Styles */
        #timetableSection {
            background: var(--light-bg);
            border-radius: var(--border-radius-lg);
            padding: 15px;
            margin-bottom: 30px;
        }

        #timetableSection h3 {
            margin-bottom: 12px;
            font-size: 1.2rem;
            text-align: center;
        }

        .timetable-wrapper {
            width: 100%;
            overflow-x: auto;
        }

        .timetable-grid {
            display: grid;
            gap: 1px;
            background: var(--border-color);
            border-radius: var(--border-radius-md);
            overflow: hidden;
            /* Let grid expand based on content for scrolling */
            min-width: max-content;
        }

        .timetable-header {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            padding: 6px 3px;
            text-align: center;
            font-weight: 600;
            font-size: 0.65rem;
            min-width: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .timetable-header .period-time {
            font-size: 0.5rem;
            font-weight: 700;
            opacity: 0.9;
            margin-top: 2px;
        }

        .timetable-day-label {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            padding: 8px 5px;
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 45px;
        }

        .timetable-day-label.current-day {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .timetable-cell {
            background: var(--card-bg);
            padding: 4px 2px;
            min-height: 38px;
            min-width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .timetable-cell.current-day-row {
            background: rgba(40, 167, 69, 0.06);
        }

        .timetable-cell.drag-over {
            background: rgba(102, 126, 234, 0.15);
            box-shadow: inset 0 0 0 2px var(--primary-grad-start);
        }

        .subject-chip {
            color: white;
            padding: 4px 6px;
            border-radius: 12px;
            font-size: 0.6rem;
            font-weight: 600;
            cursor: grab;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
            -webkit-user-select: none;
            user-select: none;
            white-space: nowrap;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .subject-chip:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .subject-chip.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Attendance status highlighting for current day subjects */
        .subject-chip.status-success {
            box-shadow: 0 0 8px 3px rgba(40, 167, 69, 0.7);
            border: 2px solid #28a745;
        }

        .subject-chip.status-warning {
            box-shadow: 0 0 8px 3px rgba(255, 193, 7, 0.7);
            border: 2px solid #ffc107;
        }

        .subject-chip.status-danger {
            box-shadow: 0 0 8px 3px rgba(231, 76, 60, 0.7);
            border: 2px solid #e74c3c;
        }

        .timetable-empty {
            text-align: center;
            padding: 25px;
            color: var(--medium-text);
        }

        .timetable-empty p {
            margin: 5px 0;
        }

        .timetable-message {
            text-align: center;
            padding: 12px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: var(--border-radius-md);
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--dark-text);
        }

        /* Period-wise Attendance View Styles */
        .period-view-container {
            max-height: 70vh;
            overflow-y: auto;
        }

        .period-month-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            overflow: hidden;
        }

        .period-month-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(135deg, var(--primary-grad-start) 0%, var(--primary-grad-end) 100%);
            color: white;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
        }

        .period-month-header h4 {
            margin: 0;
            font-size: 1rem;
        }

        .period-month-summary {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .period-summary-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .period-summary-badge.not-logged {
            background: rgba(150, 150, 150, 0.4);
            color: var(--dark-text);
            border: 1px dashed #888;
        }

        body.dark-mode .period-summary-badge.not-logged {
            background: rgba(100, 100, 100, 0.5);
            color: var(--light-text);
        }

        .period-summary-badge.present {
            background: #4CAF50;
            color: white;
        }

        .period-summary-badge.absent {
            background: #f44336;
            color: white;
        }

        .period-summary-badge.cancelled {
            background: #9e9e9e;
            color: white;
        }

        .period-summary-badge.od {
            background: #2196F3;
            color: white;
        }

        .period-summary-badge.ml {
            background: #FF9800;
            color: white;
        }

        .period-month-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .period-month-section.collapsed .period-month-toggle {
            transform: rotate(-90deg);
        }

        .period-month-section.collapsed .period-month-content {
            display: none;
        }

        .period-grid-wrapper {
            overflow-x: auto;
        }

        .period-grid {
            display: grid;
            min-width: max-content;
            font-size: 0.85rem;
        }

        .period-grid-header {
            display: contents;
        }

        .period-grid-header>div {
            padding: 10px 5px;
            text-align: center;
            font-weight: 600;
            background: var(--light-bg);
            border-bottom: 2px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .period-grid-row {
            display: contents;
        }

        .period-grid-row>div {
            padding: 8px 4px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .period-date-cell {
            font-weight: 500;
            background: var(--light-bg);
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .period-cell {
            cursor: pointer;
            border-radius: 6px;
            margin: 2px;
            min-width: 40px;
            min-height: 28px;
            font-weight: 600;
            font-size: 0.75rem;
            transition: transform 0.2s, box-shadow 0.2s, filter 0.2s;
        }

        .period-cell:hover {
            transform: scale(1.15);
            filter: brightness(1.1);
        }

        /* Softer, eye-friendly status colors */
        .period-cell.present,
        .period-cell.default {
            background: rgba(76, 175, 80, 0.85);
            color: white;
        }

        .period-cell.absent {
            background: rgba(229, 115, 115, 0.9);
            color: white;
        }

        .period-cell.cancelled {
            background: rgba(158, 158, 158, 0.8);
            color: white;
        }

        .period-cell.od {
            background: rgba(100, 181, 246, 0.9);
            color: white;
        }

        .period-cell.ml {
            background: rgba(255, 183, 77, 0.9);
            color: #333;
        }

        .period-cell.free-period {
            background: rgba(200, 200, 200, 0.3);
            color: #999;
            cursor: default;
        }

        /* Not logged - distinct gray/neutral to indicate pending */
        .period-cell.not-logged {
            background: rgba(200, 200, 200, 0.4);
            color: var(--dark-text);
            border: 2px dashed var(--medium-text);
        }

        body.dark-mode .period-cell.not-logged {
            background: rgba(100, 100, 100, 0.4);
            color: var(--light-text);
            border: 2px dashed rgba(200, 200, 200, 0.5);
        }

        .period-cell.no-class {
            background: var(--light-bg);
            color: var(--medium-text);
            cursor: default;
            opacity: 0.6;
        }

        .period-cell.no-class:hover {
            transform: none;
            filter: none;
        }

        .period-cell.holiday {
            background: var(--light-bg);
            color: var(--medium-text);
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Dark mode adjustments for period cells */
        body.dark-mode .period-cell.present,
        body.dark-mode .period-cell.default {
            background: rgba(102, 187, 106, 0.75);
        }

        body.dark-mode .period-cell.absent {
            background: rgba(239, 154, 154, 0.75);
            color: #1a1a1a;
        }

        body.dark-mode .period-cell.cancelled {
            background: rgba(189, 189, 189, 0.6);
            color: #1a1a1a;
        }

        body.dark-mode .period-cell.od {
            background: rgba(144, 202, 249, 0.75);
            color: #1a1a1a;
        }

        body.dark-mode .period-cell.ml {
            background: rgba(255, 213, 79, 0.75);
            color: #1a1a1a;
        }

        body.dark-mode .period-cell.free-period {
            background: rgba(100, 100, 100, 0.3);
            color: #666;
        }

        .period-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: var(--light-bg);
            border-radius: var(--border-radius-md);
            justify-content: center;
        }

        .period-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .period-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .period-edit-popup {
            position: fixed;
            background: var(--card-bg);
            border-radius: var(--border-radius-md);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            padding: 10px;
            z-index: 1100;
            display: none;
        }

        .period-edit-popup button {
            display: block;
            width: 100%;
            padding: 8px 15px;
            margin: 3px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            font-size: 0.85rem;
        }

        .period-edit-popup button:hover {
            filter: brightness(0.9);
        }

        .timetable-message .config-btn {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-left: 8px;
        }

        /* Period Time Config Modal Styles */
        .period-config-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .period-config-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--light-bg);
            border-radius: var(--border-radius-md);
            margin-bottom: 10px;
        }

        .period-config-item label {
            font-weight: 600;
            min-width: 50px;
        }

        .period-config-item input[type="time"] {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            background: var(--card-bg);
            font-size: 0.9rem;
        }

        .period-config-item .time-separator {
            font-weight: 500;
            color: var(--medium-text);
        }

        /* Responsive - tablets */
        @media (max-width: 768px) {
            #timetableSection {
                padding: 10px;
            }

            #timetableSection h3 {
                font-size: 1rem;
                margin-bottom: 8px;
            }

            .timetable-header {
                padding: 5px 2px;
                font-size: 0.55rem;
            }

            .timetable-header .period-time {
                font-size: 0.45rem;
            }

            .timetable-day-label {
                padding: 5px 3px;
                font-size: 0.65rem;
                min-width: 35px;
            }

            .timetable-cell {
                padding: 3px 1px;
                min-height: 32px;
                min-width: 35px;
            }

            .subject-chip {
                padding: 3px 4px;
                font-size: 0.5rem;
                border-radius: 8px;
            }

            .timetable-message {
                font-size: 0.75rem;
                padding: 10px;
            }
        }

        /* Responsive - small phones (iPhone 12 Pro, Galaxy Z Fold) */
        @media (max-width: 400px) {
            #timetableSection {
                padding: 8px;
            }

            .timetable-header {
                font-size: 0.45rem;
                padding: 4px 1px;
            }

            .timetable-header .period-time {
                font-size: 0.38rem;
            }

            .timetable-day-label {
                font-size: 0.55rem;
                padding: 4px 2px;
                min-width: 28px;
            }

            .subject-chip {
                font-size: 0.42rem;
                padding: 2px 3px;
                border-radius: 6px;
            }

            .timetable-cell {
                min-height: 28px;
                min-width: 28px;
            }

            .timetable-message {
                font-size: 0.7rem;
            }

            .timetable-message .config-btn {
                display: block;
                margin: 8px auto 0;
            }
        }

        .status-indicator {
            font-size: 1.5rem;
        }


        /* Info Slider Styles - moved to line 2670+ with correct colors */

        #partialSubjectsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        /* Tabular View Styles (Desktop) */
        .analysis-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .analysis-table th,
        .analysis-table td {
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .analysis-table th {
            background: var(--light-bg);
            font-weight: 600;
        }

        .analysis-table tbody tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.03);
        }

        [data-theme="dark"] .analysis-table tbody tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .analysis-table .subject-cell {
            text-align: left;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .fixed-ui-button {
                top: 10px;
                width: 45px;
                height: 45px;
            }

            .hamburger-btn-fixed {
                left: 10px;
            }

            .theme-switch-wrapper {
                right: 10px;
            }

            .header {
                padding: 30px 20px;
                text-align: center;
            }

            .header h1 {
                font-size: 2rem;
            }

            .header p {
                font-size: 1rem;
            }

            .info-slider {
                max-width: 95%;
                padding: 10px 15px;
                margin: 15px auto 0;
                min-height: 50px;
            }

            .slide {
                font-size: 0.85rem;
                white-space: normal;
                padding: 5px 10px;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .main-content,
            .class-selector-section {
                padding: 20px;
            }

            .class-selector-header {
                flex-direction: column;
                align-items: stretch;
            }

            .class-selector-header h3 {
                text-align: center;
                margin-bottom: 15px;
            }

            .class-selector-header .header-actions {
                justify-content: center;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                /* Force 2 columns */
                gap: 10px;
            }

            .stat-item {
                padding: 10px;
                /* Reduce padding for mobile */
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .stat-value-editable {
                font-size: 1.5rem;
            }

            .stat-value-editable input {
                font-size: 1.5rem;
                width: 50px;
            }

            .subject-title {
                font-size: 1.3rem;
            }

            .modal-content {
                padding: 25px;
            }

            .help-main-heading {
                font-size: 1.1rem;
            }

            #helpModal .modal-content {
                font-size: 0.95rem;
            }

            .analysis-table {
                width: 100%;
                table-layout: fixed;
                /* Force columns to fit */
                font-size: 0.7rem;
            }

            .analysis-table th,
            .analysis-table td {
                padding: 4px 2px;
                /* Very tight padding */
                word-wrap: break-word;
            }

            .analysis-table input {
                width: 30px !important;
                padding: 2px !important;
                font-size: 0.7rem !important;
            }

            .analysis-table .subject-cell {
                width: 40px;
                /* Fixed width for subject acronym */
            }

            .analysis-table .stat-value-editable {
                flex-direction: column;
                gap: 2px;
            }

            .analysis-table .stat-value-editable span {
                display: none;
                /* Hide the slash separator */
            }

            /* Leave Planner Responsive Styles */
            .leave-period-entry,
            .compulsory-period-entry {
                flex-direction: row;
                flex-wrap: wrap;
                align-items: center;
                gap: 5px;
                padding: 8px;
            }

            .leave-period-entry label,
            .compulsory-period-entry label {
                font-size: 0.75rem;
                white-space: nowrap;
                min-width: 40px;
            }

            .leave-period-entry input[type="date"],
            .compulsory-period-entry input[type="date"] {
                flex: 1;
                min-width: 0;
                font-size: 0.85rem;
                padding: 8px 5px;
            }

            .remove-leave-period-btn,
            .remove-compulsory-period-btn {
                padding: 8px 12px;
                font-size: 1.2rem;
                min-width: 40px;
            }

            .add-leave-period-btn,
            .add-compulsory-period-btn {
                width: 100%;
                padding: 10px;
                font-size: 0.9rem;
                margin-top: 5px;
            }

            .weekend-finder-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .weekend-finder-controls .input-group {
                width: 100%;
            }

            .weekend-finder-controls .btn {
                width: 100%;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7);
            }

            70% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(255, 82, 82, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0);
            }
        }

        /* Preview Images Grid */
        .preview-section {
            margin: 20px 0;
            padding: 20px;
            background: var(--light-bg);
            border-radius: var(--border-radius-lg);
        }

        .preview-images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .preview-image-container {
            position: relative;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            overflow: hidden;
            background: var(--card-bg);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .preview-image-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .preview-image-container img {
            width: 100%;
            height: auto;
            max-height: 300px;
            object-fit: contain;
            display: block;
        }

        .preview-image-label {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .preview-images-grid {
                grid-template-columns: 1fr;
            }
        }

        .pulse-animation {
            animation: pulse 2s infinite;
            background: var(--danger-color) !important;
            /* Highlight urgent action */
        }

        /* WhatsApp Floating Button - LIQUID GLASS */
        .whatsapp-float {
            position: fixed;
            width: 56px;
            height: 56px;
            bottom: 90px;
            right: 20px;
            /* Bright glass green gradient with translucency */
            background: linear-gradient(135deg,
                    rgba(50, 230, 120, 0.88) 0%,
                    rgba(40, 210, 100, 0.88) 100%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            color: #FFF;
            border-radius: 50%;
            text-align: center;
            font-size: 30px;
            /* Glass border and depth */
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 8px 32px rgba(37, 211, 102, 0.4),
                0 2px 0 rgba(255, 255, 255, 0.3) inset,
                0 -2px 0 rgba(0, 0, 0, 0.1) inset;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            /* Spring transition */
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-decoration: none;
            animation: subtleFloat 3s ease-in-out infinite;
            animation-delay: 0.5s;
            overflow: hidden;
        }

        /* Shimmer overlay */
        .whatsapp-float::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg,
                    transparent 30%,
                    rgba(255, 255, 255, 0.3) 50%,
                    transparent 70%);
            transform: rotate(45deg) translateY(-100%);
            transition: transform 0.6s ease;
        }

        .whatsapp-float:hover {
            transform: scale(1.12);
            box-shadow:
                0 12px 40px rgba(37, 211, 102, 0.5),
                0 2px 0 rgba(255, 255, 255, 0.4) inset,
                0 0 40px rgba(18, 140, 126, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .whatsapp-float:hover::before {
            transform: rotate(45deg) translateY(100%);
        }

        .whatsapp-float:active {
            transform: scale(0.95);
            transition: all 0.1s ease;
        }

        .whatsapp-float svg {
            width: 28px;
            height: 28px;
            fill: white;
            position: relative;
            z-index: 1;
        }

        @media (max-width: 768px) {
            .whatsapp-float {
                width: 50px;
                height: 50px;
                bottom: 80px;
                right: 15px;
            }

            .whatsapp-float svg {
                width: 24px;
                height: 24px;
            }
        }

        /* === INFO SLIDER IN HEADER === */
        .info-slider {
            width: 100% !important;
            overflow: hidden !important;
            background: rgba(255, 255, 255, 0.15) !important;
            border-radius: 8px;
            margin-top: 15px;
            padding: 10px 0;
            position: relative !important;
            z-index: 100 !important;
            display: block !important;
            min-height: 40px;
        }

        .slider-track {
            display: flex !important;
            width: max-content !important;
            animation: marqueeEffect 120s linear infinite;
        }

        .slide {
            flex-shrink: 0;
            padding: 0 40px;
            font-size: 0.95rem;
            color: #ffffff !important;
            white-space: nowrap !important;
            font-weight: 500;
            opacity: 1 !important;
            visibility: visible !important;
        }

        @keyframes marqueeEffect {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-50%);
            }
        }

        /* Pause animation on hover */
        .info-slider:hover .slider-track {
            animation-play-state: paused;
        }

        /* Mobile optimization for slider */
        @media (max-width: 768px) {
            .slide {
                font-size: 0.8rem;
                padding: 0 20px;
            }

            .slider-track {
                animation-duration: 90s;
            }
        }

        /* === AI CHATBOT FLOATING BUTTON - LIQUID GLASS === */
        #aiChatbotButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            /* Bright glass gradient with translucency */
            background: linear-gradient(135deg,
                    rgba(130, 150, 255, 0.88) 0%,
                    rgba(160, 120, 255, 0.88) 100%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            color: white;
            cursor: pointer;
            /* Glass border and depth */
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 8px 32px rgba(102, 126, 234, 0.4),
                0 2px 0 rgba(255, 255, 255, 0.3) inset,
                0 -2px 0 rgba(0, 0, 0, 0.1) inset;
            z-index: 998;
            /* Spring transition */
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: subtleFloat 3s ease-in-out infinite;
            /* Shimmer container */
            overflow: hidden;
        }

        /* Shimmer overlay for chatbot button */
        #aiChatbotButton::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg,
                    transparent 30%,
                    rgba(255, 255, 255, 0.3) 50%,
                    transparent 70%);
            transform: rotate(45deg) translateY(-100%);
            transition: transform 0.6s ease;
        }

        @media (max-width: 768px) {
            #aiChatbotButton {
                width: 50px;
                height: 50px;
                bottom: 15px;
                right: 15px;
                font-size: 24px;
            }
        }

        #aiChatbotButton:hover {
            transform: scale(1.12);
            box-shadow:
                0 12px 40px rgba(102, 126, 234, 0.5),
                0 2px 0 rgba(255, 255, 255, 0.4) inset,
                0 0 40px rgba(118, 75, 162, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
            animation: edgeGlow 2s ease-in-out infinite;
        }

        #aiChatbotButton:hover::before {
            transform: rotate(45deg) translateY(100%);
        }

        #aiChatbotButton:active {
            transform: scale(0.95);
            animation: none;
            transition: all 0.1s ease;
        }

        @keyframes chatbot-pulse {

            0%,
            100% {
                box-shadow:
                    0 8px 32px rgba(102, 126, 234, 0.4),
                    0 2px 0 rgba(255, 255, 255, 0.3) inset;
            }

            50% {
                box-shadow:
                    0 12px 40px rgba(102, 126, 234, 0.6),
                    0 2px 0 rgba(255, 255, 255, 0.4) inset,
                    0 0 30px rgba(118, 75, 162, 0.3);
            }
        }

        .chat-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: rgba(255, 255, 255, 0.5);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: -4px 0 30px rgba(0, 0, 0, 0.25);
            border-left: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            transition: right 0.4s ease;
        }

        /* Dark mode chat panel */
        .dark-mode .chat-panel {
            background: rgba(26, 26, 46, 0.6);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-panel.active {
            right: 0;
        }

        /* Hide the floating button when panel is open */
        .chat-panel.active~#aiChatbotButton,
        body:has(.chat-panel.active) #aiChatbotButton {
            display: none !important;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 1.3rem;
        }

        .chat-header button {
            background: transparent;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
        }

        .faq-section {
            padding: 15px;
            background: var(--light-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .faq-section h4 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: var(--medium-text);
        }

        .faq-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .faq-btn {
            padding: 10px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: left;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--dark-text);
            transition: all 0.2s ease;
        }

        .faq-btn:hover {
            background: var(--primary-grad-start);
            color: white;
            border-color: var(--primary-grad-start);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: transparent;
        }

        .dark-mode .chat-messages {
            background: transparent;
        }

        .chat-message {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 0.9rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.bot {
            align-self: flex-start;
            background: var(--light-bg);
            color: var(--dark-text);
            border: 1px solid var(--border-color);
            border-bottom-left-radius: 4px;
        }

        .chat-message.system {
            align-self: center;
            background: transparent;
            color: var(--medium-text);
            font-size: 0.8rem;
            font-style: italic;
        }

        .faq-section {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            background: var(--light-bg);
        }

        .faq-section h4 {
            font-size: 0.85rem;
            color: var(--medium-text);
            margin-bottom: 10px;
        }

        .faq-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .faq-btn {
            padding: 8px 12px;
            font-size: 0.8rem;
            background: var(--card-bg);
            color: var(--dark-text);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .faq-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .chat-input-container {
            padding: 15px;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        /* Solid background for chat input in dark mode (no transparency) */
        body.dark-mode .chat-input-container {
            background: #1e1e1e;
        }

        .chat-input-container input {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .chat-input-container button {
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .chat-panel {
                width: 100%;
                right: -100%;
            }

            #aiChatbotButton {
                bottom: 15px;
                right: 15px;
                width: 50px;
                height: 50px;
            }
        }

        /* Toast Notification Styles */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            gap: 12px;
            pointer-events: auto;
            cursor: pointer;
            transform: translateY(-100px);
            opacity: 0;
            animation: toastSlideIn 0.4s ease forwards;
            max-width: 90vw;
        }

        .toast.hide {
            animation: toastSlideOut 0.3s ease forwards;
        }

        @keyframes toastSlideIn {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            to {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        .toast-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 0.9rem;
            opacity: 0.95;
        }

        .toast-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .toast-action {
            background: white;
            color: var(--primary-grad-start);
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85rem;
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .toast-action:hover {
            transform: scale(1.05);
        }

        /* Login Screen Styles */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
        }

        .login-container {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .login-logo {
            font-size: 4rem;
            margin-bottom: 10px;
        }

        .login-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        .login-btn {
            width: 100%;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .login-btn-google {
            background: white;
            color: #333;
            border: 1px solid #ddd;
        }

        .login-btn-google img {
            width: 20px;
            height: 20px;
        }

        .login-btn-guest {
            background: transparent;
            color: var(--text-secondary);
            border: 2px dashed var(--border-color);
        }

        .login-btn-guest:hover {
            border-color: var(--primary-grad-start);
            color: var(--primary-grad-start);
        }

        .login-divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: var(--text-secondary);
        }

        .login-divider::before,
        .login-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        .login-divider span {
            padding: 0 15px;
            font-size: 0.85rem;
        }

        .login-feature {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        /* Account Section in Settings */
        .account-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .account-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .account-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .account-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .account-details {
            flex: 1;
        }

        .account-name {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        .account-email {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .account-sync-status {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        .account-actions {
            display: flex;
            gap: 10px;
        }

        .account-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .account-btn-sync {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: white;
        }

        .account-btn-signout {
            background: var(--glass-bg);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .guest-upgrade-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px dashed var(--primary-grad-start);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .guest-upgrade-card h4 {
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .guest-upgrade-card p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
    </style>
</head>

<body>
    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <!-- Universal Backdrop Overlay - Blocks all interactions when panels are open -->
    <div id="appBackdrop" class="app-backdrop" onclick="closeAllPanels()"></div>

    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen" style="display: none;">
        <div class="login-container">
            <div class="login-logo">📚</div>
            <h1 class="login-title">Welcome to Bunkit</h1>
            <p class="login-subtitle">Smart Attendance Manager</p>

            <button class="login-btn login-btn-google" onclick="signInWithGoogle()">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
                Continue with Google
            </button>
            <p class="login-feature">☁️ Sync across all devices</p>

            <div class="login-divider"><span>or</span></div>

            <button class="login-btn login-btn-guest" onclick="continueAsGuest()">
                👤 Continue as Guest
            </button>
            <p class="login-feature">📱 Data stays on this device</p>
        </div>
    </div>

    <button class="hamburger-btn-fixed fixed-ui-button" onclick="openNav()">&#9776;</button>
    <div class="theme-switch-wrapper fixed-ui-button">
        <label class="theme-switch" for="theme-checkbox" title="Toggle Dark/Light Mode">
            <input type="checkbox" id="theme-checkbox" aria-label="Toggle Dark Mode" />
            <div class="slider"></div>
        </label>
    </div>

    <!-- WhatsApp Floating Button -->
    <a href="https://wa.me/916386854875?text=Hi!%20I%20need%20help%20with%20Bunk%20it%20app" class="whatsapp-float"
        target="_blank" rel="noopener noreferrer" title="Contact Developer on WhatsApp">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
            <path
                d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z" />
        </svg>
    </a>

    <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="close-btn" onclick="closeNav()">&times;</a>

        <!-- Account Section at Top -->
        <div id="sidebarAccountHeader"
            style="padding: 15px; background: var(--light-bg); border-bottom: 1px solid var(--border-color); margin-bottom: 10px;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <div id="sidebarUserAvatar"
                    style="width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end)); display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem; font-weight: 600;">
                    👤</div>
                <div style="flex: 1;">
                    <div id="sidebarUserName" style="font-weight: 600; color: var(--main-text); font-size: 1rem;">Guest
                        User</div>
                    <div id="sidebarUserEmail" style="font-size: 0.75rem; color: var(--medium-text);">Not signed in
                    </div>
                </div>
            </div>
        </div>

        <!-- Account Options -->
        <a href="#" onclick="openProfileNameModal(); closeNav();">✏️ Edit Profile Name</a>
        <a href="#" id="sidebarSignInBtn" onclick="signInWithGoogle(); closeNav();">🔐 Sign in with Google</a>
        <a href="#" id="sidebarSyncBtn" onclick="syncWithDrive(); closeNav();" style="display: none;">☁️ Sync with
            Google Drive</a>
        <div id="sidebarLastSynced"
            style="display: none; padding: 5px 22px; font-size: 0.75rem; color: var(--medium-text);">
            🕐 Last synced: Never
        </div>
        <a href="#" id="sidebarSignOutBtn" onclick="signOutGoogle(); closeNav();"
            style="display: none; color: #dc3545;">🚪 Sign Out</a>

        <div style="height: 1px; background: var(--border-color); margin: 10px 15px;"></div>

        <!-- File Options -->
        <a href="#" class="sidenav-dropdown-toggle" onclick="toggleDropdown(this)">📁 File <span>▾</span></a>
        <div class="sidenav-dropdown-content">
            <a href="#" onclick="openImportModal(); closeNav();">Import Class (JSON)</a>
            <a href="#" onclick="openExportModal(); closeNav();">Export Class (JSON)</a>
            <a href="#" onclick="openBackupModal(); closeNav();">Backup All Data</a>
            <a href="#" onclick="openRestoreModal(); closeNav();">Restore from Backup</a>
            <a href="#" onclick="restoreDefaultClass(); closeNav();">Restore Default Class</a>
        </div>

        <a href="#" onclick="openNotificationSettings(); closeNav();">🔔 Notification Settings</a>
        <a href="#" onclick="openAPISettings(); closeNav();">🔑 API Settings</a>
        <a href="#" class="sidenav-dropdown-toggle" onclick="toggleDropdown(this)">👁️ View Options <span>▾</span></a>
        <div class="sidenav-dropdown-content">
            <a href="#" onclick="switchView('cards')">🗂️ Card View</a>
            <a href="#" onclick="switchView('table')">📊 Table View</a>
            <a href="#" onclick="switchView('graph')">📈 Analytics Graph</a>
        </div>

        <a href="#" id="periodViewMenuItem" onclick="openPeriodAttendanceModal(); closeNav();" style="display: none;">📊
            Period-wise Attendance</a>

        <a href="#" onclick="openHelpModal(); closeNav();">💡 How to Use</a>

        <!-- Legal & Info Dropdown -->
        <a href="#" class="sidenav-dropdown-toggle" onclick="toggleDropdown(this)">📋 Legal & Info <span>▾</span></a>
        <div class="sidenav-dropdown-content">
            <a href="/about.html" onclick="closeNav();">ℹ️ About Us</a>
            <a href="/faq.html" onclick="closeNav();">❓ FAQ</a>
            <a href="/support.html" onclick="closeNav();">🆘 Support</a>
            <a href="/contact.html" onclick="closeNav();">📞 Contact Us</a>
            <a href="/privacy.html" onclick="closeNav();">🔒 Privacy Policy</a>
            <a href="/terms.html" onclick="closeNav();">📜 Terms of Service</a>
        </div>

        <a href="#" onclick="openDonateModal(); closeNav();" style="color: #ff6b6b; font-weight: 600;">☕ Buy Me a
            Coffee</a>

        <!-- Instagram Follow Button (Small) -->
        <a href="https://www.instagram.com/_faisal.in?igsh=MTd1dzFrMHNzY3JjNA==" target="_blank"
            rel="noopener noreferrer"
            style="display: flex; align-items: center; justify-content: center; gap: 6px; padding: 8px 14px; margin: 8px 15px; background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888); color: white; font-weight: 500; font-size: 0.85rem; border-radius: 8px; text-decoration: none;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z" />
            </svg>
            Follow on Instagram
        </a>
        <div style="padding: 8px 15px; font-size: 0.75rem; color: var(--medium-text); text-align: center;">
            Made by <strong>Faisal Khan</strong>
        </div>
    </div>
    <div id="menuOverlay" class="menu-overlay" onclick="closeNav()"></div>

    <div class="container">
        <header class="header">
            <h1>Bunk it</h1>
            <p class="header-subtitle" style="font-size: 1.1rem; opacity: 0.9; margin-top: 5px;">Manage your attendance
                like a pro</p>

            <!-- Info Slider -->
            <div class="info-slider"
                style="display: block; width: 100%; overflow: hidden; background: rgba(255,255,255,0.15); border-radius: 8px; margin-top: 15px; padding: 10px 0; min-height: 40px;">
                <div class="slider-track" id="sliderTrack"
                    style="display: flex; width: max-content; animation: marqueeEffect 120s linear infinite;">
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        💡 Portal Mode: Track daily attendance with automatic calculations</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        ⚠️ OCR is 95% accurate - always verify extracted numbers with your screenshot</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🚀 Fast Setup: Use AI to generate JSON from your timetable screenshot</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📊 3 View Options: Card View (detailed), Table View (compact), Graph View (visual)</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        ⚡ Edit Anytime: Click attended/total numbers to update in any view</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🎯 Settings: Toggle between Per-Subject or Overall attendance mode</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📱 100% Offline: All data saved locally - works without internet</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🔔 Notifications: Set daily reminders to mark your attendance</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📅 History Editor: View and edit past logs using the calendar</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        ✨ Safe Skip %: Shows your % after skipping maximum allowed classes</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🔄 Backup/Restore: Save all classes to file and restore on any device</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📤 Export/Import: Share class setup with friends via JSON</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🗓️ Daily Dashboard: Color-coded status (🔴Critical 🟡Low 🟢Safe) for today's classes</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📝 Daily Logs: Track attended/skipped/cancelled classes for accuracy</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🏖️ Leave Planner: Enter planned leaves to see impact on attendance</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🎪 Max Safe Leave: Find exact dates you can skip without issues</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🌴 Long Weekend Finder: Discover best leave days for extended breaks</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📊 Can I Skip Today?: Quick check for today's class impact</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        🤖 Smart Baseline: Portal logs before baseline intelligently merged</div>
                    <div class="slide"
                        style="flex-shrink: 0; padding: 0 40px; font-size: 0.95rem; color: #ffffff; white-space: nowrap; font-weight: 500;">
                        📜 Auto History: Last 10 calculations saved - restore anytime</div>
                </div>
            </div>
        </header>

        <div class="class-selector-section">
            <div class="class-selector-header">
                <h3>📚 Select Your Class</h3>
                <div class="header-actions">
                    <button class="btn primary-btn" onclick="openAddClassModal()"
                        style="padding: 8px 20px; font-size: 0.9rem;">+ Add Class</button>
                    <button class="btn warning-btn" onclick="editSelectedClass()">Edit/Share (Class)</button>
                    <button class="btn danger-btn" onclick="deleteSelectedClass()">Delete Class</button>
                    <button class="btn info-btn" onclick="openPortalSetup()" id="portalBtn">Student Portal</button>
                    <input type="file" id="restoreInput" onchange="restoreData(event)" accept=".json"
                        style="display: none;">
                </div>
                <div class="class-search-wrapper">
                    <input type="text" class="class-search" id="classSearch"
                        placeholder="🔍 Type to search for a class..." oninput="handleSearchInput()"
                        list="class-suggestions">
                    <datalist id="class-suggestions"></datalist>
                </div>
                <select class="class-dropdown" id="classSelector" onchange="handleDropdownChange()"
                    aria-label="Select Class"></select>
            </div>

            <div id="timetableSection" style="display: none;">
                <h3>📅 Weekly Timetable</h3>
                <div class="timetable-wrapper">
                    <div id="timetableGrid" class="timetable-grid"></div>
                </div>
            </div>
            <div id="portalDashboardSection" style="display: none;"></div>

            <div class="main-content">
                <div id="classSelectedContent" style="display: none;">
                    <div class="upload-section" id="uploadSection">
                        <div class="upload-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"
                                stroke-linejoin="round" class="feather feather-upload-cloud">
                                <path d="M16 16l-4-4-4 4M12 12v9"></path>
                                <path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path>
                                <path d="M16 16l-4-4-4 4"></path>
                            </svg>
                        </div>
                        <h3>Upload Attendance Screenshot(s)</h3>
                        <p>Drag & drop your file(s) here or click to browse. You can select multiple images.</p>
                        <input type="file" id="imageInput" class="upload-input" accept="image/*" multiple>
                        <div class="upload-btn-group">
                            <button class="btn primary-btn"
                                onclick="document.getElementById('imageInput').click()">Choose
                                Image(s)</button>
                            <button class="btn secondary-btn" onclick="showInputMode('manual')">Manual
                                Entry</button>
                            <button class="btn secondary-btn" onclick="showInputMode('json')">Paste JSON</button>
                        </div>
                    </div>

                    <div class="preview-section" id="previewSection" style="display: none;">
                        <h4 style="margin-bottom: 15px; color: var(--dark-text);">📸 Uploaded Images Preview:</h4>
                        <div id="previewImagesGrid" class="preview-images-grid"></div>
                    </div>

                    <div class="loading" id="loadingSection">
                        <div class="spinner"></div>
                        <p>Processing image and extracting attendance data...</p>
                    </div>


                    <div class="settings-section">
                        <h3>⚙️ Calculation Settings</h3>
                        <div class="grid-inputs">
                            <div class="input-group">
                                <label for="minAttendanceInput">Minimum Attendance %</label>
                                <input type="number" id="minAttendanceInput" value="75" min="1" max="100"
                                    oninput="triggerRecalculation()">
                            </div>
                            <div class="input-group">
                                <label>Calculation Mode</label>
                                <div class="toggle-group" style="margin-top: 10px;">
                                    <span>Per-Subject</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="overallCriteriaCheckbox"
                                            onchange="triggerRecalculation()">
                                        <span class="slider"></span>
                                    </label>
                                    <span>Overall</span>
                                </div>
                            </div>
                            <div class="input-group" style="justify-content: flex-end;">
                                <button class="btn info-btn" onclick="checkSkipToday()">🤔 Can I Skip
                                    Today?</button>
                            </div>
                        </div>
                    </div>

                    <div class="date-section">
                        <h3>📅 Semester Timeline</h3>
                        <div class="grid-inputs">
                            <div class="input-group"><label for="currentDate">Current Date:</label><input type="date"
                                    id="currentDate" onchange="updateDailyDashboard()"></div>
                            <div class="input-group"><label for="lastDate">Last Working Date:</label><input type="date"
                                    id="lastDate"></div>
                        </div>
                    </div>

                    <div class="manual-input" id="manualInput">
                        <h3>📝 Manual Attendance Entry</h3>
                        <div class="subjects-grid" id="subjectsGrid"></div>
                        <button class="calculate-btn" onclick="calculateFromManual()">Calculate Attendance</button>
                    </div>

                    <div class="manual-input" id="jsonInput">
                        <h3>📄 Paste Attendance JSON</h3>
                        <div class="json-instructions">
                            <strong>How to use:</strong>
                            <ol>
                                <li>Click "Copy AI Prompt" and paste it into an AI chat (like Gemini) with your
                                    attendance
                                    screenshot.</li>
                                <li>The AI will generate a JSON code block. Copy it.</li>
                                <li>Paste the JSON into the text box below and click "Calculate".</li>
                            </ol>
                        </div>
                        <button class="btn secondary-btn" onclick="copyAttendanceAIPrompt()"
                            style="width: 100%; margin: 15px 0;">📋 Copy Prompt for AI</button>
                        <div class="form-group">
                            <textarea id="attendanceJsonPasteArea"
                                placeholder='{ "SUBJECT-CODE-1": { "total": 40, "present": 35 }, "SUBJECT-CODE-2": { "total": 42, "present": 30 } }'
                                style="min-height: 150px; font-family: monospace;"></textarea>
                        </div>
                        <button class="calculate-btn" onclick="calculateFromJson()">Calculate from JSON</button>
                    </div>


                    <div class="results-section" id="resultsSection"></div>

                    <div id="pdfDownloadContainer" style="text-align: center; margin-top: 30px;"></div>

                    <div id="leavePlannerSection" style="display: none;"></div>

                    <div id="maxLeaveRecommendation" style="display: none;"></div>

                    <div id="maxPossibleBunkResults" style="display: none;"></div>

                    <div id="medicalLeaveSection" style="display: none; margin-top: 20px;"></div>

                    <div id="leaveRecommendationContainer" style="display: none;">
                        <div class="subject-card" style="border-left-color: var(--info-color);">
                            <div class="subject-title">💡 Long Weekend Finder</div>
                            <p>Find the best time to take leave for the longest possible break.</p>
                            <div class="weekend-finder-controls">
                                <div class="input-group">
                                    <label for="numLeaveDays">Number of leave days to use:</label>
                                    <input type="number" id="numLeaveDays" value="1" min="1" max="10"
                                        style="padding: 10px;">
                                </div>
                                <button class="btn info-btn" onclick="findLongWeekends()" style="margin: 0;">Find
                                    Best
                                    Break</button>
                            </div>
                            <div id="longWeekendFinderResult" style="margin-top: 20px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal" id="addClassModal"></div>
        <div class="modal" id="partialEntryModal"></div>
        <div class="modal" id="exportModal"></div>
        <div class="modal" id="skipTodayModal"></div>
        <div class="modal" id="dailyLogModal"></div>
        <div class="modal" id="helpModal"></div>
        <div class="modal" id="donateModal"></div>
        <div class="modal" id="privacyPolicyModal"></div>
        <div class="modal" id="periodAttendanceModal"></div>
        <div class="modal" id="customScheduleModal"></div>
        <div class="modal" id="notificationSettingsModal">
            <div class="modal-content">
                <button class="modal-close" onclick="closeModal('notificationSettingsModal')">&times;</button>
                <div class="modal-header">
                    <h2>🔔 Notification Settings</h2>
                    <p>Get daily reminders to log your attendance</p>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="notificationEnabled" onchange="toggleNotifications(this.checked)"
                            style="width: auto;">
                        <span>Enable Daily Notifications</span>
                    </label>
                </div>
                <div class="form-group" id="notificationTimeGroup" style="display: none;">
                    <label for="notificationTime">Notification Time:</label>
                    <input type="time" id="notificationTime" value="16:30">
                    <p style="font-size: 0.85rem; color: var(--medium-text); margin-top: 5px;">
                        You'll receive a daily reminder to log your attendance at this time (in your local
                        timezone).
                    </p>
                    <p style="font-size: 0.75rem; color: var(--medium-text); margin-top: 5px;" id="timezoneInfo">
                    </p>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn primary-btn" onclick="saveNotificationSettings()">Save Settings</button>
                </div>
            </div>
        </div>
        <div class="modal" id="portalSetupModal"></div>
        <div class="modal" id="historyLogModal"></div>
        <div class="modal" id="backupOptionsModal"></div>
        <div class="modal" id="restoreOptionsModal"></div>
        <div class="modal" id="ocrSettingsModal"></div>

        <!-- AI Chatbot Floating Button -->
        <button id="aiChatbotButton" onclick="openAIChatbot()"
            style="display: flex; border: none; cursor: pointer; align-items: center; justify-content: center;">
            🤖
        </button>

        <!-- AI Chat Panel -->
        <div id="aiChatPanel" class="chat-panel">
            <!-- Chat Header -->
            <div
                style="padding: 15px 20px; background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end)); color: white; display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5rem;">🤖</span>
                    <span style="font-weight: 600; font-size: 1.1rem;">AI Assistant</span>
                </div>
                <button onclick="closeAIChatbot()"
                    style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer;">×</button>
            </div>

            <!-- FAQ Section -->
            <div class="faq-section">
                <h4>Quick Questions:</h4>
                <div class="faq-buttons">
                    <button class="faq-btn" onclick="askFAQ('How do I add a new class?')">How do I add a new
                        class?</button>
                    <button class="faq-btn" onclick="askFAQ('What is Portal Mode?')">What is Portal Mode?</button>
                    <button class="faq-btn" onclick="askFAQ('How does OCR attendance scanning work?')">How does OCR
                        attendance scanning work?</button>
                    <button class="faq-btn" onclick="askFAQ('How do I get medical leave recommendations?')">How do I get
                        medical leave recommendations?</button>
                    <button class="faq-btn"
                        onclick="askFAQ('What is the difference between upload and manual mode?')">What's the
                        difference between upload and manual mode?</button>
                </div>
            </div>

            <!-- Chat Messages -->
            <div id="chatMessages" class="chat-messages" style="flex: 1; overflow-y: auto; padding: 15px;">
                <div class="chat-message system">👋 Hi! I'm here to help you with the app. Ask me anything!</div>
            </div>

            <!-- Chat Input -->
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Ask about the app..."
                    onkeypress="if(event.key==='Enter') sendChatMessage()">
                <button onclick="sendChatMessage()">Send</button>
            </div>
        </div>

        <script>
            // --- GLOBAL ERROR HANDLER ---
            window.onerror = function (msg, url, line, col, error) {
                console.error('Global Error:', msg, url, line, col, error);
                // Only alert for critical script errors that might break functionality
                if (msg.includes('SyntaxError') || msg.includes('ReferenceError') || msg.includes('TypeError')) {
                    alert(`⚠️ App Error: ${msg}\n\nLine: ${line}\nPlease report this to the developer.`);
                }
                return false;
            };

            // --- GLOBAL STATE & CONSTANTS ---
            const defaultHolidays = ["2025-08-09", "2025-08-15", "2025-09-05", "2025-09-26", "2025-10-01", "2025-10-02", "2025-10-03", "2025-10-20", "2025-10-21", "2025-10-22", "2025-10-23", "2025-12-25"];
            const defaultExampleClass = { 'CSE Core - H (Example)': { lastDate: '2026-04-01', holidays: [...defaultHolidays], subjects: [{ name: "Data Structures & Algorithms", code: "21CSC201J", schedule: [1, 2, 1, 0, 1, 1, 0] }, { name: "Operating Systems", code: "21CSC202J", schedule: [2, 0, 2, 1, 0, 1, 0] }, { name: "Advanced Programming Practice", code: "21CSC203P", schedule: [1, 0, 1, 1, 2, 1, 0] }, { name: "Computer Org. & Architecture", code: "21CSS201T", schedule: [1, 1, 1, 1, 1, 1, 0] }, { name: "Design Thinking & Methodology", code: "21DCS201P", schedule: [1, 1, 0, 1, 1, 1, 0] }, { name: "Professional Ethics", code: "21LEM201T", schedule: [0, 1, 1, 0, 0, 0, 0] }, { name: "Transforms & BVP", code: "21MAB201T", schedule: [1, 1, 1, 1, 0, 1, 0] }, { name: "Class In Charge", code: "CL", schedule: [0, 0, 0, 1, 0, 0, 0] }] } };
            let classes = {};
            let selectedClass = null;
            let editingClassName = null;
            let ocrResultsCache = {};
            let currentAnalysisData = [];
            let isJsonMode = false;
            let calculationHistory = [];

            // Predefined color palette for subjects (timetable)
            const subjectColors = [
                '#4facfe', '#00f2fe', '#667eea', '#764ba2', '#f093fb', '#f5576c',
                '#4facfe', '#43e97b', '#38f9d7', '#fa709a', '#fee140', '#00c6fb',
                '#a18cd1', '#fbc2eb', '#ff9a9e', '#fad0c4', '#a8edea', '#fed6e3',
                '#d299c2', '#fef9d7', '#89f7fe', '#66a6ff', '#c471f5', '#12c2e9'
            ];

            // --- GOOGLE AUTH CONFIG ---
            // ⚠️ REPLACE THIS WITH YOUR CLIENT ID FROM GOOGLE CLOUD CONSOLE
            const GOOGLE_CLIENT_ID = '692376293711-jsrogchpholoqg7mutd4igb8nfp5jfd2.apps.googleusercontent.com';
            const DRIVE_SCOPE = 'https://www.googleapis.com/auth/drive.appdata';
            const BACKUP_FILENAME = 'bunkit_backup.json';
            const OAUTH_SCOPES = DRIVE_SCOPE + ' https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email';

            // --- GEMINI API (Keys now stored securely on server) ---
            // Personal API key from user settings
            function getPersonalGeminiKey() {
                return localStorage.getItem('personalGeminiKey');
            }

            // Call Gemini API via backend proxy (for OCR, class import, etc.)
            async function callGeminiProxy(action, payload) {
                const personalKey = getPersonalGeminiKey();

                if (personalKey) {
                    // Use personal key with direct call
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${personalKey}`;
                    return fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                } else {
                    // Use backend proxy
                    return fetch('/api/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action, ...payload })
                    });
                }
            }

            // Call Gemini API with fallback to proxy
            async function callGeminiAPI(prompt, retries = 3) {
                const personalKey = getPersonalGeminiKey();

                for (let i = 0; i < retries; i++) {
                    try {
                        let response;

                        if (personalKey) {
                            // Use personal key directly
                            response = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${personalKey}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{ parts: [{ text: prompt }] }],
                                        generationConfig: { temperature: 0.7, maxOutputTokens: 2048 }
                                    })
                                }
                            );
                        } else {
                            // Use backend proxy
                            response = await fetch('/api/gemini', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'generate',
                                    contents: [{ parts: [{ text: prompt }] }],
                                    generationConfig: { temperature: 0.7, maxOutputTokens: 2048 }
                                })
                            });
                        }

                        if (response.status === 429 || response.status === 403) {
                            console.warn('API rate limited, retrying...');
                            await new Promise(r => setTimeout(r, 1000));
                            continue;
                        }

                        if (!response.ok) throw new Error(`API error: ${response.status}`);

                        const data = await response.json();
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
                    } catch (error) {
                        console.error('Gemini API error:', error);
                        await new Promise(r => setTimeout(r, 500));
                    }
                }
                return 'Sorry, API unavailable. Set personal API key in Settings.';
            }

            let googleUser = null;
            let tokenClient = null;
            let gapiInited = false;
            let gisInited = false;

            // PKCE variables - stored for the token exchange
            let pkceCodeVerifier = null;

            // --- PKCE HELPER FUNCTIONS ---
            // Step 2 in diagram: Generate Code Verifier and Code Challenge

            function generateCodeVerifier() {
                // Generate a cryptographically random string of 43-128 characters
                const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
                const array = new Uint8Array(64);
                crypto.getRandomValues(array);
                return Array.from(array, byte => charset[byte % charset.length]).join('');
            }

            async function generateCodeChallenge(verifier) {
                // SHA-256 hash the verifier, then base64url encode
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode(...new Uint8Array(digest)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }

            // --- GOOGLE OAUTH WITH PKCE (No Backend Required) ---
            // OAuth 2.1 best practice for SPAs: Authorization Code Flow with PKCE
            // More secure than implicit flow, protects against code interception attacks

            // PKCE Helper Functions
            function generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return base64UrlEncode(array);
            }

            async function generateCodeChallenge(verifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return base64UrlEncode(new Uint8Array(digest));
            }

            function base64UrlEncode(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }

            // OAuth Configuration
            const OAUTH_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth';
            const OAUTH_TOKEN_URL = 'https://oauth2.googleapis.com/token';
            const REDIRECT_URI = window.location.origin + window.location.pathname;

            function initGoogleAuth() {
                // Initialize Google API client for Drive access
                gapi.load('client', async () => {
                    await gapi.client.init({
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                    });
                    gapiInited = true;
                    maybeEnableSync();
                });

                // Also initialize GIS Token Client as fallback
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: OAUTH_SCOPES,
                    callback: handleTokenResponse,
                    error_callback: handleTokenError,
                });

                gisInited = true;

                // Check if we're returning from OAuth redirect
                handleOAuthCallback();

                maybeEnableSync();
                console.log('✅ Google OAuth initialized (PKCE Flow)');
            }

            // Handle OAuth callback (when returning from Google login)
            async function handleOAuthCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');

                if (!code) return; // Not a callback

                // Verify state to prevent CSRF
                const savedState = sessionStorage.getItem('oauth_state');
                if (state !== savedState) {
                    console.error('OAuth state mismatch - possible CSRF attack');
                    alert('❌ Security error. Please try again.');
                    cleanupOAuthParams();
                    return;
                }

                // Get saved code verifier for PKCE
                const codeVerifier = sessionStorage.getItem('code_verifier');
                if (!codeVerifier) {
                    console.error('No code verifier found');
                    cleanupOAuthParams();
                    return;
                }

                console.log('🔄 Exchanging authorization code for tokens...');
                showToast('🔐 Completing sign-in...', 'Please wait', { duration: 3000 });

                try {
                    // Exchange code for tokens (PKCE allows this without client_secret)
                    const tokenResponse = await fetch(OAUTH_TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: GOOGLE_CLIENT_ID,
                            code: code,
                            code_verifier: codeVerifier,
                            grant_type: 'authorization_code',
                            redirect_uri: REDIRECT_URI,
                        }),
                    });

                    const tokenData = await tokenResponse.json();

                    if (tokenData.error) {
                        // Check if it's the client_secret issue
                        if (tokenData.error === 'invalid_request' &&
                            tokenData.error_description?.includes('client_secret')) {
                            console.log('⚠️ PKCE requires Desktop app client type. Falling back to GIS Token Flow...');
                            showToast('🔄 Using alternative login...', 'Please wait', { duration: 2000 });
                            cleanupOAuthParams();

                            // Fall back to GIS Token Flow (works with Web Application client)
                            if (gisInited && tokenClient) {
                                requestToken({ prompt: 'consent' });
                            } else {
                                alert('❌ Please try again after page loads completely.');
                            }
                            return;
                        }
                        throw new Error(tokenData.error_description || tokenData.error);
                    }

                    console.log('✅ Tokens received via PKCE');

                    // Store token expiry
                    const expiresAt = Date.now() + (tokenData.expires_in * 1000);
                    localStorage.setItem('tokenExpiresAt', expiresAt.toString());

                    // Store refresh token if provided (for seamless refresh!)
                    if (tokenData.refresh_token) {
                        localStorage.setItem('refreshToken', tokenData.refresh_token);
                        console.log('✅ Refresh token stored for seamless sync!');
                    }

                    // Set token for gapi
                    gapi.client.setToken({ access_token: tokenData.access_token });

                    // Fetch user info
                    await fetchUserInfo(tokenData.access_token);

                    showToast('✅ Signed in successfully!', 'Sync enabled', { duration: 3000 });

                } catch (error) {
                    console.error('Token exchange failed:', error);
                    alert('❌ Sign-in failed: ' + error.message);
                } finally {
                    cleanupOAuthParams();
                }
            }

            function cleanupOAuthParams() {
                // Clean up URL and session storage
                sessionStorage.removeItem('oauth_state');
                sessionStorage.removeItem('code_verifier');

                // Remove OAuth params from URL
                const url = new URL(window.location);
                url.searchParams.delete('code');
                url.searchParams.delete('state');
                url.searchParams.delete('scope');
                window.history.replaceState({}, document.title, url.pathname);
            }

            // Start PKCE OAuth flow
            async function startPKCEFlow() {
                // Generate PKCE parameters
                const codeVerifier = generateCodeVerifier();
                const codeChallenge = await generateCodeChallenge(codeVerifier);
                const state = generateCodeVerifier(); // Random state for CSRF protection

                // Save for later use
                sessionStorage.setItem('code_verifier', codeVerifier);
                sessionStorage.setItem('oauth_state', state);

                // Build authorization URL
                const authUrl = new URL(OAUTH_AUTH_URL);
                authUrl.searchParams.set('client_id', GOOGLE_CLIENT_ID);
                authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
                authUrl.searchParams.set('response_type', 'code');
                authUrl.searchParams.set('scope', OAUTH_SCOPES);
                authUrl.searchParams.set('state', state);
                authUrl.searchParams.set('code_challenge', codeChallenge);
                authUrl.searchParams.set('code_challenge_method', 'S256');
                authUrl.searchParams.set('access_type', 'offline'); // Request refresh token
                authUrl.searchParams.set('prompt', 'consent'); // Force consent to get refresh token

                console.log('🔑 Starting PKCE OAuth flow...');

                // Redirect to Google login
                window.location.href = authUrl.toString();
            }

            // Silent refresh using stored refresh token
            async function refreshWithToken() {
                const refreshToken = localStorage.getItem('refreshToken');
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return null;
                }

                try {
                    console.log('🔄 Refreshing token silently...');

                    const response = await fetch(OAUTH_TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: GOOGLE_CLIENT_ID,
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token',
                        }),
                    });

                    const data = await response.json();

                    if (data.error) {
                        console.log('Refresh failed:', data.error);
                        // Refresh token expired/revoked
                        if (data.error === 'invalid_grant') {
                            localStorage.removeItem('refreshToken');
                        }
                        return null;
                    }

                    console.log('✅ Token refreshed silently!');

                    // Update token expiry
                    const expiresAt = Date.now() + (data.expires_in * 1000);
                    localStorage.setItem('tokenExpiresAt', expiresAt.toString());

                    // Update googleUser
                    if (googleUser) {
                        googleUser.accessToken = data.access_token;
                    }

                    // Set for gapi
                    gapi.client.setToken({ access_token: data.access_token });

                    return data.access_token;

                } catch (error) {
                    console.error('Refresh error:', error);
                    return null;
                }
            }

            function maybeEnableSync() {
                if (gapiInited && gisInited) {
                    console.log('✅ Google Auth ready');
                    checkLoginStatus();
                }
            }

            // Handle token errors (popup blocked, user cancelled, etc)
            function handleTokenError(error) {
                console.error('Token error:', error);
                if (error.type === 'popup_closed') {
                    console.log('User closed the popup');
                } else if (error.type === 'popup_failed_to_open') {
                    alert('⚠️ Popup blocked! Please allow popups for this site and try again.');
                }
            }

            // Handle successful token response
            async function handleTokenResponse(response) {
                if (response.error !== undefined) {
                    console.error('Auth error:', response);
                    if (response.error === 'access_denied') {
                        alert('❌ Access denied. Please grant the required permissions.');
                    } else {
                        alert('❌ Google sign-in failed. Please try again.');
                    }
                    return;
                }

                console.log('✅ Access token received');

                try {
                    // Store token expiry time (Google tokens last ~1 hour)
                    const expiresIn = response.expires_in || 3600;
                    const expiresAt = Date.now() + (expiresIn * 1000);
                    localStorage.setItem('tokenExpiresAt', expiresAt.toString());

                    // Set the token for gapi client
                    gapi.client.setToken({ access_token: response.access_token });

                    // Fetch user info and complete login
                    await fetchUserInfo(response.access_token);
                } catch (error) {
                    console.error('Auth failed:', error);
                    alert('❌ Authentication failed: ' + error.message);
                }
            }

            // Request new token (used for both login and refresh)
            function requestToken(options = {}) {
                if (!gisInited || !tokenClient) {
                    console.error('Google Auth not initialized');
                    return;
                }

                // Options: 
                // prompt: 'consent' - Always show consent (for first login or re-grant)
                // prompt: '' - Try silent (for refresh, may fail if no session)
                // prompt: 'select_account' - Let user choose account
                tokenClient.requestAccessToken(options);
            }


            async function fetchUserInfo(accessToken) {
                try {
                    const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                        headers: { 'Authorization': `Bearer ${accessToken}` }
                    });
                    const userInfo = await response.json();

                    googleUser = {
                        name: userInfo.name,
                        email: userInfo.email,
                        picture: userInfo.picture,
                        accessToken: accessToken
                    };

                    // Save to localStorage
                    localStorage.setItem('googleUser', JSON.stringify({
                        name: userInfo.name,
                        email: userInfo.email,
                        picture: userInfo.picture
                    }));
                    localStorage.setItem('isGuest', 'false');

                    // Hide login screen, update UI
                    hideLoginScreen();
                    updateAccountUI();

                    // Auto-sync on login
                    await syncWithDrive();

                    // Update sidebar account section
                    updateSidebarAccountUI();

                    // Check if first-time login - ask for name
                    checkFirstLoginPrompt();

                    console.log('✅ Signed in as:', userInfo.email);
                } catch (error) {
                    console.error('Failed to fetch user info:', error);
                    alert('❌ Failed to get user information.');
                }
            }

            // Main sign-in function
            // TEMPORARILY DISABLED - Database work in progress
            async function signInWithGoogle() {
                alert('🚧 Google Sign-In is temporarily unavailable.\n\nWe are currently working on the database.\n\nPlease click "Continue as Guest" for now. Your data will be saved locally on this device.');
                return;
            }

            function continueAsGuest() {
                localStorage.setItem('isGuest', 'true');
                localStorage.removeItem('googleUser');
                googleUser = null;
                hideLoginScreen();
                updateAccountUI();
                updateSidebarAccountUI();
                // Check if first-time user - show onboarding
                checkFirstLoginPrompt();
                console.log('👤 Continuing as guest');
            }

            async function signOutGoogle() {
                if (confirm('Sign out? Your data will be synced to Google Drive first.')) {
                    let syncSuccess = false;
                    try {
                        // Sync data before signing out
                        if (googleUser?.accessToken) {
                            showToast('☁️ Syncing before logout...', 'Please wait', { duration: 3000 });
                            syncSuccess = await syncWithDrive();
                        }
                    } catch (error) {
                        console.error('Sync before logout failed:', error);
                    }

                    // Warn if sync failed
                    if (!syncSuccess && googleUser?.accessToken) {
                        if (!confirm('⚠️ Sync failed! Recent changes may not be saved to cloud.\n\nSign out anyway?')) {
                            return; // User cancelled
                        }
                    }

                    // Revoke access token
                    if (googleUser?.accessToken) {
                        google.accounts.oauth2.revoke(googleUser.accessToken, () => {
                            console.log('Access token revoked');
                        });
                    }

                    // Clear all auth data
                    localStorage.setItem('isGuest', 'true');
                    localStorage.removeItem('googleUser');
                    localStorage.removeItem('tokenExpiresAt');
                    localStorage.removeItem('refreshToken'); // Clear PKCE refresh token
                    googleUser = null;

                    // Refresh page to show guest mode
                    alert('✅ Signed out successfully. Page will refresh.');
                    location.reload();
                }
            }

            // --- LOGIN SCREEN FUNCTIONS ---
            function showLoginScreen() {
                const loginScreen = document.getElementById('loginScreen');
                if (loginScreen) loginScreen.style.display = 'flex';
            }

            function hideLoginScreen() {
                const loginScreen = document.getElementById('loginScreen');
                if (loginScreen) loginScreen.style.display = 'none';
            }

            // --- MODAL HELPER FUNCTIONS ---
            function openModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'flex';
                    // Trigger reflow to enable CSS transition
                    modal.offsetHeight;
                    modal.classList.add('active');
                    document.body.classList.add('backdrop-active'); // Block body scroll
                }
            }

            function closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    // Add closing animation class
                    modal.classList.add('closing');
                    modal.classList.remove('active');
                    // Wait for iOS-style closing animation to complete
                    setTimeout(() => {
                        modal.style.display = 'none';
                        modal.classList.remove('closing');
                        // Only remove backdrop-active if no other modals are open
                        if (!document.querySelector('.modal.active')) {
                            document.body.classList.remove('backdrop-active');
                        }
                    }, 310);
                }
            }

            function checkLoginStatus() {
                const isGuest = localStorage.getItem('isGuest');
                const savedUser = localStorage.getItem('googleUser');

                // Debug logging
                console.log('🔍 checkLoginStatus called');
                console.log('   isGuest:', isGuest);
                console.log('   savedUser:', savedUser ? 'exists' : 'null');

                // PRIORITY 1: If we have a saved Google user, they're logged in
                if (savedUser) {
                    try {
                        googleUser = JSON.parse(savedUser);
                        // Ensure isGuest is set correctly
                        if (isGuest !== 'false') {
                            localStorage.setItem('isGuest', 'false');
                        }
                        updateAccountUI();
                        updateSidebarAccountUI();
                        console.log('✅ Returning Google user:', googleUser.email);
                        silentTokenRefresh();
                        return;
                    } catch (e) {
                        console.error('Failed to parse savedUser:', e);
                        localStorage.removeItem('googleUser');
                    }
                }

                // PRIORITY 2: Guest user (explicitly set)
                if (isGuest === 'true') {
                    console.log('👤 Guest user mode');
                    updateAccountUI();
                    updateSidebarAccountUI();
                    return;
                }

                // PRIORITY 3: First time user - show login screen
                console.log('🆕 First time user, showing login screen');
                showLoginScreen();
            }

            // Silent token refresh - uses stored refresh token for seamless sync
            async function silentTokenRefresh() {
                if (!googleUser) {
                    console.log('⚠️ Cannot refresh - no user');
                    return;
                }

                // Check if we have a recent token that might still be valid
                const expiresAt = parseInt(localStorage.getItem('tokenExpiresAt') || '0');
                const now = Date.now();

                // Only refresh if token expired or expiring soon (within 5 min)
                if (expiresAt > now + (5 * 60 * 1000)) {
                    console.log('✅ Token still valid, no refresh needed');
                    // Set the token for gapi if we have it in googleUser
                    if (googleUser.accessToken) {
                        gapi.client.setToken({ access_token: googleUser.accessToken });
                    }
                    // Still auto-sync
                    checkAndAutoSync();
                    return;
                }

                console.log('🔄 Token expired/expiring, attempting silent refresh...');

                // PRIORITY 1: Try PKCE refresh token (seamless like WhatsApp!)
                const newToken = await refreshWithToken();
                if (newToken) {
                    console.log('✅ Seamless refresh successful!');
                    checkAndAutoSync();
                    return;
                }

                // PRIORITY 2: Try GIS silent refresh as fallback
                if (gisInited && tokenClient) {
                    try {
                        console.log('🔄 Trying GIS silent refresh...');
                        requestToken({ prompt: '' });
                    } catch (error) {
                        console.log('Silent refresh failed:', error);
                        showToast('🔐 Session expired', 'Click Sync to reconnect', { duration: 4000 });
                    }
                } else {
                    showToast('🔐 Session expired', 'Click Sync to reconnect', { duration: 4000 });
                }
            }

            // Auto-sync on app open if last sync was more than 12 hours ago
            function checkAndAutoSync() {
                const isGuest = localStorage.getItem('isGuest') === 'true';
                const savedUser = localStorage.getItem('googleUser');

                if (!isGuest && savedUser && googleUser?.accessToken) {
                    const lastSyncTime = parseInt(localStorage.getItem('lastSyncTime') || '0');
                    const twelveHoursMs = 12 * 60 * 60 * 1000; // 12 hours in milliseconds
                    const now = Date.now();

                    if (now - lastSyncTime > twelveHoursMs) {
                        console.log('🔄 Auto-sync: Last sync was more than 12 hours ago, syncing now...');
                        setTimeout(() => {
                            syncWithDrive();
                        }, 2000); // Wait 2 seconds after app load
                    } else {
                        console.log('✅ Auto-sync: Last sync was within 12 hours, skipping auto-sync');
                    }
                }
            }

            function updateAccountUI() {
                const guestView = document.getElementById('guestAccountView');
                const googleView = document.getElementById('googleAccountView');

                if (!guestView || !googleView) return;

                const isGuest = localStorage.getItem('isGuest') === 'true';
                const savedUser = localStorage.getItem('googleUser');

                if (!isGuest && savedUser) {
                    // Google user
                    const user = JSON.parse(savedUser);
                    guestView.style.display = 'none';
                    googleView.style.display = 'block';

                    document.getElementById('accountName').textContent = user.name || 'Google User';
                    document.getElementById('accountEmail').textContent = user.email || '';

                    const avatar = document.getElementById('accountAvatar');
                    if (user.picture) {
                        avatar.innerHTML = `<img src="${user.picture}" alt="Profile">`;
                    } else {
                        avatar.innerHTML = user.name ? user.name.charAt(0).toUpperCase() : '👤';
                    }

                    const lastSync = localStorage.getItem('lastDriveSync');
                    if (lastSync) {
                        document.getElementById('syncStatus').textContent =
                            `☁️ Last synced: ${new Date(lastSync).toLocaleString()}`;
                    }
                } else {
                    // Guest user
                    guestView.style.display = 'block';
                    googleView.style.display = 'none';
                }
            }

            // --- PROFILE NAME MANAGEMENT ---
            function createProfileModals() {
                // Create profile name modal if it doesn't exist
                if (!document.getElementById('profileNameModal')) {
                    const modalHTML = `
                    <div id="profileNameModal" class="modal">
                        <div class="modal-content" style="max-width: 400px;">
                            <button class="modal-close" onclick="closeModal('profileNameModal')">&times;</button>
                            <div class="modal-header">
                                <h2>✏️ Edit Profile Name</h2>
                                <p>Update your display name</p>
                            </div>
                            <div class="form-group">
                                <label>Your Name</label>
                                <input type="text" id="profileNameInput" placeholder="Enter your name" maxlength="50">
                            </div>
                            <div class="form-actions" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn secondary-btn" onclick="closeModal('profileNameModal')">Cancel</button>
                                <button class="btn primary-btn" onclick="saveProfileName()">💾 Save</button>
                            </div>
                        </div>
                    </div>`;
                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                }

                // Create first login prompt modal if it doesn't exist
                if (!document.getElementById('firstLoginPromptModal')) {
                    const firstLoginHTML = `
                    <div id="firstLoginPromptModal" class="modal">
                        <div class="modal-content" style="max-width: 420px;">
                            <div class="modal-header" style="text-align: center;">
                                <div style="font-size: 3rem; margin-bottom: 10px;">🎓</div>
                                <h2>Welcome to BunkIt!</h2>
                                <p>Let's get you set up. What should we call you?</p>
                            </div>
                            <div class="form-group">
                                <label>Your Name</label>
                                <input type="text" id="firstLoginNameInput" placeholder="Enter your name" maxlength="50">
                            </div>
                            <div class="form-actions" style="display: flex; justify-content: center; margin-top: 20px;">
                                <button class="btn primary-btn" onclick="saveFirstLoginName()" style="padding: 14px 40px; font-size: 1.1rem;">
                                    Continue →
                                </button>
                            </div>
                        </div>
                    </div>`;
                    document.body.insertAdjacentHTML('beforeend', firstLoginHTML);
                }
            }

            function openProfileNameModal() {
                const savedName = localStorage.getItem('userProfileName') || '';
                const modal = document.getElementById('profileNameModal');
                if (!modal) {
                    createProfileModals();
                }
                const nameInput = document.getElementById('profileNameInput');
                if (nameInput) nameInput.value = savedName;
                openModal('profileNameModal');
            }

            function saveProfileName() {
                const nameInput = document.getElementById('profileNameInput');
                const name = nameInput ? nameInput.value.trim() : '';
                if (name) {
                    localStorage.setItem('userProfileName', name);
                    updateSidebarAccountUI();
                    closeModal('profileNameModal');
                    showToast('Profile name updated successfully', 'success');
                } else {
                    alert('⚠️ Please enter a name');
                }
            }

            function saveFirstLoginName() {
                const nameInput = document.getElementById('firstLoginNameInput');
                const name = nameInput ? nameInput.value.trim() : '';
                if (name) {
                    localStorage.setItem('userProfileName', name);
                    updateSidebarAccountUI();
                    // Close modal with iOS animation
                    closeModal('firstLoginPromptModal');
                    // Show class setup modal after close animation completes
                    setTimeout(() => openOnboardingClassModal(), 350);
                } else {
                    showToast('Please enter your name to continue', 'warning');
                }
            }

            function checkFirstLoginPrompt() {
                const hasCompleted = localStorage.getItem('hasCompletedOnboarding');

                if (!hasCompleted) {
                    // First time user - show onboarding
                    setTimeout(() => {
                        createProfileModals();
                        const googleUser = JSON.parse(localStorage.getItem('googleUser') || '{}');
                        const firstLoginInput = document.getElementById('firstLoginNameInput');
                        if (firstLoginInput) firstLoginInput.value = googleUser.name || '';
                        openModal('firstLoginPromptModal');
                    }, 500);
                }
            }

            function openOnboardingClassModal() {
                createOnboardingClassModal();
                openModal('onboardingClassModal');
                // Bot will appear 3s after user clicks Example/Add Class buttons
            }

            function createOnboardingClassModal() {
                if (document.getElementById('onboardingClassModal')) return;

                const modal = document.createElement('div');
                modal.id = 'onboardingClassModal';
                modal.className = 'modal';
                modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header" style="text-align: center;">
                        <div style="font-size: 2.5rem; margin-bottom: 10px;">📚</div>
                        <h2>Setup Your Class</h2>
                        <p>Choose how you want to get started</p>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; padding: 15px 0;">
                        <button class="btn primary-btn" onclick="handleCreateNewClass();" style="padding: 18px; font-size: 1.1rem;">
                            ➕ Create New Class
                        </button>
                        <button class="btn secondary-btn" onclick="useExampleClass();" style="padding: 18px; font-size: 1.1rem;">
                            📝 Use Example Class
                        </button>
                    </div>
                </div>`;
                document.body.appendChild(modal);
            }

            function useExampleClass() {
                // Show Bot with glow after 3 seconds
                setTimeout(() => {
                    const botBtn = document.getElementById('aiChatbotButton');
                    const botPanel = document.getElementById('aiChatPanel');
                    if (botBtn) {
                        document.body.appendChild(botBtn);
                        botBtn.style.display = 'flex';
                        botBtn.style.zIndex = '2147483647';
                        botBtn.style.pointerEvents = 'auto';  // Ensure clicks are received
                        botBtn.style.position = 'fixed';  // Ensure fixed positioning
                        botBtn.classList.add('glowing-pulse');

                        // Store reference globally for click detection
                        window._bunkmateBot = botBtn;

                        // Direct click handler using addEventListener
                        botBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            e.preventDefault();

                            // Close ALL modals first
                            document.querySelectorAll('.modal.active').forEach(m => m.classList.remove('active'));

                            // Close tutorial overlay if present
                            const overlay = document.getElementById('bunkmateTutorialOverlay');
                            if (overlay) overlay.remove();

                            // Remove glow
                            this.classList.remove('glowing-pulse');

                            // Open chatbot panel - FORCE visibility with inline styles
                            const panel = document.getElementById('aiChatPanel');
                            if (panel) {
                                panel.classList.add('active');
                                panel.style.right = '0';
                                panel.style.display = 'flex';
                                panel.style.zIndex = '2147483647';
                            }
                        }, true);  // Capture phase
                    }
                    if (botPanel) {
                        document.body.appendChild(botPanel);
                        botPanel.style.zIndex = '2147483647';
                    }
                }, 3000);

                // Close modal with animation
                closeModal('onboardingClassModal');

                localStorage.setItem('hasCompletedOnboarding', 'true');

                // Select the example class in dropdown
                const classSelector = document.getElementById('classSelector');
                const exampleClassName = 'CSE Core - H (Example)';

                if (classSelector) {
                    classSelector.value = exampleClassName;
                    // Trigger change to load the class
                    if (typeof handleDropdownChange === 'function') {
                        handleDropdownChange();
                    }
                }

                // Open the Edit/Share Class form for the example class
                setTimeout(() => {
                    if (typeof editSelectedClass === 'function') {
                        editSelectedClass();
                    }
                }, 100);

                // Show Bunkmate tutorial after 3 seconds
                setTimeout(() => showBunkmateTutorial('example'), 3000);
            }

            function handleCreateNewClass() {
                // Show Bot with glow after 3 seconds
                setTimeout(() => {
                    const botBtn = document.getElementById('aiChatbotButton');
                    const botPanel = document.getElementById('aiChatPanel');
                    if (botBtn) {
                        document.body.appendChild(botBtn);
                        botBtn.style.display = 'flex';
                        botBtn.style.zIndex = '2147483647';
                        botBtn.style.pointerEvents = 'auto';  // Ensure clicks are received
                        botBtn.style.position = 'fixed';  // Ensure fixed positioning
                        botBtn.classList.add('glowing-pulse');

                        // Store reference globally for click detection
                        window._bunkmateBot = botBtn;

                        // Direct click handler using addEventListener
                        botBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            e.preventDefault();

                            // Close ALL modals first
                            document.querySelectorAll('.modal.active').forEach(m => m.classList.remove('active'));

                            // Close tutorial overlay if present
                            const overlay = document.getElementById('bunkmateTutorialOverlay');
                            if (overlay) overlay.remove();

                            // Remove glow
                            this.classList.remove('glowing-pulse');

                            // Open chatbot panel - FORCE visibility with inline styles
                            const panel = document.getElementById('aiChatPanel');
                            if (panel) {
                                panel.classList.add('active');
                                panel.style.right = '0';
                                panel.style.display = 'flex';
                                panel.style.zIndex = '2147483647';
                            }
                        }, true);  // Capture phase
                    }
                    if (botPanel) {
                        document.body.appendChild(botPanel);
                        botPanel.style.zIndex = '2147483647';
                    }
                }, 3000);

                // Close onboarding modal with animation
                closeModal('onboardingClassModal');
                // Mark onboarding as complete
                localStorage.setItem('hasCompletedOnboarding', 'true');
                // Open add class modal
                if (typeof openAddClassModal === 'function') {
                    openAddClassModal();
                }
                // Show Bunkmate tutorial after 3 seconds
                setTimeout(() => showBunkmateTutorial('newclass'), 3000);
            }

            // --- BUNKMATE TUTORIAL CLOUD ANIMATION ---
            let tutorialCloudIndex = 0;
            let tutorialMessages = [];
            let tutorialInterval = null;

            function showBunkmateTutorial(type) {
                const userName = localStorage.getItem('userProfileName') || 'Friend';

                // Tutorial messages in Hinglish
                const introMessages = [
                    `👋 Hey ${userName}! Main <b>Bunkmate</b> hoon - tumhara personal AI assistant jo tumhari attendance manage karne mein help karega!`,
                    `🎯 Bunkit app se tum dekh sakte ho ki <b>kitne lectures bunk</b> kar sakte ho bina attendance giraye. Mast hai na? 😎`,
                    `📊 App tumhe batayega ki <b>75% attendance</b> maintain karne ke liye kitne classes attend karne hain ya kitne bunk kar sakte ho!`
                ];

                const newClassMessages = [
                    `📝 <b>Form Entry Tab:</b> Yahaan manually apni class ka naam likho, last working date daalo, aur ek ek subject add karo with weekly schedule!`,
                    `📅 <b>Weekly Schedule:</b> Har subject ke liye Monday se Sunday tak <b>kitne lectures</b> hain wo batana hai. Jaise Monday ko 2 lectures, Tuesday ko 1, etc.`,
                    `🤖 <b>Inbuilt AI Import:</b> Sabse easy tarika! Apni <b>timetable ki photo</b> upload karo, AI khud subjects aur schedule extract kar lega!`,
                    `⚡ <b>AI Tip:</b> Best results ke liye <b>clear photo</b> lo jisme text properly dikh raha ho. Blurry photo se galat data aa sakta hai!`,
                    `📥 <b>Import from JSON:</b> Agar tumhare dost ne class export ki hai ya pehle backup liya tha, to yahan <b>paste</b> karke import karo!`,
                    `📱 <b>Scan QR:</b> Dost ki class ka QR code scan karo aur <b>instantly</b> same class import ho jayegi. Sharing is caring! 🤝`,
                    `🎓 <b>Pro Tip:</b> Class banana ke baad <b>hamburger menu</b> (☰) se backup le lo taaki data safe rahe!`,
                    `💬 <b>Need Help?</b> Kabhi bhi confuse ho to neeche right side mein mera <b>chat icon</b> 💬 hai - kuch bhi poocho!`
                ];

                const exampleMessages = [
                    `📚 Ye ek <b>Example Class</b> hai - CSE Core H semester ka demo! Isse samajh lo app kaise kaam karta hai.`,
                    `👀 Dekho - <b>Class Name</b> upar hai, <b>Last Working Date</b> semester end date hai, aur neeche saare <b>subjects</b> hain!`,
                    `📅 Har subject mein <b>Weekly Schedule</b> hai - matlab Mon-Sun kitne lectures hain. Ye attendance calculate karne ke liye zaroori hai!`,
                    `✏️ <b>Edit kaise kare:</b> Subject name click karke change karo, schedule mein numbers change karo, ya <b>Remove</b> button se delete karo!`,
                    `➕ <b>Naya Subject:</b> Neeche <b>"+ Add Subject"</b> button hai - click karke apne subjects add karo!`,
                    `💾 <b>Save karna mat bhoolna:</b> Saare changes karne ke baad <b>Save Class</b> button zaroor dabao!`,
                    `📊 <b>Attendance Track:</b> Save karne ke baad main screen pe subjects dikhenge - wahan se daily attendance mark karo!`,
                    `💬 <b>Confused?</b> Koi tension nahi! Neeche right side mein mera <b>chat icon</b> 💬 hai - mujhse kuch bhi poocho, main hoon na! 🤗`
                ];

                tutorialMessages = [...introMessages, ...(type === 'newclass' ? newClassMessages : exampleMessages)];
                tutorialCloudIndex = 0;

                createTutorialOverlay();
                showNextCloud();
            }

            function createTutorialOverlay() {
                // Remove existing if any
                const existing = document.getElementById('bunkmateTutorialOverlay');
                if (existing) existing.remove();

                const overlay = document.createElement('div');
                overlay.id = 'bunkmateTutorialOverlay';
                overlay.innerHTML = `
                    <style>
                        #bunkmateTutorialOverlay {
                            position: fixed;
                            bottom: 90px;
                            right: 20px;
                            z-index: 100000;
                            pointer-events: none;
                        }
                        .bunkmate-cloud {
                            background: white;
                            color: #333;
                            padding: 15px 20px;
                            border-radius: 20px;
                            max-width: 320px;
                            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                            position: relative;
                            animation: cloudPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                            pointer-events: auto;
                            font-size: 0.95rem;
                            line-height: 1.5;
                        }
                        .bunkmate-cloud::after {
                            content: '';
                            position: absolute;
                            bottom: -10px;
                            right: 30px;
                            width: 20px;
                            height: 20px;
                            background: white;
                            transform: rotate(45deg);
                            box-shadow: 4px 4px 8px rgba(0,0,0,0.1);
                        }
                        .bunkmate-cloud-header {
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            margin-bottom: 8px;
                            font-weight: 600;
                            color: #6366f1;
                        }
                        .bunkmate-cloud-text {
                            color: #444;
                        }
                        .bunkmate-cloud-actions {
                            display: flex;
                            gap: 10px;
                            margin-top: 12px;
                            justify-content: flex-end;
                        }
                        .bunkmate-btn {
                            padding: 6px 14px;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 0.85rem;
                            font-weight: 500;
                            transition: all 0.2s;
                        }
                        .bunkmate-btn-next {
                            background: linear-gradient(135deg, #6366f1, #8b5cf6);
                            color: white;
                        }
                        .bunkmate-btn-next:hover {
                            transform: scale(1.05);
                        }
                        .bunkmate-btn-skip {
                            background: #f1f5f9;
                            color: #64748b;
                        }
                        .bunkmate-btn-skip:hover {
                            background: #e2e8f0;
                        }
                        .bunkmate-progress {
                            display: flex;
                            gap: 4px;
                            margin-top: 10px;
                            justify-content: center;
                        }
                        .bunkmate-dot {
                            width: 6px;
                            height: 6px;
                            border-radius: 50%;
                            background: #e2e8f0;
                        }
                        .bunkmate-dot.active {
                            background: #6366f1;
                        }
                        @keyframes cloudPop {
                            0% { transform: scale(0) translateY(50px); opacity: 0; }
                            100% { transform: scale(1) translateY(0); opacity: 1; }
                        }
                    </style>
                    <div class="bunkmate-cloud">
                        <div class="bunkmate-cloud-header">
                            <span>🤖</span> Bunkmate
                        </div>
                        <div class="bunkmate-cloud-text" id="bunkmateCloudText"></div>
                        <div class="bunkmate-progress" id="bunkmateProgress"></div>
                        <div class="bunkmate-cloud-actions">
                            <button class="bunkmate-btn bunkmate-btn-skip" onclick="closeBunkmateTutorial()">Skip</button>
                            <button class="bunkmate-btn bunkmate-btn-next" onclick="showNextCloud()" id="bunkmateNextBtn">Next →</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
            }

            function showNextCloud() {
                const textEl = document.getElementById('bunkmateCloudText');
                const progressEl = document.getElementById('bunkmateProgress');
                const nextBtn = document.getElementById('bunkmateNextBtn');

                if (!textEl || tutorialCloudIndex >= tutorialMessages.length) {
                    closeBunkmateTutorial();
                    return;
                }

                // Update cloud with animation
                const cloud = document.querySelector('.bunkmate-cloud');
                if (cloud) {
                    cloud.style.animation = 'none';
                    cloud.offsetHeight; // Trigger reflow
                    cloud.style.animation = 'cloudPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                }

                textEl.innerHTML = tutorialMessages[tutorialCloudIndex];

                // Update progress dots
                progressEl.innerHTML = tutorialMessages.map((_, i) =>
                    `<div class="bunkmate-dot ${i === tutorialCloudIndex ? 'active' : ''}"></div>`
                ).join('');

                // Update button text on last message
                if (tutorialCloudIndex === tutorialMessages.length - 1) {
                    nextBtn.textContent = 'Done ✓';
                } else {
                    nextBtn.textContent = 'Next →';
                }

                tutorialCloudIndex++;
            }

            function closeBunkmateTutorial() {
                const overlay = document.getElementById('bunkmateTutorialOverlay');
                if (overlay) {
                    overlay.style.transition = 'opacity 0.3s';
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.remove(), 300);
                }
                tutorialCloudIndex = 0;
                tutorialMessages = [];

                // Stop the bot icon glow when tutorial is skipped/finished
                const botBtn = document.getElementById('aiChatbotButton');
                if (botBtn) {
                    botBtn.classList.remove('glowing-pulse');
                }
            }

            function createProfileModals() {
                if (document.getElementById('profileNameModal')) return;

                // Profile Name Modal
                const profileModal = document.createElement('div');
                profileModal.id = 'profileNameModal';
                profileModal.className = 'modal';
                profileModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <button class="modal-close" onclick="closeModal('profileNameModal')">&times;</button>
                    <div class="modal-header">
                        <h2>👤 Edit Profile</h2>
                        <p>Customize how your name appears</p>
                    </div>
                    <div class="form-group">
                        <label for="profileNameInput">Your Name:</label>
                        <input type="text" id="profileNameInput" placeholder="Enter your name" maxlength="50">
                    </div>
                    <div class="form-actions">
                        <button class="btn primary-btn" onclick="saveProfileName()">💾 Save</button>
                        <button class="btn secondary-btn" onclick="closeModal('profileNameModal')">Cancel</button>
                    </div>
                </div>`;
                document.body.appendChild(profileModal);

                // First Login Prompt Modal
                const firstLoginModal = document.createElement('div');
                firstLoginModal.id = 'firstLoginPromptModal';
                firstLoginModal.className = 'modal';
                firstLoginModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header" style="text-align: center;">
                        <div style="font-size: 3rem; margin-bottom: 10px;">🎉</div>
                        <h2>Welcome to Bunk it!</h2>
                        <p>Let's personalize your experience</p>
                    </div>
                    <div class="form-group">
                        <label for="firstLoginNameInput">What should we call you?</label>
                        <input type="text" id="firstLoginNameInput" placeholder="Enter your name" maxlength="50" style="text-align: center; font-size: 1.1rem;">
                    </div>
                    <div class="form-actions" style="justify-content: center;">
                        <button class="btn primary-btn" onclick="saveFirstLoginName()" style="min-width: 150px;">Continue</button>
                    </div>
                </div>`;
                document.body.appendChild(firstLoginModal);
            }

            // Update sidebar account section UI
            function updateSidebarAccountUI() {
                const signInBtn = document.getElementById('sidebarSignInBtn');
                const syncBtn = document.getElementById('sidebarSyncBtn');
                const signOutBtn = document.getElementById('sidebarSignOutBtn');
                const lastSyncedDiv = document.getElementById('sidebarLastSynced');
                const userName = document.getElementById('sidebarUserName');
                const userEmail = document.getElementById('sidebarUserEmail');
                const userAvatar = document.getElementById('sidebarUserAvatar');

                if (!userName) return;

                const isGuest = localStorage.getItem('isGuest') === 'true';
                const savedUser = localStorage.getItem('googleUser');
                const profileName = localStorage.getItem('userProfileName');
                const lastSyncTime = localStorage.getItem('lastSyncTime');

                if (!isGuest && savedUser) {
                    // Google user
                    const user = JSON.parse(savedUser);
                    signInBtn.style.display = 'none';
                    syncBtn.style.display = 'block';
                    signOutBtn.style.display = 'block';

                    // Show last synced time
                    if (lastSyncedDiv) {
                        lastSyncedDiv.style.display = 'block';
                        if (lastSyncTime) {
                            const syncDate = new Date(parseInt(lastSyncTime));
                            const formattedDate = syncDate.toLocaleDateString('en-IN', { day: '2-digit', month: '2-digit', year: 'numeric' });
                            const formattedTime = syncDate.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
                            lastSyncedDiv.textContent = `🕐 Last synced: ${formattedDate}, ${formattedTime}`;
                        } else {
                            lastSyncedDiv.textContent = '🕐 Last synced: Never';
                        }
                    }

                    userName.textContent = profileName || user.name || 'User';
                    userEmail.textContent = user.email || '';

                    if (user.picture && userAvatar) {
                        userAvatar.innerHTML = `<img src="${user.picture}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                    } else if (userAvatar) {
                        const initial = (profileName || user.name || 'U').charAt(0).toUpperCase();
                        userAvatar.innerHTML = initial;
                    }
                } else {
                    // Guest user
                    signInBtn.style.display = 'block';
                    syncBtn.style.display = 'none';
                    signOutBtn.style.display = 'none';
                    if (lastSyncedDiv) lastSyncedDiv.style.display = 'none';

                    userName.textContent = profileName || 'Guest User';
                    userEmail.textContent = profileName ? 'Guest Mode' : 'Not signed in';

                    if (userAvatar) {
                        const initial = profileName ? profileName.charAt(0).toUpperCase() : '👤';
                        userAvatar.innerHTML = initial;
                    }
                }
            }

            // --- GOOGLE DRIVE SYNC FUNCTIONS ---
            async function uploadBackupToDrive() {
                if (!googleUser?.accessToken) {
                    console.log('No access token for upload');
                    return false;
                }

                try {
                    const backupData = getBackupDataObj();
                    backupData.metadata.syncTimestamp = new Date().toISOString();

                    // Check if file exists
                    const fileId = await findBackupFileId();

                    // Check if token was invalidated during findBackupFileId (403 error)
                    if (!googleUser?.accessToken) {
                        console.log('Token was cleared, consent requested. User needs to retry.');
                        return false;
                    }

                    if (fileId) {
                        // Update existing file
                        await updateDriveFile(fileId, backupData);
                    } else {
                        // Create new file
                        await createDriveFile(backupData);
                    }

                    localStorage.setItem('lastDriveSync', new Date().toISOString());
                    updateAccountUI();
                    console.log('✅ Backup uploaded to Drive');
                    return true;
                } catch (error) {
                    console.error('Upload to Drive failed:', error);
                    return false;
                }
            }

            async function downloadBackupFromDrive() {
                if (!googleUser?.accessToken) {
                    console.log('No access token for download');
                    return null;
                }

                try {
                    const fileId = await findBackupFileId();
                    if (!fileId) {
                        console.log('No backup file found in Drive');
                        return null;
                    }

                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
                        {
                            headers: { 'Authorization': `Bearer ${googleUser.accessToken}` }
                        }
                    );

                    // Handle 403 Forbidden - need fresh consent
                    if (response.status === 403 || response.status === 401) {
                        console.log('⚠️ Drive download access denied, user needs to grant permission');
                        googleUser.accessToken = null;
                        // Don't auto-request - popup blocked. Next sync click will trigger proper consent
                        return null;
                    }

                    if (!response.ok) throw new Error('Download failed');

                    const data = await response.json();
                    console.log('✅ Backup downloaded from Drive');
                    return data;
                } catch (error) {
                    console.error('Download from Drive failed:', error);
                    return null;
                }
            }

            async function findBackupFileId() {
                try {
                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&q=name='${BACKUP_FILENAME}'`,
                        {
                            headers: { 'Authorization': `Bearer ${googleUser.accessToken}` }
                        }
                    );

                    // Handle 403 Forbidden - need to request consent again
                    if (response.status === 403 || response.status === 401) {
                        console.log('⚠️ Drive access denied, user needs to grant permission...');
                        googleUser.accessToken = null; // Clear invalid token
                        // DON'T auto-request consent - popup will be blocked
                        // User needs to click Sync button which triggers user-action popup
                        alert('🔐 Google Drive permission needed!\n\nPlease click "Sync" button again to grant Drive access.');
                        return null;
                    }

                    const data = await response.json();
                    return data.files?.[0]?.id || null;
                } catch (error) {
                    console.error('Find file failed:', error);
                    return null;
                }
            }

            async function createDriveFile(backupData) {
                const metadata = {
                    name: BACKUP_FILENAME,
                    parents: ['appDataFolder']
                };

                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', new Blob([JSON.stringify(backupData)], { type: 'application/json' }));

                const response = await fetch(
                    'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
                    {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${googleUser.accessToken}` },
                        body: form
                    }
                );

                // Handle 403 Forbidden - need fresh consent
                if (response.status === 403 || response.status === 401) {
                    googleUser.accessToken = null;
                    // Don't auto-request - popup blocked. Next sync click will trigger proper consent
                    throw new Error('Drive permission denied');
                }

                if (!response.ok) throw new Error('Create file failed');
                return await response.json();
            }
            async function updateDriveFile(fileId, backupData) {
                const response = await fetch(
                    `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`,
                    {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${googleUser.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(backupData)
                    }
                );

                // Handle 403 Forbidden - need fresh consent
                if (response.status === 403 || response.status === 401) {
                    googleUser.accessToken = null;
                    // Don't auto-request - popup blocked. Next sync click will trigger proper consent
                    throw new Error('Drive permission denied');
                }

                if (!response.ok) throw new Error('Update file failed');
                return await response.json();
            }

            async function syncWithDrive() {
                // Check if user has token
                if (googleUser && !googleUser.accessToken) {
                    // Try to refresh token first
                    const newToken = await refreshWithToken();
                    if (newToken) {
                        console.log('✅ Token refreshed, proceeding with sync');
                    } else {
                        // No token and can't refresh - request via GIS
                        if (gisInited && tokenClient) {
                            showToast('🔐 Session expired', 'Please grant access', { duration: 3000 });
                            requestToken({ prompt: 'consent' });
                        } else {
                            alert('⚠️ Please sign in with Google first.');
                        }
                        return;
                    }
                }

                if (!googleUser?.accessToken) {
                    alert('⚠️ Please sign in with Google first.');
                    return;
                }

                try {
                    showToast('☁️ Syncing...', 'Connecting to Google Drive', { duration: 2000 });

                    const cloudBackup = await downloadBackupFromDrive();

                    // Check if token was invalidated during download (403 error)
                    if (!googleUser?.accessToken) {
                        console.log('Token was cleared during download, consent requested. User needs to retry.');
                        showToast('🔐 Permission needed', 'Please click Sync again after granting access', { duration: 4000 });
                        return;
                    }

                    const localBackup = getBackupDataObj();

                    // Check if local data is essentially empty
                    const localHasData = localBackup.stats && (
                        localBackup.stats.totalClasses > 0 ||
                        localBackup.stats.totalLogs > 0
                    );
                    const cloudHasData = cloudBackup && cloudBackup.stats && (
                        (cloudBackup.stats.totalClasses || 0) > 0 ||
                        (cloudBackup.stats.totalLogs || 0) > 0
                    );

                    // Check if this is the first sync for this Google account on this device
                    const syncedAccountsKey = 'syncedGoogleAccounts';
                    const syncedAccounts = JSON.parse(localStorage.getItem(syncedAccountsKey) || '[]');
                    const currentEmail = googleUser?.email;
                    const isFirstSyncForAccount = currentEmail && !syncedAccounts.includes(currentEmail);

                    if (!cloudBackup) {
                        // No cloud backup - upload local (even if empty, user is starting fresh)
                        if (localHasData) {
                            await uploadBackupToDrive();
                            showToast('☁️ Synced', 'Backup uploaded to Google Drive', { duration: 3000 });
                        } else {
                            showToast('☁️ Synced', 'No data to backup yet', { duration: 3000 });
                        }
                    } else {
                        // CRITICAL: Protect against data loss
                        // If local is empty but cloud has data, ALWAYS restore from cloud
                        if (!localHasData && cloudHasData) {
                            console.log('⚠️ Local data is empty but cloud has data - restoring from cloud');
                            restoreFromBackupData(cloudBackup);
                            showToast('☁️ Restored', 'Your data was restored from Google Drive', { duration: 4000 });
                            celebrateAchievement('goal-reached');
                            // Mark this account as synced on this device
                            if (currentEmail && !syncedAccounts.includes(currentEmail)) {
                                syncedAccounts.push(currentEmail);
                                localStorage.setItem(syncedAccountsKey, JSON.stringify(syncedAccounts));
                            }
                            localStorage.setItem('lastSyncTime', Date.now().toString());
                            localStorage.setItem('lastDriveSync', new Date().toISOString());
                            updateSidebarAccountUI();
                            return;
                        }

                        // FIRST SYNC PROTECTION: If this is first sync on this device AND both have data
                        // Compare timestamps to decide action
                        if (isFirstSyncForAccount && localHasData && cloudHasData) {
                            const cloudClasses = cloudBackup.stats?.totalClasses || 0;
                            const localClasses = localBackup.stats?.totalClasses || 0;
                            const cloudTime = new Date(cloudBackup.metadata?.syncTimestamp || cloudBackup.metadata?.timestamp || 0);
                            // Use lastAppInteraction (actual user activity) instead of backup timestamp
                            const localInteraction = localStorage.getItem('lastAppInteraction');
                            const localTime = localInteraction ? new Date(localInteraction) : new Date(0);

                            // If local is NOT newer than cloud, auto-restore from cloud (safe default)
                            if (localTime <= cloudTime) {
                                console.log('🔄 First sync: Local not newer than cloud, auto-restoring from cloud');
                                restoreFromBackupData(cloudBackup);
                                showToast('☁️ Restored', 'Your data was restored from Google Drive', { duration: 4000 });
                            } else {
                                // Local is NEWER - this is unusual, ask user (might be on friend's device)
                                const userChoice = confirm(
                                    `🔄 First sync on this device!\n\n` +
                                    `This device has NEWER data than your cloud backup:\n` +
                                    `☁️ Cloud backup: ${cloudClasses} class(es)\n` +
                                    `📱 This device: ${localClasses} class(es)\n\n` +
                                    `Choose wisely:\n` +
                                    `• OK = Restore YOUR backup from Google Drive\n` +
                                    `• Cancel = Keep this device's data (will overwrite cloud!)`
                                );

                                if (userChoice) {
                                    // User wants their cloud backup
                                    console.log('👤 User chose to restore from cloud (first sync protection)');
                                    restoreFromBackupData(cloudBackup);
                                    showToast('☁️ Restored', 'Your data was restored from Google Drive', { duration: 4000 });
                                } else {
                                    // User chose device data - double confirm for safety
                                    const doubleConfirm = confirm(
                                        `⚠️ Are you SURE?\n\n` +
                                        `This will PERMANENTLY replace your cloud backup ` +
                                        `(${cloudClasses} classes) with this device's data (${localClasses} classes).\n\n` +
                                        `This cannot be undone!`
                                    );

                                    if (doubleConfirm) {
                                        console.log('👤 User confirmed to upload local data (first sync protection)');
                                        await uploadBackupToDrive();
                                        showToast('☁️ Synced', 'Cloud backup replaced with this device data', { duration: 3000 });
                                    } else {
                                        // User cancelled - restore from cloud instead
                                        restoreFromBackupData(cloudBackup);
                                        showToast('☁️ Restored', 'Your data was restored from Google Drive', { duration: 4000 });
                                    }
                                }
                            }

                            // Mark this account as synced on this device
                            syncedAccounts.push(currentEmail);
                            localStorage.setItem(syncedAccountsKey, JSON.stringify(syncedAccounts));
                            localStorage.setItem('lastSyncTime', Date.now().toString());
                            localStorage.setItem('lastDriveSync', new Date().toISOString());
                            updateSidebarAccountUI();
                            return;
                        }

                        // Compare timestamps (only if local has data AND not first sync)
                        const cloudTime = new Date(cloudBackup.metadata?.syncTimestamp || cloudBackup.metadata?.timestamp || 0);
                        // Use lastAppInteraction (actual user activity) instead of backup timestamp
                        const localInteraction = localStorage.getItem('lastAppInteraction');
                        const localTime = localInteraction ? new Date(localInteraction) : new Date(0);

                        console.log('Cloud time:', cloudTime, 'Local interaction time:', localTime);
                        console.log('Local has data:', localHasData, 'Cloud has data:', cloudHasData);

                        if (cloudTime > localTime) {
                            // Cloud is newer - restore from cloud
                            console.log('☁️ Cloud backup is newer - restoring');
                            restoreFromBackupData(cloudBackup);
                            showToast('☁️ Synced', 'Data restored from Google Drive', { duration: 3000 });
                        } else if (localTime > cloudTime) {
                            // Local is newer - upload to cloud
                            console.log('📱 Local data is newer - uploading');
                            await uploadBackupToDrive();
                            showToast('☁️ Synced', 'Backup uploaded to Google Drive', { duration: 3000 });
                        } else {
                            showToast('☁️ Synced', 'Everything is up to date', { duration: 3000 });
                        }
                    }

                    // Mark this account as synced on this device
                    if (currentEmail && !syncedAccounts.includes(currentEmail)) {
                        syncedAccounts.push(currentEmail);
                        localStorage.setItem(syncedAccountsKey, JSON.stringify(syncedAccounts));
                    }

                    // Save sync timestamp
                    localStorage.setItem('lastSyncTime', Date.now().toString());
                    localStorage.setItem('lastDriveSync', new Date().toISOString());
                    updateSidebarAccountUI();
                } catch (error) {
                    console.error('Sync failed:', error);
                    showToast('❌ Sync Failed', error.message, { duration: 5000 });
                }
            }

            function restoreFromBackupData(backupData) {
                // Use the existing restore logic
                if (backupData.classes) {
                    localStorage.setItem('attendanceClasses_v2', JSON.stringify(backupData.classes));
                }
                if (backupData.attendanceLogs) {
                    localStorage.setItem('attendance_logs', JSON.stringify(backupData.attendanceLogs));
                }
                if (backupData.theme) {
                    localStorage.setItem('theme', backupData.theme);
                    if (backupData.theme === 'dark') {
                        document.body.classList.add('dark-mode');
                    } else {
                        document.body.classList.remove('dark-mode');
                    }
                }
                if (backupData.notificationSettings) {
                    for (const className in backupData.notificationSettings) {
                        localStorage.setItem(
                            `notificationSettings_${className}`,
                            JSON.stringify(backupData.notificationSettings[className])
                        );
                    }
                }
                if (backupData.timetableArrangements) {
                    for (const className in backupData.timetableArrangements) {
                        localStorage.setItem(
                            `timetable_arrangement_${className}`,
                            JSON.stringify(backupData.timetableArrangements[className])
                        );
                    }
                }
                if (backupData.periodTimes) {
                    for (const className in backupData.periodTimes) {
                        localStorage.setItem(
                            `periodTimes_${className}`,
                            JSON.stringify(backupData.periodTimes[className])
                        );
                    }
                }
                if (backupData.lastOpenedClass) {
                    localStorage.setItem('lastOpenedClass', backupData.lastOpenedClass);
                }
                if (backupData.defaultView) {
                    localStorage.setItem('defaultView', backupData.defaultView);
                }

                // Reload app state
                loadFromStorage();
                populateClassSelector();
                onClassChange();
            }

            // Initialize Google Auth when API loads
            window.addEventListener('load', () => {
                // Wait for both scripts to load
                const checkGoogleLoaded = setInterval(() => {
                    if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                        clearInterval(checkGoogleLoaded);
                        initGoogleAuth();
                    }
                }, 100);

                // Timeout after 10 seconds
                setTimeout(() => clearInterval(checkGoogleLoaded), 10000);
            });

            // --- DATE UTILITY (use local timezone, not UTC) ---
            function formatLocalDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Parse YYYY-MM-DD string to local midnight Date (avoids UTC timezone issues)
            function parseLocalDate(dateStr) {
                const [year, month, day] = dateStr.split('-').map(Number);
                return new Date(year, month - 1, day); // month is 0-indexed
            }

            // --- INITIALIZATION & DATA MANAGEMENT ---
            function loadFromStorage() {
                const storedClasses = localStorage.getItem('attendanceClasses_v2');
                classes = storedClasses ? JSON.parse(storedClasses) : JSON.parse(JSON.stringify(defaultExampleClass));
            }

            function saveToStorage() {
                localStorage.setItem('attendanceClasses_v2', JSON.stringify(classes));
                // Track last app interaction time for sync comparison
                localStorage.setItem('lastAppInteraction', new Date().toISOString());
            }

            document.addEventListener('DOMContentLoaded', function () {
                initializeApp();
                // Clear any recovery attempt flag after successful init
                localStorage.removeItem('initRecoveryAttempt');
            });
            // === SIMPLE FIX: Auto-reload when PWA resumes from frozen state ===
            let lastActiveTime = Date.now();

            // Track when app was last active
            setInterval(() => { lastActiveTime = Date.now(); }, 1000);

            // Check if app state is broken (PWA frozen state issue)
            // Only check things that are DEFINITELY broken, not normal states
            function isStateBroken() {
                // Don't check during initial load
                if (!document.body) return false;

                const selector = document.getElementById('classSelector');
                // Selector exists but has no options (not even default) = broken
                const selectorBroken = selector && selector.options.length === 0;

                // Theme saved as dark but body doesn't have class = broken
                const savedTheme = localStorage.getItem('theme');
                const themeBroken = savedTheme === 'dark' && !document.body.classList.contains('dark-mode');

                // Only reload if definitely broken
                return selectorBroken || themeBroken;
            }

            // On visibility change - if state is broken, just reload
            document.addEventListener('visibilitychange', function () {
                if (document.visibilityState === 'visible') {
                    // Small delay to let things settle
                    setTimeout(() => {
                        if (isStateBroken()) {
                            console.log('🔄 PWA state broken, reloading page...');
                            location.reload();
                        }
                    }, 100);
                }
            });

            // On pageshow (bfcache) - if state is broken, reload
            window.addEventListener('pageshow', function (event) {
                if (event.persisted || isStateBroken()) {
                    setTimeout(() => {
                        if (isStateBroken()) {
                            console.log('🔄 Page from bfcache with broken state, reloading...');
                            location.reload();
                        }
                    }, 100);
                }
            });

            // On focus - if state is broken, reload
            window.addEventListener('focus', function () {
                setTimeout(() => {
                    if (isStateBroken()) {
                        console.log('🔄 Focus with broken state, reloading...');
                        location.reload();
                    }
                }, 100);
            });

            // Restore app state without full reinitialization (faster)
            function restoreAppState() {
                try {
                    // 1. Restore classes from localStorage FIRST
                    const storedClasses = localStorage.getItem('attendanceClasses_v2');
                    console.log('📦 Stored classes found:', !!storedClasses);

                    if (storedClasses) {
                        const parsedClasses = JSON.parse(storedClasses);
                        const classCount = Object.keys(parsedClasses).length;
                        console.log('📦 Parsed classes count:', classCount);

                        if (classCount > 0) {
                            classes = parsedClasses;
                        }
                    }

                    // 2. ALWAYS repopulate class selector if classes exist
                    const selector = document.getElementById('classSelector');
                    if (selector && Object.keys(classes).length > 0) {
                        console.log('🔄 Repopulating class selector with', Object.keys(classes).length, 'classes');

                        // Force clear and repopulate
                        selector.innerHTML = '<option value="">-- Select a Class --</option>';
                        const datalist = document.getElementById('class-suggestions');
                        if (datalist) datalist.innerHTML = '';

                        Object.keys(classes).sort().forEach(className => {
                            selector.innerHTML += `<option value="${className}">${className}</option>`;
                            if (datalist) datalist.innerHTML += `<option value="${className}"></option>`;
                        });

                        console.log('✅ Class selector now has', selector.options.length, 'options');

                        // Restore last selected class
                        const lastClass = localStorage.getItem('lastOpenedClass');
                        if (lastClass && classes[lastClass]) {
                            selector.value = lastClass;
                            console.log('📌 Selected last class:', lastClass);
                            onClassChange();
                        } else {
                            // Select first class
                            const firstClass = Object.keys(classes)[0];
                            selector.value = firstClass;
                            console.log('📌 Selected first class:', firstClass);
                            onClassChange();
                        }
                    } else {
                        console.log('⚠️ No classes to restore or selector not found');
                    }

                    // 3. Restore theme
                    const themeToggle = document.getElementById('theme-checkbox');
                    const savedTheme = localStorage.getItem('theme');
                    if (savedTheme === 'dark') {
                        if (!document.body.classList.contains('dark-mode')) {
                            document.body.classList.add('dark-mode');
                            if (themeToggle) themeToggle.checked = true;
                            console.log('🌙 Dark mode restored');
                        }
                    } else {
                        document.body.classList.remove('dark-mode');
                        if (themeToggle) themeToggle.checked = false;
                    }

                    // 4. Restore user account UI
                    if (typeof updateAccountUI === 'function') {
                        updateAccountUI();
                    }
                    if (typeof updateSidebarAccountUI === 'function') {
                        updateSidebarAccountUI();
                    }

                    // 5. Re-check login status
                    if (typeof checkLoginStatus === 'function') {
                        const savedUser = localStorage.getItem('googleUser');
                        if (savedUser) {
                            googleUser = JSON.parse(savedUser);
                        }
                        checkLoginStatus();
                    }

                    // 6. Check if modals are initialized (PWA frozen state fix)
                    const addClassModal = document.getElementById('addClassModal');
                    if (addClassModal && addClassModal.innerHTML.trim() === '') {
                        console.log('⚠️ Modals not initialized, running full init...');
                        initializeApp();
                        return; // Exit after full init
                    }

                    console.log('✅ App state restored successfully');
                } catch (error) {
                    console.error('❌ State restoration failed:', error);
                    // If restoration fails, do full reinitialize
                    initializeApp();
                }
            }

            // Main initialization function
            function initializeApp() {
                try {
                    loadFromStorage();

                    // Verify classes loaded
                    if (Object.keys(classes).length === 0) {
                        console.log('⚠️ No classes found, loading defaults...');
                        classes = JSON.parse(JSON.stringify(defaultExampleClass));
                    }

                    document.getElementById('currentDate').value = formatLocalDate(new Date());
                    populateClassSelector();

                    // Auto-restore last opened class
                    const lastClass = localStorage.getItem('lastOpenedClass');
                    const selector = document.getElementById('classSelector');

                    if (lastClass && classes[lastClass]) {
                        selector.value = lastClass;
                        onClassChange();
                    } else if (Object.keys(classes).length > 0) {
                        // If no last class but classes exist, select the first one
                        const firstClass = Object.keys(classes)[0];
                        selector.value = firstClass;
                        onClassChange();
                    }

                    setupEventListeners();

                    const themeToggle = document.getElementById('theme-checkbox');
                    const savedTheme = localStorage.getItem('theme');
                    if (savedTheme) {
                        if (savedTheme === 'dark') {
                            document.body.classList.add('dark-mode');
                            themeToggle.checked = true;
                        }
                    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        document.body.classList.add('dark-mode');
                        themeToggle.checked = true;
                        localStorage.setItem('theme', 'dark');
                    }
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.get('openLog') === 'true') {
                        // Remove the parameter from URL
                        window.history.replaceState({}, document.title, window.location.pathname);

                        // Auto-select last class and scroll to dashboard
                        // Auto-select last class and open daily log
                        const lastClass = localStorage.getItem('lastOpenedClass');
                        if (lastClass && classes[lastClass]) {
                            setTimeout(() => {
                                document.getElementById('classSelector').value = lastClass;
                                onClassChange();
                                // Open the daily log modal directly
                                openDailyLog();
                            }, 500);
                        }
                    }

                    // Define switchModalTab function BEFORE modal HTML
                    window.switchModalTab = function (tab) {
                        console.log('🔘 Tab switch requested:', tab);

                        const tabs = {
                            aiContent: document.getElementById('aiImportTab')
                        };

                        // Remove active from all buttons
                        ['formTabBtn', 'jsonTabBtn', 'scanTabBtn', 'aiImportTabBtn', 'shareTabBtn'].forEach(id => {
                            const btn = document.getElementById(id);
                            if (btn) btn.classList.remove('active');
                        });

                        // Hide all content
                        ['formEntryTab', 'jsonEntryTab', 'scanEntryTab', 'aiImportTab', 'shareEntryTab'].forEach(id => {
                            const elem = document.getElementById(id);
                            if (elem) elem.style.display = 'none';
                        });

                        isJsonMode = false;

                        // Show selected tab
                        if (tab === 'form') {
                            const btn = document.getElementById('formTabBtn');
                            const content = document.getElementById('formEntryTab');
                            if (btn) btn.classList.add('active');
                            if (content) content.style.display = 'block';
                        } else if (tab === 'json') {
                            const btn = document.getElementById('jsonTabBtn');
                            const content = document.getElementById('jsonEntryTab');
                            if (btn) btn.classList.add('active');
                            if (content) content.style.display = 'block';
                            isJsonMode = true;
                        } else if (tab === 'scan') {
                            const btn = document.getElementById('scanTabBtn');
                            const content = document.getElementById('scanEntryTab');
                            if (btn) btn.classList.add('active');
                            if (content) content.style.display = 'block';
                            if (typeof startQRScannerInTab === 'function') startQRScannerInTab();
                        } else if (tab === 'ai-import') {
                            const btn = document.getElementById('aiImportTabBtn');
                            const content = document.getElementById('aiImportTab');
                            if (btn) btn.classList.add('active');
                            if (content) {
                                content.style.display = 'block';
                                console.log('✅ AI Import tab activated successfully!');
                            } else {
                                console.error('❌ aiImportTab element not found!');
                            }
                        } else if (tab === 'share') {
                            const btn = document.getElementById('shareTabBtn');
                            const content = document.getElementById('shareEntryTab');
                            if (btn) btn.classList.add('active');
                            if (content) content.style.display = 'block';
                            if (typeof generateShareQRInTab === 'function') generateShareQRInTab();
                        }
                    };

                    // --- MODAL HTML DEFINITIONS ---
                    const addClassModalHTML = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('addClassModal')">&times;</button>
                    <div class="modal-header"><h2 id="addClassModalTitle"></h2></div>
                    <div class="modal-tabs">
                        <button id="formTabBtn" class="active" onclick="switchModalTab('form')">Form Entry</button>
                        <button id="aiImportTabBtn" onclick="switchModalTab('ai-import')">✨ Inbuilt AI Import</button>
                        <button id="jsonTabBtn" onclick="switchModalTab('json')">Import from JSON</button>
                        <button id="scanTabBtn" onclick="switchModalTab('scan')">Scan QR</button>
                        <button id="shareTabBtn" onclick="switchModalTab('share')" style="display: none;">Share Class</button>
                    </div>
                    
                    <div id="formEntryTab">
                        <div class="form-group"><label for="newClassName">Class Name *</label><input type="text" id="newClassName" placeholder="e.g., CSE Core - H"></div>
                        <div class="form-group"><label for="newClassLastDate">Last Working Date *</label><input type="date" id="newClassLastDate"></div>
                        <div class="form-group"><label>Subjects *</label><div id="subjectsContainer"></div><button class="add-subject-btn" onclick="addSubjectEntry()">+ Add Subject</button></div>
                        <div class="holiday-section"><label>Holidays</label><ul id="holidayList"></ul><div class="add-holiday-form"><input type="date" id="newHolidayDate"><button type="button" class="add-holiday-btn" onclick="addHolidayToModal()">Add Holiday</button></div></div>
                    </div>

                    <div id="aiImportTab" style="display: none;">
                        <div class="json-instructions">
                            <strong>🤖 Inbuilt AI Import:</strong>
                            <p>Upload your <strong>Timetable</strong>, <strong>Attendance Screenshot</strong>, or any other class details. The AI will read them and fill out the form for you!</p>
                        </div>
                        
                        <div class="form-group">
                            <label>1. Upload Files (Images/Screenshots):</label>
                            <div style="border: 2px dashed #ccc; border-color: var(--border-color, #ccc); padding: 20px; text-align: center; border-radius: 8px; cursor: pointer; background: rgba(0,0,0,0.02);" onclick="document.getElementById('aiImportFiles').click()">
                                <span style="font-size: 2rem;">📂</span><br>
                                <span style="color: #666; color: var(--medium-text, #666);">Click to upload Timetable, Attendance, etc.</span>
                            </div>
                            <input type="file" id="aiImportFiles" multiple accept="image/*" style="display: none;" onchange="updateAIFileCount(this)">
                            <div id="aiFileCount" style="margin-top: 5px; font-size: 0.9rem; color: var(--success-grad-start);"></div>
                        </div>

                        <div class="form-group">
                            <label>2. Additional Details (Optional):</label>
                            <textarea id="aiImportText" placeholder="e.g., Last working day is Dec 20, 2025. Holidays are Aug 15, Oct 2." style="min-height: 80px;"></textarea>
                        </div>

                        <div id="aiImportLoading" style="display: none; text-align: center; margin: 20px 0;">
                            <div class="spinner"></div>
                            <p>🤖 AI is analyzing your files...<br>This may take a few seconds.</p>
                        </div>

                        <button class="btn primary-btn" onclick="handleAIClassImport()" style="width: 100%;">✨ Run Inbuilt AI Import</button>
                    </div>

                    <div id="jsonEntryTab" style="display: none;">
                        <div class="json-instructions">
                            <strong>How to use:</strong>
                            <ol>
                                <li>Click the button below to copy the AI prompt.</li>
                                <li>Paste it into an AI Chat (like Gemini, ChatGPT).</li>
                                <li>Attach your <strong>timetable screenshot</strong> AND your <strong>attendance details screenshot</strong>. Provide <strong>your holiday list</strong> and <strong>last working date</strong>.</li>
                                <li>The AI will generate a JSON code block. Copy it.</li>
                                <li>Paste the entire JSON code into the text box below and click Save.</li>
                            </ol>
                        </div>
                        <button class="btn secondary-btn" onclick="copyAIPrompt()" style="width: 100%; margin-bottom: 15px;">📋 Copy Prompt for AI</button>
                        <div class="form-group">
                            <label for="jsonPasteArea">Paste JSON here:</label>
                            <textarea id="jsonPasteArea" placeholder='{ "Your Class Name": { "lastDate": "...", "holidays": [...], "subjects": [...] } }'></textarea>
                        </div>
                    </div>

                    <div id="scanEntryTab" style="display: none;">
                        <div class="json-instructions">
                            <strong>Scan Class QR Code:</strong>
                            <p>Point your camera at a shared class QR code to import it instantly.</p>
                        </div>
                         <!-- File Upload Option -->
                        <div style="margin-bottom: 20px; text-align: center;">
                            <input type="file" id="qrInputFileTab" accept="image/*" style="display: none;" onchange="handleQRFileUploadInTab(this)">
                            <button class="btn secondary-btn" onclick="document.getElementById('qrInputFileTab').click()">📂 Upload QR Image</button>
                        </div>
                        <div id="readerTab" style="width: 100%; min-height: 300px;"></div>
                    </div>

                    <div id="shareEntryTab" style="display: none;">
                        <div class="modal-header" style="text-align: center; margin-bottom: 20px;">
                            <h2>📤 Share Class</h2>
                            <p>Scan this QR code to import this class setup on another device.</p>
                        </div>
                        <div id="qrcodeTab" style="display: inline-block; padding: 20px; background: white; margin: 20px auto; display: flex; justify-content: center;"></div>
                        <p style="font-size: 0.9rem; color: var(--medium-text); margin-bottom: 20px; text-align: center;">Includes subjects and holidays. Does not include your personal attendance logs.</p>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button class="btn success-btn" onclick="shareQRImageTab()">📱 Share via App</button>
                            <button class="btn secondary-btn" onclick="downloadQRImageTab()">⬇️ Download QR</button>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button class="btn primary-btn" onclick="submitClassForm()">Save Class</button>
                        <button class="btn secondary-btn" onclick="closeModal('addClassModal')">Cancel</button>
                    </div>
                </div>`;

                    const helpModalHTML = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('helpModal')">&times;</button>
                    <div class="modal-header"><h2>💡 How to Use This Tool</h2></div>
                    
                    <div class="alert-message warning" style="border-left-color: var(--warning-color);">
                        <strong>Important:</strong> OCR (image reading) is accurate only about 95% of the time. <strong>Always compare the extracted numbers</strong> with your screenshot to ensure they are correct. You can edit them directly in the results cards.
                    </div>

                    <h4 class="help-main-heading">1. Initial Setup (First Time)</h4>
                    <p>Before you can calculate, you need to add your class details.</p>
                    <ol>
                        <li>Click <strong>"+ Add"</strong>.</li>
                        <li><strong>Manual Entry:</strong> Fill in your class name, semester end date, and add each subject with its name, code, and weekly schedule (number of classes from Monday to Sunday).</li>
                        <li><strong>Fast Entry (Recommended):</strong> Switch to the <strong>"Import from JSON"</strong> tab. Use the "Copy Prompt for AI" button and paste it into an AI chatbot (like Gemini) along with your timetable and attendance screenshots. The AI will generate a JSON code. Paste this code back into the app to set up everything automatically.</li>
                    </ol>

                    <h4 class="help-main-heading">2. Calculating Your Attendance</h4>
                    <ul>
                        <li><strong>Screenshot Upload:</strong> Once your class is set up and selected, click "Choose Image" and upload a screenshot of your college's attendance portal. The app will automatically read the data.</li>
                        <li><strong>Manual/JSON Entry:</strong> If you prefer, click "Manual Entry" to type in your attended/held classes, or "Paste JSON" to paste data extracted by an AI.</li>
                    </ul>

                    <h4 class="help-main-heading">3. Student Portal (New Feature)</h4>
                    <ul>
                        <li><strong>Create Portal:</strong> Switch to "Student Portal" mode to track your daily attendance. Set a "Baseline Date" and your current attendance stats.</li>
                        <li><strong>Daily Logging:</strong> Mark your attendance daily (Attended, Skipped, Cancelled, Duty Leave, Medical Leave). The app will automatically update your stats.</li>
                        <li><strong>Notifications:</strong> Get daily reminders to mark your attendance. You can customize the time in settings.</li>
                        <li><strong>History Editor:</strong> View and edit past logs. Use the calendar to jump to specific dates.</li>
                        <li><strong>Smart Baseline:</strong> If you add logs for dates <em>before</em> your baseline, they will only count if they exceed your initial baseline data, ensuring accuracy.</li>
                    </ul>

                    <h4 class="help-main-heading">4. Understanding the Features</h4>
                    <ul>
                        <li><strong>Calculation Settings:</strong> Set your college's minimum attendance percentage. Use the toggle to switch between viewing your status for each subject individually or for your overall average.</li>
                        <li><strong>Can I Skip Today?:</strong> A quick check to see how skipping all of today's classes would affect your final attendance percentage for each subject.</li>
                        <li><strong>Daily Dashboard:</strong> Shows which classes you have on the selected "Current Date" and a color-coded status (🔴Critical, 🟡Low, 🟢Safe) based on your latest calculation.</li>
                        <li><strong>Daily Log:</strong> Keep track of days you attended, skipped, or had classes cancelled. This makes future calculations more accurate as it accounts for cancelled classes.</li>
                        <li><strong>Leave Planner & Compulsory Events:</strong> Enter planned leaves and must-attend events to see their impact on your ability to take leave. Use the "Recalculate Max Safe Leave" to get updated recommendations.</li>
                        <li><strong>Max Safe Leave:</strong> Calculates the exact dates you could skip entirely without falling below the minimum attendance requirement, considering your planned leaves and compulsory events.</li>
                        <li><strong>Long Weekend Finder:</strong> An intelligent tool that finds the best days to take leave to get the longest continuous break possible by combining your leave days with weekends and holidays.</li>
                    </ul>
                    
                    <h4 class="help-main-heading">4. Data Management (in Hamburger Menu)</h4>
                    <ul>
                        <li><strong>Export/Import:</strong> Share your class setup with friends.</li>
                        <li><strong>Backup/Restore:</strong> Save all your classes to a file on your device and restore from it later. This is great for switching devices.</li>
                        <li><strong>History:</strong> The app automatically saves your last 10 calculations. You can view or restore any of them from the history dropdown.</li>
                    </ul>
                </div>`;


                    document.getElementById('addClassModal').innerHTML = addClassModalHTML;
                    document.getElementById('helpModal').innerHTML = helpModalHTML;
                    document.getElementById('partialEntryModal').innerHTML = `<div class="modal-content"><button class="modal-close" onclick="closeModal('partialEntryModal')">&times;</button><div class="modal-header"><h2>Missed Subjects Entry</h2><p>OCR missed some subjects. Please enter their attendance manually.</p></div><div id="partialSubjectsGrid"></div><div class="form-actions"><button class="btn primary-btn" onclick="submitPartialEntry()">Submit & Recalculate</button></div></div>`;
                    document.getElementById('exportModal').innerHTML = `<div class="modal-content"><button class="modal-close" onclick="closeModal('exportModal')">&times;</button><div class="modal-header"><h2>Export/Share Class</h2><p>Copy this JSON and share it. Your friend can import it using the 'Import from JSON' tab.</p></div><div class="form-group"><textarea id="exportJsonTextarea" readonly></textarea></div><div class="form-actions"><button class="btn primary-btn" onclick="copyExportJson()">Copy to Clipboard</button></div></div>`;
                    document.getElementById('skipTodayModal').innerHTML = `<div class="modal-content"><button class="modal-close" onclick="closeModal('skipTodayModal')">&times;</button><div class="modal-header"><h2>Can You Skip Today?</h2></div><div id="skipTodayResults"></div></div>`;
                    document.getElementById('dailyLogModal').innerHTML = `<div class="modal-content"><button class="modal-close" onclick="closeModal('dailyLogModal')">&times;</button><div class="modal-header"><h2>Daily Attendance Log</h2></div><div class="form-group"><label for="logDate">Current Date:</label><input type="date" id="logDate" onchange="populateDailyLog()"></div><div id="dailyLogSubjects"></div><div class="form-actions"><button class="btn primary-btn" onclick="saveDailyLog()">Save Log</button></div><p style="font-size: 0.8rem; text-align: center; margin-top: 15px;"><strong>Note:</strong> For past dates, 'Duty Leave (OD)' must be manually reflected by adding 1 to both 'Attended' and 'Held' values in the results.</p></div>`;
                    document.getElementById('backupOptionsModal').innerHTML = `<div class="modal-content"><button class="modal-close" onclick="closeModal('backupOptionsModal')">&times;</button><div class="modal-header"><h2>💾 Backup Data</h2><p>Choose how you want to save your backup.</p></div><div class="form-actions" style="flex-direction: column; gap: 15px;"><button class="btn primary-btn" onclick="performBackupDownload()" style="width: 100%;">⬇️ Download JSON File</button><button class="btn success-btn" onclick="performBackupShare()" style="width: 100%;">📤 Share JSON File</button><button class="btn info-btn" onclick="performBackupCopy()" style="width: 100%;">📋 Copy JSON to Clipboard</button></div></div>`;

                    // OCR Settings Modal
                    document.getElementById('ocrSettingsModal').innerHTML = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('ocrSettingsModal')">&times;</button>
                    <div class="modal-header">
                        <h2>🔑 API Settings</h2>
                        <p>Configure AI-powered attendance extraction</p>
                    </div>
                    
                    <div style="background: var(--card-bg); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid var(--border-color);">
                        <h3 style="margin-bottom: 15px; font-size: 1.1rem;">📍 Your Personal API Key</h3>
                        <p style="margin-bottom: 15px; color: var(--medium-text); font-size: 0.9rem;">
                            Get your own <strong>free 10,000/day quota</strong> by adding your personal Gemini API key.
                        </p>
                        
                        <div class="form-group">
                            <label for="personalGeminiKey">Your Gemini API Key:</label>
                            <input type="password" id="personalGeminiKey" placeholder="AIzaSy..." style="font-family: monospace;">
                            <small style="color: var(--medium-text); margin-top: 5px; display: block;">
                                Your key is stored locally and never shared
                            </small>
                        </div>
                        
                        <div id="personalQuotaStatus" style="margin: 15px 0; padding: 10px; background: var(--light-bg); border-radius: 8px; display: none;">
                            <strong>Your Quota Today:</strong> <span id="personalQuotaCount">0/1500</span>
                        </div>
                    </div>
                    
                    <div style="background: var(--light-bg); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; font-size: 1rem;">🔑 How to Get Free API Key:</h4>
                        <ol style="margin: 0; padding-left: 20px; color: var(--dark-text);">
                            <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" style="color: var(--primary-grad-start);">Google AI Studio</a></li>
                            <li>Click <strong>"Get API Key"</strong> or <strong>"Create API Key"</strong></li>
                            <li>Copy the key (starts with <code>AIzaSy...</code>)</li>
                            <li>Paste it above and click <strong>Save</strong></li>
                        </ol>
                    </div>
                    
                    <div class="form-actions">
                        <button class="btn primary-btn" onclick="saveAPISettings()">💾 Save Settings</button>
                        <button class="btn secondary-btn" onclick="testPersonalKey()">🧪 Test My Key</button>
                    </div>
                </div>`;

                    document.getElementById('restoreOptionsModal').innerHTML = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('restoreOptionsModal')">&times;</button>
                    <div class="modal-header"><h2>♻️ Restore Data</h2><p>Choose how you want to restore your data.</p></div>
                    
                    <div class="modal-tabs">
                        <button id="restoreFileTabBtn" class="active" onclick="switchRestoreTab('file')">Upload File</button>
                        <button id="restorePasteTabBtn" onclick="switchRestoreTab('paste')">Paste JSON</button>
                    </div>

                    <div id="restoreFileTab">
                        <div style="text-align: center; padding: 20px;">
                            <p style="margin-bottom: 20px;">Upload a previously backed up .json file.</p>
                            <button class="btn primary-btn" onclick="document.getElementById('restoreInput').click()">📂 Select Backup File</button>
                        </div>
                    </div>

                    <div id="restorePasteTab" style="display: none;">
                        <div class="form-group">
                            <label for="restoreJsonPaste">Paste Backup JSON:</label>
                            <textarea id="restoreJsonPaste" placeholder='Paste your backup JSON here...' style="min-height: 200px; font-family: monospace;"></textarea>
                        </div>
                        <div class="form-actions">
                            <button class="btn primary-btn" onclick="performRestorePaste()">Restore from Text</button>
                        </div>
                    </div>
                </div>`;
                } catch (error) {
                    console.error('❌ App initialization failed:', error);
                    // Try to recover by reloading
                    if (!localStorage.getItem('initRecoveryAttempt')) {
                        localStorage.setItem('initRecoveryAttempt', Date.now().toString());
                        location.reload();
                    } else {
                        localStorage.removeItem('initRecoveryAttempt');
                        alert('App initialization failed. Please try refreshing the page or use ?forceclear in the URL to reset.');
                    }
                }
            }

            function setupEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const imageInput = document.getElementById('imageInput');
                ['dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadSection.addEventListener(eventName, e => {
                        e.preventDefault();
                        if (eventName === 'dragover') uploadSection.classList.add('dragover');
                        else uploadSection.classList.remove('dragover');
                        if (eventName === 'drop' && e.dataTransfer.files.length) {
                            showInputMode('upload');
                            handleImageUpload(e.dataTransfer.files);
                        }
                    });
                });
                imageInput.addEventListener('change', e => {
                    if (e.target.files.length) {
                        showInputMode('upload');
                        handleImageUpload(e.target.files);
                    }
                });
            }

            // --- HAMBURGER SIDENAV FUNCTIONS ---
            function openNav() {
                document.getElementById("mySidenav").classList.add("active");
                document.getElementById("menuOverlay").classList.add("active");
                document.body.classList.add('backdrop-active'); // Block body scroll
            }

            function closeNav() {
                document.getElementById("mySidenav").classList.remove("active");
                document.getElementById("menuOverlay").classList.remove("active");
                document.body.classList.remove('backdrop-active'); // Restore body scroll
            }

            function toggleDropdown(element) {
                const content = element.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                    element.querySelector('span').innerHTML = '▾';
                } else {
                    content.style.display = "block";
                    element.querySelector('span').innerHTML = '▴';
                }
            }

            // --- DARK MODE TOGGLE ---
            // Initialize dark mode toggle after DOM loads
            window.addEventListener('load', function () {
                const themeCheckbox = document.getElementById('theme-checkbox');

                if (themeCheckbox) {
                    // Add event listener for toggle
                    themeCheckbox.addEventListener('change', function (e) {
                        console.log('Theme toggle clicked:', e.target.checked);
                        if (e.target.checked) {
                            document.body.classList.add('dark-mode');
                            localStorage.setItem('theme', 'dark');
                            console.log('Dark mode enabled');
                        } else {
                            document.body.classList.remove('dark-mode');
                            localStorage.setItem('theme', 'light');
                            console.log('Dark mode disabled');
                        }
                    });

                    // Load saved theme on page load
                    const savedTheme = localStorage.getItem('theme');
                    console.log('Saved theme:', savedTheme);
                    if (savedTheme === 'dark') {
                        document.body.classList.add('dark-mode');
                        themeCheckbox.checked = true;
                        console.log('Applied saved dark mode');
                    }
                } else {
                    console.error('Theme checkbox element not found!');
                }
            });

            // --- CORE HELPER FUNCTIONS ---
            function getSubjectAcronym(name) {
                if (!name) return "";
                const ignoreWords = ['and', 'of', 'the', 'in', 'for', 'to'];
                return name.split(/\s+/)
                    .filter(word => !ignoreWords.includes(word.toLowerCase()))
                    .map(word => word[0].toUpperCase())
                    .join('');
            }

            function getMinAttendanceCriteria() {
                const value = parseFloat(document.getElementById('minAttendanceInput').value);
                return isNaN(value) || value <= 0 ? 0.75 : value / 100;
            }

            function isOverallMode() {
                return document.getElementById('overallCriteriaCheckbox').checked;
            }

            function triggerRecalculation() {
                if (currentAnalysisData.length > 0) {
                    calculateAttendance(currentAnalysisData);
                }
            }

            function populateClassSelector() {
                const selector = document.getElementById('classSelector');
                const datalist = document.getElementById('class-suggestions');
                selector.innerHTML = '<option value="">-- Select a Class --</option>';
                datalist.innerHTML = '';
                Object.keys(classes).sort().forEach(className => {
                    selector.innerHTML += `<option value="${className}">${className}</option>`;
                    datalist.innerHTML += `<option value="${className}"></option>`;
                });
            }

            function handleSearchInput() {
                const searchInput = document.getElementById('classSearch');
                const selector = document.getElementById('classSelector');
                if (classes[searchInput.value]) {
                    if (selector.value !== searchInput.value) {
                        selector.value = searchInput.value;
                        onClassChange();
                    }
                }
            }

            function handleDropdownChange() {
                document.getElementById('classSearch').value = document.getElementById('classSelector').value;
                onClassChange();
            }

            function onClassChange() {
                const className = document.getElementById('classSelector').value;
                const content = document.getElementById('classSelectedContent');
                const timetable = document.getElementById('timetableSection');

                showInputMode('upload');
                document.getElementById('resultsSection').innerHTML = '';
                const leavePlannerSection = document.getElementById('leavePlannerSection');
                if (leavePlannerSection) leavePlannerSection.style.display = 'none';

                document.getElementById('pdfDownloadContainer').innerHTML = '';

                const maxLeaveRec = document.getElementById('maxLeaveRecommendation');
                if (maxLeaveRec) maxLeaveRec.style.display = 'none';

                const leaveRecContainer = document.getElementById('leaveRecommendationContainer');
                if (leaveRecContainer) leaveRecContainer.style.display = 'none';

                const previewSection = document.getElementById('previewSection');
                if (previewSection) previewSection.style.display = 'none';
                currentAnalysisData = [];

                if (className && classes[className]) {
                    selectedClass = { ...classes[className] };
                    document.getElementById('lastDate').value = selectedClass.lastDate;
                    content.style.display = 'block';
                    timetable.style.display = 'block';
                    generateManualInputs();
                    generateTimetable();

                    // Save last opened class
                    localStorage.setItem('lastOpenedClass', className);

                    // Initialize Portal if available
                    if (typeof initPortal === 'function') {
                        initPortal();
                    }

                    // Update period-wise view menu visibility
                    if (typeof updatePeriodViewMenuVisibility === 'function') {
                        updatePeriodViewMenuVisibility();
                    }
                } else {
                    selectedClass = null;
                    content.style.display = 'none';
                    timetable.style.display = 'none';

                    // Hide period-wise view menu when no class selected
                    if (typeof updatePeriodViewMenuVisibility === 'function') {
                        updatePeriodViewMenuVisibility();
                    }
                }
            }

            // --- OCR & CORE CALCULATIONS ---
            async function handleImageUpload(files) {
                if (!selectedClass) { alert("Please select a class first!"); return; }

                // Convert FileList to Array
                const filesArray = Array.from(files);

                const previewSection = document.getElementById('previewSection');
                const previewGrid = document.getElementById('previewImagesGrid');
                const loadingSection = document.getElementById('loadingSection');
                document.getElementById('resultsSection').innerHTML = '';

                // Clear and populate preview grid with all images
                previewGrid.innerHTML = '';
                previewSection.style.display = 'block';

                filesArray.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const container = document.createElement('div');
                        container.className = 'preview-image-container';

                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.alt = `Preview ${index + 1}`;

                        const label = document.createElement('div');
                        label.className = 'preview-image-label';
                        label.textContent = `Image ${index + 1}`;

                        container.appendChild(label);
                        container.appendChild(img);
                        previewGrid.appendChild(container);
                    };
                    reader.readAsDataURL(file);
                });

                loadingSection.style.display = 'block';

                try {
                    let mergedData = {};

                    // Process each image
                    for (let i = 0; i < filesArray.length; i++) {
                        const file = filesArray[i];
                        console.log(`📸 Processing image ${i + 1} of ${filesArray.length}...`);

                        const result = await processAttendanceImage(file, true);

                        if (result.success && result.data) {
                            console.log(`✅ OCR Success for image ${i + 1} via ${result.method}`);
                            // Merge data from this image
                            mergedData = { ...mergedData, ...result.data };
                        } else {
                            console.warn(`⚠️ Failed to process image ${i + 1}: ${result.error}`);
                        }
                    }

                    // Process merged data if we got anything
                    if (Object.keys(mergedData).length > 0) {
                        console.log(`✅ Successfully processed ${filesArray.length} image(s), merged data:`, mergedData);
                        processJsonAndCalculate(mergedData);
                    } else {
                        throw new Error('Could not extract data from any of the images');
                    }
                } catch (err) {
                    console.error('❌ Processing Error:', err);
                    alert(`Failed to process images: ${err.message}`);
                } finally {
                    loadingSection.style.display = 'none';
                }
            }

            // === OCR API - Uses Backend Proxy ===
            // OCR now uses the same backend proxy as chatbot for API key security
            // Personal key takes priority, otherwise backend handles key rotation

            function hasPersonalGeminiKey() {
                return !!localStorage.getItem('personalGeminiKey');
            }

            // For backward compatibility - returns empty if no personal key
            function getNextAvailableOCRKey() {
                const personalKey = localStorage.getItem('personalGeminiKey');
                if (personalKey) {
                    return { key: personalKey, index: -1 };
                }
                // For shared keys, we use backend proxy instead
                return { key: null, index: -1, useProxy: true };
            }

            // Stub functions for backward compatibility
            function markOCRKeyExhausted(keyIndex) {
                console.log('OCR keys handled by backend proxy');
            }

            // Legacy variable for backward compatibility
            const SHARED_GEMINI_KEY = '';


            // === HYBRID OCR SYSTEM (Personal Gemini → Shared Gemini → Tesseract) ===
            async function processAttendanceImage(file, showFallbackPrompt = false) {
                try {
                    // Try personal Gemini API key first
                    const personalKey = localStorage.getItem('personalGeminiKey');
                    if (personalKey) {
                        console.log('Attempting OCR with personal Gemini API...');
                        const result = await processImageWithGemini(file, personalKey);
                        if (result.success) {
                            return { success: true, data: result.data, method: 'Personal Gemini API' };
                        }
                    }

                    // Fall back to shared Gemini API keys with rotation
                    console.log('Attempting OCR with shared Gemini API keys...');
                    let keyData = getNextAvailableOCRKey();
                    while (keyData) {
                        console.log(`🔑 Trying OCR Key #${keyData.index + 1}...`);
                        const sharedResult = await processImageWithGemini(file, keyData.key);
                        if (sharedResult.success) {
                            return { success: true, data: sharedResult.data, method: `Shared Gemini API (Key #${keyData.index + 1})` };
                        }
                        // Check if quota exhausted (429 error)
                        if (sharedResult.quotaExhausted) {
                            markOCRKeyExhausted(keyData.index);
                            keyData = getNextAvailableOCRKey();
                        } else {
                            break; // Other error, don't try more keys
                        }
                    }

                    // Fall back to Tesseract
                    console.log('Falling back to Tesseract.js...');
                    const tesseractResult = await processImageWithTesseract(file);
                    if (tesseractResult.success) {
                        return { success: true, data: tesseractResult.data, method: 'Tesseract.js' };
                    }

                    throw new Error('All OCR methods failed');

                } catch (error) {
                    console.error('OCR Processing Error:', error);
                    return { success: false, error: error.message };
                }
            }

            async function processImageWithGemini(file, apiKey) {
                try {
                    // Convert file to base64
                    const base64Image = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });

                    // Extract subject codes and names for the prompt
                    const subjectsList = selectedClass.subjects.map(s =>
                        `${s.code}: ${s.name}`
                    ).join(', ');

                    const prompt = `Extract attendance data from this university attendance screenshot. The class has these subjects: ${subjectsList}.

Generate a JSON object mapping subject codes to attendance numbers. Use this EXACT format:
{
  "SUBJECT-CODE-1": { "total": TOTAL_CLASSES, "present": ATTENDED_CLASSES },
  "SUBJECT-CODE-2": { "total": TOTAL_CLASSES, "present": ATTENDED_CLASSES }
}

CRITICAL RULES:
1. Use EXACT subject codes from the list above
2. Extract "total" (classes held) and "present" (classes attended) as integers
3. Return ONLY JSON, no explanations`;

                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [
                                        { text: prompt },
                                        {
                                            inlineData: {
                                                data: base64Image.split(',')[1],
                                                mimeType: file.type
                                            }
                                        }
                                    ]
                                }]
                            })
                        }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Gemini API Error (${response.status}): ${errorData.error?.message || 'Unknown'}`);
                    }

                    const result = await response.json();
                    const generatedText = result.candidates[0]?.content?.parts[0]?.text;

                    if (!generatedText) {
                        throw new Error('No response from Gemini API');
                    }

                    // Extract JSON from response (handle code blocks)
                    let jsonString = generatedText.trim();
                    if (jsonString.includes('```json')) {
                        jsonString = jsonString.split('```json')[1].split('```')[0].trim();
                    } else if (jsonString.includes('```')) {
                        jsonString = jsonString.split('```')[1].split('```')[0].trim();
                    }

                    const data = JSON.parse(jsonString);
                    return { success: true, data };

                } catch (error) {
                    console.error('Gemini OCR Error:', error);
                    return { success: false, error: error.message };
                }
            }

            async function processImageWithTesseract(file) {
                try {
                    const reader = new FileReader();
                    const imageDataUrl = await new Promise((resolve) => {
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });

                    const result = await Tesseract.recognize(imageDataUrl, 'eng', {
                        logger: (m) => {
                            if (m.status === 'recognizing text') {
                                console.log(`Tesseract Progress: ${Math.round(m.progress * 100)}%`);
                            }
                        }
                    });

                    const text = result.data.text;
                    console.log('Tesseract OCR Text:', text);

                    const extractedJson = extractDataToJson(text, selectedClass.subjects);
                    return { success: true, data: extractedJson };

                } catch (error) {
                    console.error('Tesseract Error:', error);
                    return { success: false, error: error.message };
                }
            }

            const levenshtein = (s1, s2) => { if (!s1) return s2 ? s2.length : 0; if (!s2) return s1.length; const s1_len = s1.length, s2_len = s2.length; if (s1_len === 0) return s2_len; if (s2_len === 0) return s1_len; let v0 = new Array(s2_len + 1), v1 = new Array(s2_len + 1); for (let i = 0; i <= s2_len; i++) v0[i] = i; for (let i = 0; i < s1_len; i++) { v1[0] = i + 1; for (let j = 0; j < s2_len; j++) { v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + (s1[i] === s2[j] ? 0 : 1)); } v0 = v1.slice(); } return v1[s2_len]; };
            function fuzzyMatch(ocrText, targetCode) { const ocrUpper = ocrText.toUpperCase().replace(/\s/g, ''), targetUpper = targetCode.toUpperCase(); if (targetUpper === 'CL' && ocrUpper === 'CL') return { match: true, confidence: 100, method: 'exact' }; const targetSuffix = targetUpper.substring(2); if (targetSuffix && ocrUpper.includes(targetSuffix)) return { match: true, confidence: 95, method: 'suffix' }; const corePattern = targetUpper.substring(4); if (corePattern && ocrUpper.includes(corePattern) && ocrUpper.length >= targetUpper.length - 2) return { match: true, confidence: 85, method: 'core' }; let matchCount = 0, positions = []; for (let i = 0; i < targetUpper.length; i++) { const idx = ocrUpper.indexOf(targetUpper[i], positions.length > 0 ? positions[positions.length - 1] + 1 : 0); if (idx !== -1) { matchCount++; positions.push(idx); } } const matchPercentage = (matchCount / targetUpper.length) * 100; if (matchPercentage >= 70) return { match: true, confidence: matchPercentage, method: 'char-match' }; const distance = levenshtein(ocrUpper, targetUpper); const similarity = (1 - distance / Math.max(ocrUpper.length, targetUpper.length)) * 100; if (similarity >= 65) return { match: true, confidence: similarity, method: 'levenshtein' }; return { match: false, confidence: 0, method: 'none' }; }
            function processLine(matchedLine, subject, jsonData, matchedWord = null, context) { let startIndex = 0; if (matchedWord) { startIndex = matchedLine.indexOf(matchedWord) + matchedWord.length; } else { const words = matchedLine.split(/\s+/); for (const word of words) { if (fuzzyMatch(word, subject.code).match) { startIndex = matchedLine.indexOf(word) + word.length; break; } } } const numbersString = matchedLine.substring(startIndex); const numberRegex = /(\d+(?:\.\d+)?)\s*(%)?/g; let match; const allFoundNumbers = []; while ((match = numberRegex.exec(numbersString)) !== null) { const value = parseFloat(match[1]); const isPercent = !!match[2]; const isInteger = value === Math.floor(value); if (isInteger || isPercent) allFoundNumbers.push({ value, isPercent }); } if (allFoundNumbers.length < 2) return; const ocrPercent = allFoundNumbers.find(n => n.isPercent); const rawOcrIntegers = allFoundNumbers.filter(n => !n.isPercent).map(n => n.value); const ocrIntegers = rawOcrIntegers.filter(n => n < 200).sort((a, b) => b - a); if (ocrIntegers.length < 2) return; const candidates = []; if (ocrIntegers.length >= 2) { const [c1_total, c1_p] = ocrIntegers; candidates.push({ total: c1_total, present: c1_p, absent: c1_total - c1_p }); } if (ocrPercent) { const c2_total = ocrIntegers[0]; const c2_present = Math.round((ocrPercent.value / 100) * c2_total); candidates.push({ total: c2_total, present: c2_present, absent: c2_total - c2_present }); } if (context.avgTotal && ocrIntegers[0].toString().length !== context.avgTotal.toString().length) { const c3_total = ocrIntegers[0] * 10; if (c3_total < 200) { const c3_present = ocrIntegers.length > 1 ? ocrIntegers[1] : (ocrPercent ? Math.round((ocrPercent.value / 100) * c3_total) : c3_total - 5); candidates.push({ total: c3_total, present: c3_present, absent: c3_total - c3_present }); } } let bestCandidate = null; let maxScore = -1; candidates.forEach(cand => { if (cand.present < 0 || cand.absent < 0 || cand.total <= 0) return; let score = 100; score -= Math.abs(cand.total - ocrIntegers[0]) * 0.5; if (ocrPercent) { const derivedPercent = (cand.present / cand.total) * 100; score -= Math.abs(derivedPercent - ocrPercent.value); } if (context.avgTotal && context.avgWeeklyClasses > 0) { const currentWeekly = subject.schedule.reduce((a, b) => a + b, 0); const expectedTotalRatio = currentWeekly / context.avgWeeklyClasses; const expectedTotal = context.avgTotal * expectedTotalRatio; const deviation = Math.abs(cand.total - expectedTotal); const tolerance = context.avgTotal * 0.25; if (deviation > tolerance) { score -= (deviation - tolerance) * 2; } } if (score > maxScore) { maxScore = score; bestCandidate = cand; } }); if (bestCandidate) { jsonData[subject.code] = { total: bestCandidate.total, present: bestCandidate.present }; } }
            function extractDataToJson(text, subjects) { const jsonData = {}; const lines = text.split('\n'); const usedLines = new Set(); const history = { totals: [], weeklyClasses: [] }; const processAllSubjects = () => { subjects.forEach(subject => { if (jsonData[subject.code]) return; let bestMatch = { line: null, confidence: 0, index: -1, word: null }; lines.forEach((line, index) => { if (usedLines.has(index)) return; for (const word of line.split(/\s+/)) { const result = fuzzyMatch(word, subject.code); if (result.match && result.confidence > bestMatch.confidence) { bestMatch = { line, confidence: result.confidence, index, word }; } } }); if (bestMatch.line && bestMatch.confidence >= 65) { usedLines.add(bestMatch.index); const context = {}; if (history.totals.length > 0) { context.avgTotal = history.totals.reduce((a, b) => a + b, 0) / history.totals.length; const avgWeekly = history.weeklyClasses.reduce((a, b) => a + b, 0) / history.weeklyClasses.length; context.avgWeeklyClasses = avgWeekly > 0 ? avgWeekly : 1; } processLine(bestMatch.line, subject, jsonData, bestMatch.word, context); if (jsonData[subject.code]) { history.totals.push(jsonData[subject.code].total); const weeklySum = subject.schedule.reduce((a, b) => a + b, 0); history.weeklyClasses.push(weeklySum > 0 ? weeklySum : 1); } } }); }; processAllSubjects(); processAllSubjects(); return jsonData; }
            function processOCRText(text) { const extractedJson = extractDataToJson(text, selectedClass.subjects); console.log("Extracted JSON:", JSON.stringify(extractedJson, null, 2)); processJsonAndCalculate(extractedJson); }
            function validateAndCorrectData(jsonData) { if (!selectedClass || !selectedClass.subjects) return jsonData; const frequencyGroups = {}; selectedClass.subjects.forEach(subject => { if (jsonData[subject.code]) { const weeklyFrequency = subject.schedule.reduce((a, b) => a + b, 0); if (weeklyFrequency > 0) { if (!frequencyGroups[weeklyFrequency]) { frequencyGroups[weeklyFrequency] = []; } frequencyGroups[weeklyFrequency].push(subject.code); } } }); for (const freq in frequencyGroups) { const subjectCodes = frequencyGroups[freq]; if (subjectCodes.length < 2) continue; const totals = subjectCodes.map(code => jsonData[code].total).sort((a, b) => a - b); const mid = Math.floor(totals.length / 2); const medianTotal = totals.length % 2 !== 0 ? totals[mid] : Math.round((totals[mid - 1] + totals[mid]) / 2); subjectCodes.forEach(code => { const originalData = jsonData[code]; if (Math.abs(originalData.total - medianTotal) > 15) { console.warn(`Data Correction: Subject ${code} total (${originalData.total}) is an outlier compared to its group median (${medianTotal}). Auto-correcting.`); const originalPercent = originalData.total > 0 ? (originalData.present / originalData.total) : 0; const newTotal = medianTotal; const newPresent = Math.round(newTotal * originalPercent); jsonData[code] = { total: newTotal, present: newPresent }; } }); } return jsonData; }
            function processJsonAndCalculate(jsonData) { jsonData = validateAndCorrectData(jsonData); const attendanceDataForCalc = [], missedSubjects = []; const classSubjectCodes = new Set(selectedClass.subjects.map(s => s.code)); selectedClass.subjects.forEach(subject => { if (jsonData[subject.code]) { attendanceDataForCalc.push({ ...subject, totalHeld: jsonData[subject.code].total, attended: jsonData[subject.code].present }); } else { missedSubjects.push(subject); } }); const unmatchedOcrCodes = Object.keys(jsonData).filter(code => !classSubjectCodes.has(code)); if (unmatchedOcrCodes.length > 0) { showToast(`⚠️ Unrecognized codes: ${unmatchedOcrCodes.join(', ')}`, 'warning'); console.warn('OCR extracted codes not in class:', unmatchedOcrCodes); } if (missedSubjects.length > 0 && attendanceDataForCalc.length > 0) { ocrResultsCache = jsonData; openPartialEntryModal(missedSubjects); return; } if (Object.keys(jsonData).length === 0) { alert('Could not extract any attendance data. Please try manual entry.'); return; } calculateAttendance(attendanceDataForCalc); }

            function calculateAttendance(attendanceData) {
                const resultsSection = document.getElementById('resultsSection');

                // Ensure results section is visible
                resultsSection.style.display = 'block';

                // Initialize the structure with Header and View Containers
                resultsSection.innerHTML = `
                <h2>📊 Attendance Analysis & Projections</h2>
                <div id="analysisResults" class="results-grid"></div>
                <div id="tabularAnalysisSection" style="display: none; margin-top: 20px;"></div>
                <div id="graphAnalysisSection" style="display: none; margin-top: 20px;"></div>
            `;

                const analysisResults = [];

                attendanceData.forEach(subject => {
                    const currentDate = new Date(document.getElementById('currentDate').value);
                    const lastDate = new Date(document.getElementById('lastDate').value);
                    const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));
                    const remaining = countClassesInRange(new Date(currentDate.getTime() + 86400000), lastDate, subject.schedule, holidayDates, subject.code);

                    const attended = subject.initialAttended ?? subject.attended;
                    const totalHeld = subject.initialTotal ?? subject.totalHeld;

                    analysisResults.push({
                        ...subject,
                        remaining,
                        attended: attended,
                        totalHeld: totalHeld,
                        initialAttended: attended,
                        initialTotal: totalHeld
                    });
                });

                currentAnalysisData = analysisResults;

                const snapshot = {
                    results: JSON.parse(JSON.stringify(currentAnalysisData)),
                    settings: {
                        minAttendance: document.getElementById('minAttendanceInput').value,
                        overallMode: document.getElementById('overallCriteriaCheckbox').checked,
                        currentDate: document.getElementById('currentDate').value,
                        lastDate: document.getElementById('lastDate').value
                    },
                    timestamp: new Date()
                };
                calculationHistory.unshift(snapshot);
                if (calculationHistory.length > 10) calculationHistory.pop();
                updateHistoryDropdown();

                if (isOverallMode()) {
                    displayOverallAnalysis();
                } else {
                    displayPerSubjectAnalysis();
                }

                document.getElementById('pdfDownloadContainer').innerHTML = `<button class="btn success-btn" onclick="downloadCurrentReportPDF()">Download Report (PDF)</button>`;

                const leavePlannerSection = document.getElementById('leavePlannerSection');
                if (leavePlannerSection) leavePlannerSection.style.display = 'block';

                generateLeavePlanner();

                const maxLeaveRec = document.getElementById('maxLeaveRecommendation');
                if (maxLeaveRec) maxLeaveRec.style.display = 'block';

                calculateMaxSafeLeave();
                recommendMedicalCertificates(); // NEW: Medical Certificate Recommendation

                const leaveRecContainer = document.getElementById('leaveRecommendationContainer');
                if (leaveRecContainer) leaveRecContainer.style.display = 'block';
                findLongWeekends();
                updateDailyDashboard();

                // UX Enhancement: Scroll to results
                document.querySelector('#resultsSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Check if calculation was triggered from Portal Mode
                // If yes, prompt user to update portal data
                setTimeout(() => {
                    promptPortalUpdate();
                }, 500); // Small delay to let results render first
            }

            function displayPerSubjectAnalysis() {
                const container = document.getElementById('analysisResults');
                container.innerHTML = ''; // Clear previous cards

                currentAnalysisData.forEach(subject => {
                    const { alertClass, alertMessage, stats } = getSubjectAnalysis(subject.attended, subject.totalHeld, subject.remaining);
                    container.innerHTML += `
                    <div class="subject-card">
                        <div class="subject-title">${subject.name} (${subject.code})</div>
                        <div class="stats-grid">
                            ${generateStatItemHTML(`currentPercent_${subject.code}`, 'Current %', stats.currentPercent.toFixed(1) + '%', 'The attendance percentage based on classes held so far.')}
                            ${generateStatItemHTML(`maxPercent_${subject.code}`, 'Attend All Classes %', stats.projectedMaxPercent.toFixed(1) + '%', 'Your final percentage if you attend ALL remaining classes.')}
                            ${generateStatItemHTML(`minPercent_${subject.code}`, 'Skip All Classes %', stats.projectedMinPercent.toFixed(1) + '%', 'Your final percentage if you SKIP all remaining classes.')}
                            ${stats.projectedMaxPercent >= (getMinAttendanceCriteria() * 100) ? generateStatItemHTML(`safeSkipPercent_${subject.code}`, 'After Safe Skips %', stats.safeSkipPercent.toFixed(1) + '%', 'Your final percentage after skipping the maximum number of classes while staying above the minimum requirement.') : ''}
                            <div class="stat-item">
                                <div class="stat-value-editable">
                                    <input type="number" id="attended_${subject.code}" value="${subject.attended}" oninput="recalculateSubject('${subject.code}')"> / 
                                    <input type="number" id="total_${subject.code}" value="${subject.totalHeld}" oninput="recalculateSubject('${subject.code}')">
                                </div>
                                <div class="stat-label">Attended / Held</div>
                            </div>
                            ${generateStatItemHTML(`remaining_${subject.code}`, 'Remaining', stats.remaining, 'Total number of classes from tomorrow until the last working day.')}
                            ${generateStatItemHTML(`stillNeed_${subject.code}`, 'Need to Attend', stats.stillNeed, 'The minimum number of remaining classes you MUST attend to meet the requirement.')}
                            ${generateStatItemHTML(`maxSkippable_${subject.code}`, 'Can Skip', stats.maxSkippable, 'The maximum number of remaining classes you can miss and still meet the requirement.')}
                        </div>
                        <div id="alert_${subject.code}" class="alert-message ${alertClass}">${alertMessage}</div>
                    </div>`;
                });

                // Preserve current view mode (or use saved preference if currentView is not set)
                const viewToUse = currentView || localStorage.getItem('defaultView') || 'table';
                switchView(viewToUse);
            }

            // --- VIEW SWITCHING & ANALYTICS ---

            // Load saved view preference or default to table (never default to graph)
            let currentView = localStorage.getItem('defaultView') || 'table';
            if (currentView === 'graph') currentView = 'table'; // Ensure graph is never default

            function switchView(view) {
                currentView = view;

                // Save preference for cards/table only (never save graph as default)
                if (view === 'cards' || view === 'table') {
                    localStorage.setItem('defaultView', view);
                }

                const analysisResults = document.getElementById('analysisResults');
                const tabularAnalysisSection = document.getElementById('tabularAnalysisSection');
                const graphAnalysisSection = document.getElementById('graphAnalysisSection');

                if (analysisResults) analysisResults.style.display = view === 'cards' ? 'grid' : 'none';
                if (tabularAnalysisSection) tabularAnalysisSection.style.display = view === 'table' ? 'block' : 'none';
                if (graphAnalysisSection) graphAnalysisSection.style.display = view === 'graph' ? 'block' : 'none';

                if (view === 'table') renderTabularAnalysis();
                if (view === 'graph') renderAttendanceChart();
            }

            function renderTabularAnalysis() {
                const container = document.getElementById('tabularAnalysisSection');
                if (!container) return;

                if (!currentAnalysisData || currentAnalysisData.length === 0) {
                    container.innerHTML = '<p style="text-align:center; padding:20px;">No data available. Please calculate attendance first.</p>';
                    return;
                }

                const minAttendance = getMinAttendanceCriteria() * 100;

                let html = `
                <div class="card" style="padding: 5px;">
                    <h3 style="margin-bottom: 10px; font-size: 1.2rem;">📊 Detailed Attendance Table</h3>
                    <div style="overflow-x: hidden;"> <!-- Disable scroll to force fit -->
                    <table class="analysis-table">
                        <thead>
                            <tr>
                                <th>Sub</th>
                                <th>Att/Tot</th>
                                <th>Curr%</th>
                                <th>Max%</th>
                                <th>Min%</th>
                                <th>Safe%</th>
                                <th>Rem</th>
                                <th>Need</th>
                                <th>Skip</th>
                            </tr>
                        </thead>
                        <tbody>`;

                currentAnalysisData.forEach(subject => {
                    const { stats } = getSubjectAnalysis(subject.attended, subject.totalHeld, subject.remaining);
                    const statusColor = stats.currentPercent >= minAttendance ? 'var(--success-grad-start)' : 'var(--danger-color)';
                    const safeSkipVal = stats.projectedMaxPercent >= minAttendance ? stats.safeSkipPercent.toFixed(0) + '%' : '-';

                    html += `
                    <tr>
                        <td class="subject-cell" style="font-weight: 500;">${getSubjectAcronym(subject.name)}</td>
                        <td>
                            <div class="stat-value-editable" style="justify-content: center; gap: 2px;">
                                <input type="number" id="table_attended_${subject.code}" value="${subject.attended}" oninput="recalculateSubject('${subject.code}', 'table')">
                                <span>/</span>
                                <input type="number" id="table_total_${subject.code}" value="${subject.totalHeld}" oninput="recalculateSubject('${subject.code}', 'table')">
                            </div>
                        </td>
                        <td style="font-weight: bold; color: ${statusColor}"><span id="table_currentPercent_${subject.code}">${stats.currentPercent.toFixed(0)}%</span></td>
                        <td><span id="table_maxPercent_${subject.code}">${stats.projectedMaxPercent.toFixed(0)}%</span></td>
                        <td><span id="table_minPercent_${subject.code}">${stats.projectedMinPercent.toFixed(0)}%</span></td>
                        <td><span id="table_safeSkipPercent_${subject.code}">${safeSkipVal}</span></td>
                        <td><span id="table_remaining_${subject.code}">${stats.remaining}</span></td>
                        <td style="font-weight: bold; color: var(--warning-color);"><span id="table_stillNeed_${subject.code}">${stats.stillNeed}</span></td>
                        <td style="font-weight: bold; color: var(--success-grad-start);"><span id="table_maxSkippable_${subject.code}">${stats.maxSkippable}</span></td>
                    </tr>`;
                });

                if (isOverallMode()) {
                    const overall = currentAnalysisData.reduce((acc, subject) => {
                        acc.attended += subject.attended;
                        acc.totalHeld += subject.totalHeld;
                        acc.remaining += subject.remaining;
                        return acc;
                    }, { attended: 0, totalHeld: 0, remaining: 0 });

                    const { stats } = getSubjectAnalysis(overall.attended, overall.totalHeld, overall.remaining);
                    const statusColor = stats.currentPercent >= minAttendance ? 'var(--success-grad-start)' : 'var(--danger-color)';
                    const safeSkipVal = stats.projectedMaxPercent >= minAttendance ? stats.safeSkipPercent.toFixed(0) + '%' : '-';

                    html += `
                    <tr style="background-color: var(--light-bg); font-weight: bold; border-top: 2px solid var(--border-color);">
                        <td class="subject-cell">OVERALL</td>
                        <td>${overall.attended}/${overall.totalHeld}</td>
                        <td style="color: ${statusColor}">${stats.currentPercent.toFixed(0)}%</td>
                        <td>${stats.projectedMaxPercent.toFixed(0)}%</td>
                        <td>${stats.projectedMinPercent.toFixed(0)}%</td>
                        <td>${safeSkipVal}</td>
                        <td>${stats.remaining}</td>
                        <td style="color: var(--warning-color);">${stats.stillNeed}</td>
                        <td style="color: var(--success-grad-start);">${stats.maxSkippable}</td>
                    </tr>`;
                }

                // Add legend
                html += `</tbody></table></div>
                    <div style="margin-top: 15px; padding: 10px; background: var(--light-bg); border-radius: 8px; font-size: 0.85rem;">
                        <h4 style="margin: 0 0 8px 0; font-size: 0.95rem;">📖 Legend</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
                            <div><strong>Sub:</strong> Subject</div>
                            <div><strong>Att/Tot:</strong> Attended / Total</div>
                            <div><strong>Curr%:</strong> Current %</div>
                            <div><strong>Max%:</strong> Attend All Classes %</div>
                            <div><strong>Min%:</strong> Skip All Classes %</div>
                            <div><strong>Safe%:</strong> After Safe Skips %</div>
                            <div><strong>Rem:</strong> Remaining Classes</div>
                            <div><strong>Need:</strong> Need to Attend</div>
                            <div><strong>Skip:</strong> Can Skip</div>
                        </div>
                        <h4 style="margin: 12px 0 8px 0; font-size: 0.95rem;">📚 Subjects</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">`;

                currentAnalysisData.forEach(subject => {
                    html += `<div><strong>${getSubjectAcronym(subject.name)}:</strong> ${subject.name}</div>`;
                });

                html += `</div></div></div>`;
                container.innerHTML = html;
            }

            let attendanceChartInstance = null;

            function renderAttendanceChart() {
                const container = document.getElementById('graphAnalysisSection');
                if (!container) return;

                if (!currentAnalysisData || currentAnalysisData.length === 0) {
                    container.innerHTML = '<p style="text-align:center; padding:20px;">No data available. Please calculate attendance first.</p>';
                    return;
                }

                const minAttendance = getMinAttendanceCriteria() * 100;
                const isOverall = isOverallMode();

                if (isOverall) {
                    // Overall Mode Graph - Show aggregated metrics
                    const overall = currentAnalysisData.reduce((acc, subject) => {
                        acc.attended += subject.attended;
                        acc.totalHeld += subject.totalHeld;
                        acc.remaining += subject.remaining;
                        return acc;
                    }, { attended: 0, totalHeld: 0, remaining: 0 });

                    const { stats } = getSubjectAnalysis(overall.attended, overall.totalHeld, overall.remaining);

                    container.innerHTML = `
                    <div class="card">
                        <h3 style="margin-bottom: 15px;">📊 Overall Attendance Progress</h3>
                        <div style="height: 400px; position: relative;">
                            <canvas id="attendanceChartCanvas"></canvas>
                        </div>
                    </div>`;

                    const ctx = document.getElementById('attendanceChartCanvas').getContext('2d');

                    if (attendanceChartInstance) {
                        attendanceChartInstance.destroy();
                    }

                    const labels = ['Current %', 'Attend All %', 'Skip All %', 'Required %'];
                    const data = [
                        stats.currentPercent,
                        stats.projectedMaxPercent,
                        stats.projectedMinPercent,
                        minAttendance
                    ];
                    const colors = [
                        stats.currentPercent >= minAttendance ? 'rgba(46, 204, 113, 0.7)' : 'rgba(231, 76, 60, 0.7)',
                        'rgba(52, 152, 219, 0.7)',
                        'rgba(52, 73, 94, 0.7)',
                        'rgba(243, 156, 18, 0.7)'
                    ];
                    const borderColors = [
                        stats.currentPercent >= minAttendance ? '#2ecc71' : '#e74c3c',
                        '#3498db',
                        '#34495e',
                        '#f39c12'
                    ];

                    attendanceChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Overall Attendance',
                                data: data,
                                backgroundColor: colors,
                                borderColor: borderColors,
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y', // Horizontal bar chart
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: { display: true, text: 'Percentage (%)' }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            return context.dataset.label + ': ' + context.raw.toFixed(1) + '%';
                                        }
                                    }
                                },
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                } else {
                    // Per-Subject Mode Graph
                    container.innerHTML = `
                    <div class="card">
                        <h3 style="margin-bottom: 15px;">📈 Per-Subject Attendance Overview</h3>
                        <div style="height: 400px; position: relative;">
                            <canvas id="attendanceChartCanvas"></canvas>
                        </div>
                    </div>`;

                    const ctx = document.getElementById('attendanceChartCanvas').getContext('2d');

                    if (attendanceChartInstance) {
                        attendanceChartInstance.destroy();
                    }

                    const labels = currentAnalysisData.map(s => s.code);
                    const currentData = currentAnalysisData.map(s => {
                        const { stats } = getSubjectAnalysis(s.attended, s.totalHeld, s.remaining);
                        return stats.currentPercent;
                    });
                    const requiredData = currentAnalysisData.map(() => minAttendance);

                    attendanceChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [
                                {
                                    label: 'Current %',
                                    data: currentData,
                                    backgroundColor: currentData.map(val => val >= minAttendance ? 'rgba(46, 204, 113, 0.7)' : 'rgba(231, 76, 60, 0.7)'),
                                    borderColor: currentData.map(val => val >= minAttendance ? '#2ecc71' : '#e74c3c'),
                                    borderWidth: 1
                                },
                                {
                                    label: 'Required %',
                                    data: requiredData,
                                    type: 'line',
                                    borderColor: '#3498db',
                                    borderDash: [5, 5],
                                    pointRadius: 0,
                                    borderWidth: 2,
                                    fill: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: { display: true, text: 'Percentage (%)' }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            return context.dataset.label + ': ' + context.raw.toFixed(1) + '%';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }

            function displayOverallAnalysis() {
                const container = document.getElementById('analysisResults');
                container.innerHTML = '';

                const overall = currentAnalysisData.reduce((acc, subject) => {
                    acc.attended += subject.attended;
                    acc.totalHeld += subject.totalHeld;
                    acc.remaining += subject.remaining;
                    return acc;
                }, { attended: 0, totalHeld: 0, remaining: 0 });

                const { alertClass, alertMessage, stats } = getSubjectAnalysis(overall.attended, overall.totalHeld, overall.remaining);

                container.innerHTML += `
                <div class="subject-card" style="border-left-color: var(--primary-grad-start);">
                    <div class="subject-title">📈 Overall Attendance Summary</div>
                    <div class="stats-grid">
                        ${generateStatItemHTML('overall_currentPercent', 'Current %', stats.currentPercent.toFixed(1) + '%', 'The overall attendance percentage based on all classes held so far.')}
                        ${generateStatItemHTML('overall_maxPercent', 'Attend All Classes %', stats.projectedMaxPercent.toFixed(1) + '%', 'Your final overall percentage if you attend ALL remaining classes.')}
                        ${generateStatItemHTML('overall_minPercent', 'Skip All Classes %', stats.projectedMinPercent.toFixed(1) + '%', 'Your final overall percentage if you SKIP all remaining classes.')}
                        ${stats.projectedMaxPercent >= (getMinAttendanceCriteria() * 100) ? generateStatItemHTML('overall_safeSkipPercent', 'After Safe Skips %', stats.safeSkipPercent.toFixed(1) + '%', 'Your final percentage after skipping the maximum number of classes while staying above the minimum requirement.') : ''}
                        ${generateStatItemHTML('overall_attendedTotal', 'Attended / Held', `${overall.attended} / ${overall.totalHeld}`, 'Total classes attended versus total classes held across all subjects.')}
                        ${generateStatItemHTML('overall_remaining', 'Remaining', stats.remaining, 'Total number of classes remaining across all subjects.')}
                        ${generateStatItemHTML('overall_stillNeed', 'Need to Attend', stats.stillNeed, 'The minimum number of remaining classes you MUST attend to meet the overall requirement.')}
                        ${generateStatItemHTML('overall_maxSkippable', 'Can Skip', stats.maxSkippable, 'The maximum number of remaining classes you can miss and still meet the overall requirement.')}
                    </div>
                    <div class="alert-message ${alertClass}">${alertMessage}</div>
                </div>`;

                // Preserve current view mode
                if (currentView) {
                    switchView(currentView);
                }
            }

            function getSubjectAnalysis(attended, totalHeld, remaining, minCriteriaOverride = null) {
                const minCriteria = minCriteriaOverride !== null ? minCriteriaOverride : getMinAttendanceCriteria();
                const finalTotal = totalHeld + remaining;
                const minRequired = finalTotal > 0 ? Math.ceil(minCriteria * finalTotal) : 0;
                const stillNeed = Math.max(0, minRequired - attended);
                const maxSkippable = Math.max(0, remaining - stillNeed);

                const currentPercent = totalHeld === 0 ? 0 : (attended / totalHeld) * 100;
                const projectedMaxPercent = finalTotal === 0 ? 0 : ((attended + remaining) / finalTotal) * 100;
                const projectedMinPercent = finalTotal === 0 ? 0 : (attended / finalTotal) * 100;
                const safeSkipPercent = finalTotal === 0 ? 0 : ((attended + stillNeed) / finalTotal) * 100;

                let alertClass = '', alertMessage = '';
                if (stillNeed > remaining) {
                    alertClass = 'danger';
                    const classesNeeded = minRequired - (attended + remaining);
                    alertMessage = `<strong>Cannot Reach ${minCriteria * 100}%!</strong> Your max possible attendance is ${projectedMaxPercent.toFixed(1)}%.`;
                    if (projectedMaxPercent >= 65) {
                        alertMessage += `<br>🚨 You may need to condone <strong>${classesNeeded}</strong> class(es) with a medical certificate.`;
                    } else {
                        alertMessage += `<br>🛑 **Detainment Likely:** Max attendance is below 65%.`;
                    }
                } else if (currentPercent < (minCriteria * 100)) {
                    alertClass = 'warning';
                    alertMessage = `<strong>Action Required:</strong> You must attend at least <strong>${stillNeed}</strong> of the remaining ${remaining} classes.`;
                } else {
                    alertClass = 'success';
                    alertMessage = `<strong>On Track!</strong> You can afford to miss up to <strong>${maxSkippable}</strong> more classes.`;
                }
                return { alertClass, alertMessage, stats: { currentPercent, projectedMaxPercent, projectedMinPercent, safeSkipPercent, remaining, stillNeed, maxSkippable, finalTotal, attended, totalHeld } };
            }

            function generateStatItemHTML(id, label, value, tooltipText) {
                return `
                <div class="stat-item">
                    <div class="stat-value" id="${id}">${value}</div>
                    <div class="stat-label">
                        ${label}
                        <i class="info-icon">i<span class="tooltip">${tooltipText}</span></i>
                    </div>
                </div>`;
            }

            // --- REWRITTEN: This function now performs surgical DOM updates to prevent cursor jumping ---
            function recalculateSubject(subjectCode, source = 'card') {
                const subjectData = currentAnalysisData.find(s => s.code === subjectCode);
                if (!subjectData) return;

                let newAttended, newTotal;

                // Get values based on source
                if (source === 'card') {
                    newAttended = parseInt(document.getElementById(`attended_${subjectCode}`).value, 10) || 0;
                    newTotal = parseInt(document.getElementById(`total_${subjectCode}`).value, 10) || 0;
                } else {
                    newAttended = parseInt(document.getElementById(`table_attended_${subjectCode}`).value, 10) || 0;
                    newTotal = parseInt(document.getElementById(`table_total_${subjectCode}`).value, 10) || 0;
                }

                // Sync the OTHER input immediately
                if (source === 'card') {
                    const tableAttended = document.getElementById(`table_attended_${subjectCode}`);
                    const tableTotal = document.getElementById(`table_total_${subjectCode}`);
                    if (tableAttended) tableAttended.value = newAttended;
                    if (tableTotal) tableTotal.value = newTotal;
                } else {
                    const cardAttended = document.getElementById(`attended_${subjectCode}`);
                    const cardTotal = document.getElementById(`total_${subjectCode}`);
                    if (cardAttended) cardAttended.value = newAttended;
                    if (cardTotal) cardTotal.value = newTotal;
                }

                // Visual validation feedback (apply to both if they exist)
                const inputs = [
                    document.getElementById(`attended_${subjectCode}`),
                    document.getElementById(`total_${subjectCode}`),
                    document.getElementById(`table_attended_${subjectCode}`),
                    document.getElementById(`table_total_${subjectCode}`)
                ];

                inputs.forEach(input => {
                    if (input) input.style.borderColor = newTotal < newAttended ? 'var(--danger-color)' : '';
                });

                if (newTotal < newAttended) return; // Stop if data is invalid

                // Update the central data store
                subjectData.attended = newAttended;
                subjectData.totalHeld = newTotal;
                subjectData.initialAttended = newAttended; // Ensure these are kept in sync for future full calcs
                subjectData.initialTotal = newTotal;

                // Recalculate stats for this subject only
                const { alertClass, alertMessage, stats } = getSubjectAnalysis(newAttended, newTotal, subjectData.remaining);
                const minAttendance = getMinAttendanceCriteria() * 100;
                const safeSkipVal = stats.projectedMaxPercent >= minAttendance ? stats.safeSkipPercent.toFixed(1) + '%' : '-';

                // Update the UI surgically without re-rendering the whole component
                const updateElementText = (id, text) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = text;
                };

                // Update Card View Elements
                updateElementText(`currentPercent_${subjectCode}`, stats.currentPercent.toFixed(1) + '%');
                updateElementText(`maxPercent_${subjectCode}`, stats.projectedMaxPercent.toFixed(1) + '%');
                updateElementText(`minPercent_${subjectCode}`, stats.projectedMinPercent.toFixed(1) + '%');
                updateElementText(`safeSkipPercent_${subjectCode}`, stats.safeSkipPercent.toFixed(1) + '%');
                updateElementText(`stillNeed_${subjectCode}`, stats.stillNeed);
                updateElementText(`maxSkippable_${subjectCode}`, stats.maxSkippable);

                // Update Table View Elements
                updateElementText(`table_currentPercent_${subjectCode}`, stats.currentPercent.toFixed(1) + '%');
                updateElementText(`table_maxPercent_${subjectCode}`, stats.projectedMaxPercent.toFixed(1) + '%');
                updateElementText(`table_minPercent_${subjectCode}`, stats.projectedMinPercent.toFixed(1) + '%');
                updateElementText(`table_safeSkipPercent_${subjectCode}`, safeSkipVal);
                updateElementText(`table_remaining_${subjectCode}`, stats.remaining);
                updateElementText(`table_stillNeed_${subjectCode}`, stats.stillNeed);
                updateElementText(`table_maxSkippable_${subjectCode}`, stats.maxSkippable);

                const alertDiv = document.getElementById(`alert_${subjectCode}`);
                if (alertDiv) {
                    alertDiv.className = `alert-message ${alertClass}`;
                    alertDiv.innerHTML = alertMessage;
                }

                // If overall mode is active, that display needs a full refresh
                if (isOverallMode()) {
                    displayOverallAnalysis();
                }

                // Re-calculate other dependent sections of the page
                calculateMaxSafeLeave();
                updateDailyDashboard();

                // UX Improvement: Scroll to the updated card

                attendedInput.closest('.subject-card')?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }


            function countClassesInRange(startDate, endDate, schedule, classHolidays, subjectCode) {
                let total = 0;
                if (!startDate || !endDate || startDate > endDate) return 0;
                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                let current = new Date(startDate.getTime());
                const holidayTimestamps = new Set(classHolidays.map(h => h.setHours(0, 0, 0, 0)));
                while (current <= endDate) {
                    const dayOfWeek = current.getDay();
                    const isHolidayDay = holidayTimestamps.has(new Date(current).setHours(0, 0, 0, 0));
                    if (!isHolidayDay) {
                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                        if (schedule[scheduleIndex]) {
                            let classesToday = schedule[scheduleIndex];
                            const dateStr = formatLocalDate(current);
                            const dayLog = logs[dateStr];
                            if (dayLog && dayLog[subjectCode] === 'Cancelled') {
                                classesToday = 0;
                            }
                            total += classesToday;
                        }
                    }
                    current.setDate(current.getDate() + 1);
                }
                return total;
            }

            function showInputMode(mode) { // mode can be 'upload', 'manual', 'json'
                const uploadSection = document.getElementById('uploadSection');
                const manualInput = document.getElementById('manualInput');
                const jsonInput = document.getElementById('jsonInput');
                const previewImage = document.getElementById('previewImage');

                if (uploadSection) uploadSection.style.display = mode === 'upload' ? 'block' : 'none';
                if (manualInput) manualInput.style.display = mode === 'manual' ? 'block' : 'none';
                if (jsonInput) jsonInput.style.display = mode === 'json' ? 'block' : 'none';

                if (mode !== 'upload' && previewImage) {
                    previewImage.style.display = 'none';
                }
            }

            function generateManualInputs() { const subjectsGrid = document.getElementById('subjectsGrid'); subjectsGrid.innerHTML = ''; if (!selectedClass) return; selectedClass.subjects.forEach((subject, index) => { subjectsGrid.innerHTML += `<div class="subject-input"><h4>${subject.name} (${subject.code})</h4><div class="manual-input-fields"><input type="number" id="manual_total_${index}" placeholder="Total Hours Held" min="0"><input type="number" id="manual_attended_${index}" placeholder="Hours Attended" min="0"></div></div>`; }); }
            function calculateFromManual() {
                const attendanceData = [];
                if (!selectedClass) return;
                selectedClass.subjects.forEach((subject, index) => {
                    const totalInput = document.getElementById(`manual_total_${index}`);
                    const attendedInput = document.getElementById(`manual_attended_${index}`);

                    if (totalInput && attendedInput) {
                        const total = parseInt(totalInput.value) || 0;
                        const attended = parseInt(attendedInput.value) || 0;

                        if (total > 0 && attended <= total) {
                            attendanceData.push({ ...subject, attended, totalHeld: total });
                        }
                    }
                });

                if (attendanceData.length > 0) calculateAttendance(attendanceData);
                else alert("Please enter valid data for at least one subject.");
            }
            function openPartialEntryModal(missedSubjects) { const grid = document.getElementById('partialSubjectsGrid'); grid.innerHTML = ''; missedSubjects.forEach(subject => { grid.innerHTML += `<div class="subject-input"><h4>${subject.name} (${subject.code})</h4><div class="manual-input-fields"><input type="number" id="partial_total_${subject.code}" placeholder="Total Hours Held" min="0"><input type="number" id="partial_attended_${subject.code}" placeholder="Hours Attended" min="0"></div></div>`; }); openModal('partialEntryModal'); }
            function submitPartialEntry() {
                const grid = document.getElementById('partialSubjectsGrid');
                if (!grid) return;

                const newEntries = {};
                grid.querySelectorAll('.subject-input').forEach(inputDiv => {
                    const codeMatch = inputDiv.querySelector('h4').textContent.match(/\(([^)]+)\)/);
                    if (!codeMatch) return;

                    const code = codeMatch[1];
                    const totalInput = document.getElementById(`partial_total_${code}`);
                    const attendedInput = document.getElementById(`partial_attended_${code}`);

                    if (totalInput && attendedInput) {
                        const total = parseInt(totalInput.value) || 0;
                        const attended = parseInt(attendedInput.value) || 0;

                        if (total > 0 && attended <= total) newEntries[code] = { total, present: attended };
                    }
                });
                const mergedJson = { ...ocrResultsCache, ...newEntries };
                closeModal('partialEntryModal');
                processJsonAndCalculate(mergedJson);
            }

            function calculateFromJson() {
                const jsonInput = document.getElementById('attendanceJsonPasteArea');
                const jsonString = jsonInput ? jsonInput.value : '';

                if (!jsonString.trim()) {
                    alert("Please paste the JSON data into the text area.");
                    return;
                }
                try {
                    const jsonData = JSON.parse(jsonString);
                    if (typeof jsonData !== 'object' || jsonData === null || Array.isArray(jsonData)) {
                        throw new Error("Invalid JSON format. Expected an object of subjects.");
                    }
                    processJsonAndCalculate(jsonData);
                } catch (error) {
                    alert(`Error parsing JSON: ${error.message}`);
                }
            }

            function copyAttendanceAIPrompt() {
                const promptText = `Analyze the provided university attendance screenshot. Your task is to generate a single JSON object that maps subject codes to their attendance figures. Follow this structure precisely:

{
  "SUBJECT-CODE-1": { "total": TOTAL_CLASSES_HELD, "present": CLASSES_ATTENDED },
  "SUBJECT-CODE-2": { "total": TOTAL_CLASSES_HELD, "present": CLASSES_ATTENDED },
  ...
}

CRITICAL INSTRUCTIONS:
1.  The keys of the JSON object MUST be the exact subject codes as they appear in the screenshot.
2.  Each value MUST be an object containing two keys: "total" (for total classes held) and "present" (for classes attended).
3.  The values for "total" and "present" must be integers.
4.  Provide ONLY the JSON code block in your response, with no extra text, explanations, or markdown formatting.`;
                navigator.clipboard.writeText(promptText).then(() => alert('AI prompt for attendance data copied to clipboard!'), () => alert('Failed to copy prompt.'));
            }



            // === NOTIFICATION FUNCTIONS ===
            function openNotificationSettings() {
                // Require class selection for notification settings
                const className = document.getElementById('classSelector')?.value;
                if (!className || !classes[className]) {
                    showToast('Please select a class first to configure notifications.', 'warning');
                    return;
                }

                const modal = document.getElementById('notificationSettingsModal');
                // Use per-class notification settings
                const settings = JSON.parse(localStorage.getItem(`notificationSettings_${className}`) || '{"enabled":true,"time":"16:30"}');

                document.getElementById('notificationEnabled').checked = settings.enabled;
                document.getElementById('notificationTime').value = settings.time;
                document.getElementById('notificationTimeGroup').style.display = settings.enabled ? 'block' : 'none';

                // Display timezone info
                const now = new Date();
                const timezoneOffset = now.getTimezoneOffset();
                const timezoneOffsetHours = -timezoneOffset / 60;
                const isIST = timezoneOffsetHours === 5.5;
                const timezoneLabel = isIST ? 'IST (UTC+5:30)' : `UTC${timezoneOffsetHours >= 0 ? '+' : ''}${timezoneOffsetHours}`;

                const timezoneInfoEl = document.getElementById('timezoneInfo');
                if (timezoneInfoEl) {
                    timezoneInfoEl.textContent = `Your timezone: ${timezoneLabel}${!isIST ? ' ⚠️ Not IST' : ''}`;
                }

                // Store which class we're configuring
                modal.dataset.className = className;

                // Update modal title to show class name
                const modalHeader = modal.querySelector('.modal-header h2');
                if (modalHeader) {
                    modalHeader.innerHTML = `🔔 Notification Settings<br><small style="font-size:0.7em;opacity:0.8">for ${className}</small>`;
                }

                openModal('notificationSettingsModal');
            }

            function toggleNotifications(enabled) {
                if (enabled) {
                    // Check if current date is within semester range
                    const currentClass = localStorage.getItem('lastOpenedClass');
                    if (currentClass) {
                        const classesData = JSON.parse(localStorage.getItem('classes') || '{}');
                        const classData = classesData[currentClass];

                        if (classData && classData.lastDate) {
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);

                            const semesterEnd = new Date(classData.lastDate);
                            semesterEnd.setHours(0, 0, 0, 0);

                            // Only check if today is after last working date
                            if (today > semesterEnd) {
                                alert(`⚠️ Cannot enable notifications.\n\nCurrent date is after the semester end date (${classData.lastDate}).\nPlease update your class's last working date.`);
                                document.getElementById('notificationEnabled').checked = false;
                                document.getElementById('notificationTimeGroup').style.display = 'none';
                                return;
                            }
                        }
                    }
                }

                document.getElementById('notificationTimeGroup').style.display = enabled ? 'block' : 'none';
            }

            // Auto-enable notifications when portal mode is activated
            async function autoEnableNotificationsForPortal() {
                // Check if notifications are already enabled
                const existingSettings = JSON.parse(localStorage.getItem('notificationSettings') || '{}');
                if (existingSettings.enabled) {
                    console.log('Notifications already enabled, skipping auto-enable.');
                    return;
                }

                // Check browser support
                if (!('Notification' in window)) {
                    console.log('Browser does not support notifications.');
                    return;
                }

                // Request permission
                let permission = Notification.permission;
                if (permission === 'default') {
                    permission = await Notification.requestPermission();
                }

                if (permission !== 'granted') {
                    console.log('Notification permission not granted.');
                    return;
                }

                // Auto-enable with default time (4:30 PM)
                const defaultTime = '16:30';
                const settings = { enabled: true, time: defaultTime };
                localStorage.setItem('notificationSettings', JSON.stringify(settings));

                // Sync to IndexedDB for Service Worker
                try {
                    const dbRequest = indexedDB.open('BunkitDB', 1);
                    dbRequest.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings');
                        }
                    };
                    dbRequest.onsuccess = (event) => {
                        const db = event.target.result;
                        const tx = db.transaction(['settings'], 'readwrite');
                        const store = tx.objectStore('settings');
                        store.put(settings, 'notificationSettings');
                        store.delete('lastNotificationDate');

                        // Notify SW to update/schedule
                        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                            navigator.serviceWorker.controller.postMessage({ type: 'SETTINGS_UPDATED' });
                        }
                    };
                } catch (error) {
                    console.error('Error syncing notifications to IndexedDB:', error);
                }

                // Start notification checker
                startNotificationChecker();

                // Notify user
                alert(`🔔 Daily Notifications Enabled!\n\nYou'll receive daily reminders at ${defaultTime} to log your attendance.\n\nYou can change this time in Notification Settings from the menu.`);

                console.log('Notifications auto-enabled for Portal Mode.');
            }

            async function saveNotificationSettings() {
                try {
                    const enabled = document.getElementById('notificationEnabled').checked;
                    const time = document.getElementById('notificationTime').value;

                    // Get the class name from the modal dataset OR fallback to selector
                    const modal = document.getElementById('notificationSettingsModal');
                    let className = modal.dataset.className;

                    if (!className) {
                        className = document.getElementById('classSelector')?.value;
                        console.warn('Modal dataset.className missing, using selector value:', className);
                    }

                    if (!className) {
                        alert('Error: No class selected. Please close and re-open the settings.');
                        return;
                    }

                    console.log('Saving notification settings for class:', className, { enabled, time });

                    if (enabled) {
                        // FIRST: Check if current date is within semester range
                        if (classes[className]) {
                            const classData = classes[className];

                            if (classData && classData.lastDate) {
                                const today = new Date();
                                today.setHours(0, 0, 0, 0);

                                const semesterEnd = new Date(classData.lastDate);
                                semesterEnd.setHours(0, 0, 0, 0);

                                // Only check if current date is after last working date
                                if (today > semesterEnd) {
                                    showToast(`Cannot enable notifications. Current date is after the semester end date (${classData.lastDate}).`, 'error');
                                    document.getElementById('notificationEnabled').checked = false;
                                    return;
                                }
                            }
                        }

                        // Request notification permission
                        if (!('Notification' in window)) {
                            showToast('This browser does not support notifications.', 'error');
                            return;
                        }

                        const permission = await Notification.requestPermission();
                        console.log('Notification permission:', permission);

                        if (permission !== 'granted') {
                            showToast('Notification permission denied. Please enable notifications in your browser settings.', 'error');
                            document.getElementById('notificationEnabled').checked = false;
                            return;
                        }
                    }

                    const settings = { enabled, time };
                    // Save per-class notification settings
                    localStorage.setItem(`notificationSettings_${className}`, JSON.stringify(settings));

                    // CRITICAL FIX: Smartly handle "Already Shown" flag
                    const now = new Date();
                    const [targetHour, targetMinute] = time.split(':').map(Number);
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();

                    const targetTotalMinutes = targetHour * 60 + targetMinute;
                    const currentTotalMinutes = currentHour * 60 + currentMinute;

                    if (currentTotalMinutes >= targetTotalMinutes) {
                        // Time has passed for today. Mark as shown so it doesn't fire immediately.
                        localStorage.setItem('lastNotificationDate', now.toDateString());
                        console.log('Target time passed for today. Marked as shown to prevent immediate trigger.');
                    } else {
                        // Time is in the future. Clear flag to ensure it fires today.
                        localStorage.removeItem('lastNotificationDate');
                        console.log('Target time is in future. Flag cleared to allow firing today.');
                    }

                    // Sync to IndexedDB for Service Worker
                    try {
                        const dbRequest = indexedDB.open('BunkitDB', 1);
                        dbRequest.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('settings')) {
                                db.createObjectStore('settings');
                            }
                        };
                        dbRequest.onsuccess = (event) => {
                            const db = event.target.result;
                            const tx = db.transaction(['settings'], 'readwrite');
                            const store = tx.objectStore('settings');

                            // Store per-class notification settings
                            store.put(settings, `notificationSettings_${className}`);

                            // Also store all classes data for SW to check lastDate
                            store.put(classes, 'classesData');

                            // Clear the per-class notification shown flag
                            store.delete(`lastNotificationDate_${className}`);

                            console.log(`Settings for ${className} synced to IndexedDB.`);

                            // Notify SW to update/schedule
                            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                                navigator.serviceWorker.controller.postMessage({
                                    type: 'SETTINGS_UPDATED',
                                    className: className
                                });
                            }
                        };
                    } catch (error) {
                        console.error('Error syncing to IndexedDB:', error);
                    }

                    if (enabled) {
                        startNotificationChecker();

                        // Show test notification immediately
                        if (Notification.permission === 'granted') {
                            if ('serviceWorker' in navigator) {
                                navigator.serviceWorker.ready.then(registration => {
                                    registration.showNotification('✅ Notifications Enabled!', {
                                        body: `You'll receive daily reminders at ${time}`,
                                        icon: '/icon-192x192.png'
                                    });
                                });
                            } else {
                                new Notification('✅ Notifications Enabled!', {
                                    body: `You'll receive daily reminders at ${time}`,
                                    icon: '/icon-192x192.png'
                                });
                            }
                        }

                        showToast(`Daily notifications enabled at ${time}!`, 'success');
                        alert(`✅ Notifications enabled for ${time}!`);
                    } else {
                        stopNotificationChecker();
                        showToast('Daily notifications disabled.', 'info');
                        alert('🔕 Notifications disabled.');
                    }

                    closeModal('notificationSettingsModal');

                } catch (e) {
                    console.error('Save Notification Settings Error:', e);
                    showToast('Failed to save settings: ' + e.message, 'error');
                }
            }

            // === API SETTINGS FUNCTIONS ===
            function openAPISettings() {
                const modal = document.getElementById('ocrSettingsModal');

                // Populate the modal content if it's empty
                if (!modal.innerHTML) {
                    modal.innerHTML = `
                        <div class="modal-content">
                            <button class="modal-close" onclick="closeModal('ocrSettingsModal')">&times;</button>
                            <div class="modal-header">
                                <h2>🔑 API Settings</h2>
                                <p>Configure your Gemini API key for OCR and AI Assistant features</p>
                            </div>
                            <div class="form-group">
   <label for="personalGeminiKey">Personal Gemini API Key</label>
                                <input type="text" id="personalGeminiKey" placeholder="Optional: Enter your Gemini API key">
                                <p style="font-size:  0.85rem; color: var(--medium-text); margin-top: 5px;">
                                    Get your free 10,000 requests/day Gemini API key from <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>
                                </p>
                            </div>
                            <div id="personalQuotaStatus" style="display: none; margin-top: 10px; padding: 10px; background: var(--light-bg); border-radius: 8px;">
                                <p style="font-size: 0.9rem; margin: 0;">
                                    ⏱️ Personal Quota Used Today: <strong id="personalQuotaCount">0/10000</strong>
                                </p>
                            </div>
                            <div style="text-align: center; margin-top: 20px;">
                                <button class="btn primary-btn" onclick="saveAPISettings()">Save Settings</button>
                                <button class="btn secondary-btn" onclick="testPersonalKey()">Test API Key</button>
                            </div>
                        </div>
                    `;
                }

                // Load saved settings
                const personalKey = localStorage.getItem('personalGeminiKey') || '';
                const personalKeyInput = document.getElementById('personalGeminiKey');
                if (personalKeyInput) {
                    personalKeyInput.value = personalKey;
                }

                // Update quota display
                if (typeof updateOCRQuotaDisplay === 'function') {
                    updateOCRQuotaDisplay();
                }

                openModal('ocrSettingsModal');
            }

            let notificationInterval = null;



            function startNotificationChecker() {
                stopNotificationChecker(); // Clear any existing interval

                console.log('🎯 Starting notification checker...');

                // Check every minute
                notificationInterval = setInterval(checkAndShowNotification, 60000);
                console.log('⏱️ Interval set for every 60 seconds');

                // Check immediately
                checkAndShowNotification();
            }

            function stopNotificationChecker() {
                if (notificationInterval) {
                    clearInterval(notificationInterval);
                    notificationInterval = null;
                }
            }

            // In-App Toast Notification
            function showToast(title, message, options = {}) {
                const container = document.getElementById('toastContainer');
                if (!container) return;

                const toast = document.createElement('div');
                toast.className = 'toast';

                const icon = options.icon || '🔔';
                const actionText = options.actionText || 'Log Now';
                const onAction = options.onAction || (() => { });
                const duration = options.duration || 8000;

                toast.innerHTML = `
                    <span class="toast-icon">${icon}</span>
                    <div class="toast-content">
                        <div class="toast-title">${title}</div>
                        <div class="toast-message">${message}</div>
                    </div>
                    <button class="toast-action">${actionText}</button>
                    <button class="toast-close">&times;</button>
                `;

                container.appendChild(toast);

                // Action button click
                toast.querySelector('.toast-action').addEventListener('click', () => {
                    onAction();
                    dismissToast(toast);
                });

                // Close button click
                toast.querySelector('.toast-close').addEventListener('click', () => {
                    dismissToast(toast);
                });

                // Auto-dismiss after duration
                setTimeout(() => dismissToast(toast), duration);
            }

            function dismissToast(toast) {
                if (!toast || toast.classList.contains('hide')) return;
                toast.classList.add('hide');
                setTimeout(() => toast.remove(), 300);
            }

            // 🎉 Celebration Confetti Animation
            function celebrateAchievement(type = 'default') {
                if (typeof confetti !== 'function') {
                    console.log('Confetti not loaded');
                    return;
                }

                const configs = {
                    'default': {
                        particleCount: 100,
                        spread: 70,
                        origin: { y: 0.6 }
                    },
                    'attendance-safe': {
                        particleCount: 150,
                        spread: 100,
                        colors: ['#22c55e', '#16a34a', '#15803d'],
                        origin: { y: 0.6 }
                    },
                    'perfect-attendance': {
                        particleCount: 200,
                        spread: 120,
                        colors: ['#ffd700', '#ffed4a', '#f59e0b'],
                        origin: { y: 0.5 },
                        scalar: 1.2
                    },
                    'goal-reached': {
                        particleCount: 100,
                        angle: 60,
                        spread: 55,
                        origin: { x: 0 }
                    },
                    'streak': {
                        particleCount: 50,
                        spread: 60,
                        colors: ['#8b5cf6', '#a78bfa', '#c4b5fd']
                    }
                };

                const config = configs[type] || configs['default'];
                confetti(config);

                // For goal-reached, fire from both sides
                if (type === 'goal-reached') {
                    setTimeout(() => {
                        confetti({
                            ...config,
                            angle: 120,
                            origin: { x: 1 }
                        });
                    }, 150);
                }
            }

            // 📲 Share Attendance Summary on WhatsApp
            function shareOnWhatsApp() {
                // Calculate overall and subject-wise attendance
                let totalPresent = 0;
                let totalClasses = 0;
                let summaryLines = [];

                for (const className in classes) {
                    const classData = classes[className];
                    const present = classData.subjects.reduce((sum, s) => sum + (s.present || 0), 0);
                    const total = classData.subjects.reduce((sum, s) => sum + (s.total || 0), 0);

                    if (total > 0) {
                        const percentage = ((present / total) * 100).toFixed(1);
                        totalPresent += present;
                        totalClasses += total;

                        // Add class summary
                        const emoji = percentage >= 75 ? '✅' : percentage >= 65 ? '⚠️' : '❌';
                        summaryLines.push(`${emoji} ${className}: ${percentage}%`);
                    }
                }

                const overallPercentage = totalClasses > 0
                    ? ((totalPresent / totalClasses) * 100).toFixed(1)
                    : 0;

                // Create WhatsApp message
                const message = `📊 *My Attendance Summary* - Bunk it

📈 *Overall: ${overallPercentage}%*

${summaryLines.join('\n')}

📅 Updated: ${new Date().toLocaleDateString('en-IN')}

📱 Track your attendance: https://bunkitapp.in`;

                // Open WhatsApp with pre-filled message
                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
                window.open(whatsappUrl, '_blank');
            }

            // Share specific class attendance
            function shareClassOnWhatsApp(className) {
                const classData = classes[className];
                if (!classData) return;

                let subjectLines = [];
                let totalPresent = 0;
                let totalClasses = 0;

                classData.subjects.forEach(subject => {
                    const present = subject.present || 0;
                    const total = subject.total || 0;
                    totalPresent += present;
                    totalClasses += total;

                    if (total > 0) {
                        const percentage = ((present / total) * 100).toFixed(1);
                        const emoji = percentage >= 75 ? '✅' : percentage >= 65 ? '⚠️' : '❌';
                        subjectLines.push(`${emoji} ${subject.name}: ${percentage}% (${present}/${total})`);
                    }
                });

                const overallPercentage = totalClasses > 0
                    ? ((totalPresent / totalClasses) * 100).toFixed(1)
                    : 0;

                const message = `📚 *${className} - Attendance*

📈 *Overall: ${overallPercentage}%*

${subjectLines.join('\n')}

📅 Updated: ${new Date().toLocaleDateString('en-IN')}

📱 Track attendance: https://bunkitapp.in`;

                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
                window.open(whatsappUrl, '_blank');
            }

            function checkAndShowNotification() {
                const checkTime = new Date().toLocaleString();
                localStorage.setItem('lastNotificationCheck', checkTime);
                console.log('🔔 ========== NOTIFICATION CHECK START ==========');
                console.log('🔔 Check Time:', checkTime);

                const now = new Date();
                const today = formatLocalDate(now);
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const currentTotalMinutes = currentHour * 60 + currentMinute;

                // Get timezone info
                const timezoneOffset = now.getTimezoneOffset();
                const timezoneOffsetHours = -timezoneOffset / 60;
                const isIST = timezoneOffsetHours === 5.5;
                console.log(`⏰ Timezone: ${isIST ? 'IST' : 'UTC' + (timezoneOffsetHours >= 0 ? '+' : '') + timezoneOffsetHours}`);

                // Loop through all classes and check each one's notification settings
                let notificationShown = false;
                for (const className in classes) {
                    if (!classes.hasOwnProperty(className)) continue;

                    const classData = classes[className];
                    const settings = JSON.parse(localStorage.getItem(`notificationSettings_${className}`) || '{"enabled":true,"time":"16:30"}');

                    console.log(`🔔 Checking class: ${className}`, settings);

                    // Skip if notifications disabled for this class
                    if (!settings.enabled) {
                        console.log(`  ❌ ${className}: Notifications disabled`);
                        continue;
                    }

                    // Skip if class has ended (today > lastDate)
                    if (classData.lastDate && today > classData.lastDate) {
                        console.log(`  ⏭️ ${className}: Class ended (${classData.lastDate})`);
                        continue;
                    }

                    // Check if current time matches this class's notification time
                    const [targetHour, targetMinute] = settings.time.split(':').map(Number);
                    const targetTotalMinutes = targetHour * 60 + targetMinute;

                    if (currentTotalMinutes >= targetTotalMinutes) {
                        // Check if already shown for this class today
                        const lastShownKey = `lastNotificationDate_${className}`;
                        const lastShown = localStorage.getItem(lastShownKey);

                        if (lastShown !== now.toDateString()) {
                            console.log(`  ✅ ${className}: Time to notify! (${settings.time})`);

                            // Set this class as last opened so notification shows for it
                            localStorage.setItem('lastOpenedClass', className);

                            // Show system notification (works in background too)
                            showDailyLogNotification();

                            // Show in-app toast notification (only when app is in foreground)
                            showToast(
                                '📚 Attendance Reminder',
                                `Time to log today's attendance for ${className}!`,
                                {
                                    icon: '📝',
                                    actionText: 'Log Now',
                                    duration: 10000,
                                    onAction: () => {
                                        // Select this class and open log modal
                                        document.getElementById('classSelector').value = className;
                                        onClassChange();
                                        openLogModal();
                                    }
                                }
                            );

                            localStorage.setItem(lastShownKey, now.toDateString());
                            notificationShown = true;

                            // Only show one notification at a time to avoid spam
                            break;
                        } else {
                            console.log(`  ⏭️ ${className}: Already shown today`);
                        }
                    } else {
                        console.log(`  ⏳ ${className}: Not time yet (current: ${currentTotalMinutes}, target: ${targetTotalMinutes})`);
                    }
                }

                if (!notificationShown) {
                    console.log('🔔 No notifications triggered this check');
                }
                console.log('🔔 ========== NOTIFICATION CHECK END ==========');
            }


            // Diagnostic test function
            async function testNotificationNow() {
                console.log('🧪 === NOTIFICATION DIAGNOSTIC TEST ===');

                // Test 1: Browser Support
                if (!('Notification' in window)) {
                    alert('❌ FAILED: Your browser does not support notifications');
                    console.error('❌ No Notification API support');
                    return;
                }
                console.log('✅ Browser supports notifications');

                // Test 2: Permission Status
                console.log(`📋 Current permission: ${Notification.permission}`);

                if (Notification.permission === 'denied') {
                    alert('❌ FAILED: Notifications are blocked.\n\nPlease enable notifications in your browser settings:\n- Click the lock/info icon in address bar\n- Change notifications to "Allow"');
                    return;
                }

                if (Notification.permission === 'default') {
                    console.log('📣 Requesting permission...');
                    const permission = await Notification.requestPermission();
                    console.log(`📋 Permission after request: ${permission}`);

                    if (permission !== 'granted') {
                        alert('❌ FAILED: Permission denied');
                        return;
                    }
                }

                console.log('✅ Permission granted');

                // Test 3: Show test notification
                // Test 3: Show test notification
                try {
                    console.log('🚀 Creating test notification...');
                    if ('serviceWorker' in navigator) {
                        console.log('⚙️ Checking Service Worker registration...');
                        const registration = await navigator.serviceWorker.getRegistration();

                        if (!registration) {
                            throw new Error('Service Worker not registered! Please reload the page.');
                        }

                        console.log('✅ Service Worker found:', registration.scope);

                        // Check if active
                        if (!registration.active) {
                            console.warn('⚠️ Service Worker found but not active yet.');
                        }

                        await registration.showNotification('🧪 Test Notification', {
                            body: 'If you see this, notifications are working!',
                            icon: '/icon-192x192.png',
                            badge: '/notification-icon.png',
                            tag: 'test',
                            requireInteraction: false
                        });
                        console.log('✅ Test notification dispatched via Service Worker');
                    } else {
                        new Notification('🧪 Test Notification', {
                            body: 'If you see this, notifications are working!',
                            icon: '/icon-192x192.png',
                            badge: '/notification-icon.png',
                            tag: 'test',
                            requireInteraction: false
                        });
                    }

                    console.log('✅ Test notification created successfully!');
                    alert('✅ SUCCESS!\n\nIf you don\'t see a notification, check:\n1. System notification settings (Windows/Mac)\n2. Browser notification settings\n3. Do Not Disturb mode');

                } catch (error) {
                    console.error('❌ Error creating notification:', error);
                    alert(`❌ FAILED: ${error.message}`);
                }

                // Test 4: Check if notification checker is running
                const settings = JSON.parse(localStorage.getItem('notificationSettings') || '{"enabled":true}');
                console.log('📋 Notification settings:', settings);
                console.log(`📋 Notification interval active: ${notificationInterval !== null}`);
            }

            async function showDailyLogNotification() {
                console.log('📢 ========== showDailyLogNotification CALLED ==========');
                const lastClass = localStorage.getItem('lastOpenedClass');
                const className = lastClass || 'your class';

                // Check if class has ended (today > lastDate)
                if (lastClass && classes[lastClass]) {
                    const classData = classes[lastClass];
                    const today = formatLocalDate(new Date());
                    if (classData.lastDate && today > classData.lastDate) {
                        console.log('⏭️ BLOCKED: Class has ended (today:', today, '> lastDate:', classData.lastDate, ')');
                        return; // Don't show notification for ended class
                    }
                }

                console.log('📢 Permission status:', Notification.permission);

                if (Notification.permission !== 'granted') {
                    console.error('❌ FAILED: Notification permission not granted!');
                    alert('Notification permission not granted. Please enable notifications.');
                    return;
                }

                try {
                    if ('serviceWorker' in navigator) {
                        console.log('📢 Using Service Worker for notification...');
                        const registration = await navigator.serviceWorker.ready;

                        if (!registration) {
                            throw new Error('Service Worker not ready');
                        }

                        console.log('📢 SW Ready, showing notification...');
                        await registration.showNotification('📚 Attendance Log Reminder', {
                            body: `Time to log today's attendance for ${className}!`,
                            icon: '/icon-192x192.png',
                            badge: '/badge-icon.png',
                            tag: 'daily-log',
                            requireInteraction: true,
                            data: { url: '/?openLog=true' }
                        });
                        console.log('✅ Notification shown successfully via SW!');
                    } else {
                        console.log('📢 Using legacy Notification API...');
                        const notification = new Notification('📚 Attendance Log Reminder', {
                            body: `Time to log today's attendance for ${className}!`,
                            icon: '/icon-192x192.png',
                            badge: '/badge-icon.png',
                            tag: 'daily-log',
                            requireInteraction: true
                        });
                        notification.onclick = function () {
                            window.focus();
                            notification.close();
                            if (lastClass && classes[lastClass]) {
                                document.getElementById('classSelector').value = lastClass;
                                onClassChange();
                            }
                        };
                        console.log('✅ Notification shown successfully via legacy API!');
                    }
                } catch (error) {
                    console.error('❌ ERROR showing notification:', error);
                    alert(`Failed to show notification: ${error.message}\n\nPlease check:\n1. Windows notification settings\n2. Browser notification permissions\n3. Do Not Disturb / Focus Assist mode`);
                }
                console.log('📢 ========== showDailyLogNotification END ==========');
            }



            function openAddClassModal(className = null) {
                const modal = document.getElementById('addClassModal');
                const title = document.getElementById('addClassModalTitle');
                const shareTabBtn = document.getElementById('shareTabBtn');

                editingClassName = className;
                switchModalTab('form');

                const newClassNameInput = document.getElementById('newClassName');
                const newClassLastDateInput = document.getElementById('newClassLastDate');
                const subjectsContainer = document.getElementById('subjectsContainer');
                const jsonTabBtn = document.getElementById('jsonTabBtn');

                if (className && classes[className]) {
                    // Edit Mode
                    if (title) title.textContent = '📝 Edit Class';
                    const classData = classes[className];
                    if (newClassNameInput) newClassNameInput.value = className;
                    if (newClassLastDateInput) newClassLastDateInput.value = classData.lastDate;
                    if (subjectsContainer) subjectsContainer.innerHTML = '';
                    classData.subjects.forEach(subject => addSubjectEntry(subject));
                    populateHolidaysInModal(classData.holidays || defaultHolidays);

                    if (jsonTabBtn) jsonTabBtn.style.display = 'none';
                    if (shareTabBtn) shareTabBtn.style.display = 'inline-block';
                } else {
                    // Add Mode
                    if (title) title.textContent = '➕ Add New Class';
                    if (newClassNameInput) newClassNameInput.value = '';
                    if (newClassLastDateInput) newClassLastDateInput.value = '';
                    if (subjectsContainer) subjectsContainer.innerHTML = '';
                    addSubjectEntry();
                    populateHolidaysInModal([]);

                    if (jsonTabBtn) jsonTabBtn.style.display = 'block';
                    if (shareTabBtn) shareTabBtn.style.display = 'none';
                }
                openModal('addClassModal');
            }
            function openImportModal() { openAddClassModal(); setTimeout(() => switchModalTab('json'), 50); }

            function openDonateModal() {
                const modal = document.getElementById('donateModal');
                modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px; text-align: center;">
                    <button class="modal-close" onclick="closeModal('donateModal')">&times;</button>
                    <div class="modal-header" style="padding-bottom: 10px;">
                        <h2>☕ Support the Developer</h2>
                        <p style="font-size: 0.95rem; color: var(--medium-text);">Help keep Bunk it free forever!</p>
                    </div>
                    
                    <div class="donate-message-box" style="background: var(--card-bg); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--secondary-grad-start); box-shadow: 0 4px 15px rgba(79, 172, 254, 0.15);">
                        <p style="font-size: 1rem; color: var(--dark-text); margin-bottom: 15px; line-height: 1.6;">
                            Hey there! 👋 I'm a solo developer building this app in my free time to help students manage their attendance better.
                        </p>
                        <p style="font-size: 0.95rem; color: var(--dark-text); margin-bottom: 15px; line-height: 1.6;">
                            Your support helps me:
                        </p>
                        <ul style="text-align: left; font-size: 0.9rem; color: var(--dark-text); padding-left: 25px; margin-bottom: 10px; line-height: 1.8;">
                            <li>💰 Cover API costs (AI, OCR, cloud services)</li>
                            <li>🚫 Keep the app <strong>100% ad-free</strong></li>
                            <li>☁️ Add cloud sync & user accounts</li>
                            <li>🔐 Implement secure data backup</li>
                            <li>✨ Build more useful features!</li>
                        </ul>
                    </div>
                    
                    <div style="background: var(--light-bg); padding: 20px; border-radius: 12px; border: 1px solid var(--border-color);">
                        <p style="font-weight: 600; font-size: 1.1rem; margin-bottom: 15px; color: var(--secondary-grad-start);">
                            ☕ Scan to Buy Me a Coffee
                        </p>
                        <img id="donateQRImage" src="donate-qr.png" alt="UPI QR Code" style="max-width: 200px; border-radius: 12px; border: 3px solid var(--border-color); margin-bottom: 15px; background: white; padding: 10px;">
                        <p style="font-size: 0.85rem; color: var(--medium-text); margin-top: 10px; margin-bottom: 15px;">
                            Scan with any UPI app (GPay, PhonePe, Paytm, etc.)
                        </p>
                        
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn info-btn" onclick="downloadDonateQR()" style="padding: 10px 20px; font-size: 0.9rem;">
                                📥 Download QR
                            </button>
                            <button class="btn primary-btn" onclick="shareDonateQR()" style="padding: 10px 20px; font-size: 0.9rem;">
                                📤 Share QR
                            </button>
                        </div>
                    </div>
                    
                    <p style="font-size: 0.9rem; color: var(--medium-text); margin-top: 20px; font-style: italic;">
                        💖 Every contribution, big or small, means the world to me!
                    </p>
                    
                    <!-- Buy Me a Coffee Button -->
                    <div style="margin-top: 20px;">
                        <a href="https://buymeacoffee.com/Faisalkhan119" target="_blank" rel="noopener noreferrer" 
                           style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-weight: 600; font-size: 0.95rem; border-radius: 10px; text-decoration: none; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); transition: all 0.3s ease;"
                           onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)';"
                           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.3)';">
                            ☕ Buy me a coffee
                        </a>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn secondary-btn" onclick="closeModal('donateModal')" style="padding: 12px 30px;">
                            Maybe Later
                        </button>
                    </div>
                </div>`;
                openModal('donateModal');
            }

            function downloadDonateQR() {
                const link = document.createElement('a');
                link.href = 'donate-qr.png';
                link.download = 'Bunkit_Donate_QR.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            async function shareDonateQR() {
                try {
                    const response = await fetch('donate-qr.png');
                    const blob = await response.blob();
                    const file = new File([blob], 'Bunkit_Donate_QR.png', { type: 'image/png' });

                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            title: 'Support Bunk it App',
                            text: '☕ Help keep Bunk it ad-free! Scan this QR code with any UPI app to donate.',
                            files: [file]
                        });
                    } else if (navigator.share) {
                        await navigator.share({
                            title: 'Support Bunk it App',
                            text: '☕ Help keep Bunk it ad-free! Download the app and support the developer.',
                            url: window.location.href
                        });
                    } else {
                        alert('Sharing not supported. QR will be downloaded instead.');
                        downloadDonateQR();
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        downloadDonateQR();
                    }
                }
            }

            // Comprehensive How to Use Modal
            function openHelpModal() {
                const modal = document.getElementById('helpModal');
                modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
                    <button class="modal-close" onclick="closeModal('helpModal')">&times;</button>
                    <div class="modal-header">
                        <h2>💡 How to Use Bunk it</h2>
                        <p>Complete guide to all features</p>
                    </div>
                    
                    <div style="text-align: left; padding: 10px;">
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📚 1. Setting Up Your Class</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Add Class:</strong> Click "+ Add Class" button to create a new class</li>
                            <li><strong>Class Name:</strong> Enter your class/section name (e.g., "CSE-A 3rd Sem")</li>
                            <li><strong>Last Working Date:</strong> Set the semester end date</li>
                            <li><strong>Subjects:</strong> Add each subject with name, code, and weekly schedule (classes per day)</li>
                            <li><strong>Holidays:</strong> Add holidays so they're excluded from calculations</li>
                            <li><strong>AI Import:</strong> Upload timetable screenshot to auto-fill class details</li>
                            <li><strong>QR Import:</strong> Scan a classmate's QR code to copy their class setup</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📸 2. Entering Attendance</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Image Upload (OCR):</strong> Upload attendance portal screenshot - AI extracts the numbers</li>
                            <li><strong>Manual Entry:</strong> Enter total and attended classes for each subject</li>
                            <li><strong>JSON Paste:</strong> Paste attendance data in JSON format from AI chat</li>
                            <li><strong>⚠️ Pro Tip:</strong> OCR is ~95% accurate - always verify extracted numbers</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🎓 3. Portal Mode (Daily Tracking)</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Enable:</strong> Go to "Student Portal" button → Set baseline date & semester start</li>
                            <li><strong>Daily Logs:</strong> Mark attended/skipped/cancelled classes each day</li>
                            <li><strong>Dashboard:</strong> See color-coded status (🔴 Danger, 🟡 Warning, 🟢 Safe)</li>
                            <li><strong>History:</strong> View/edit past logs using the calendar icon</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📊 4. View Options</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Card View:</strong> Detailed cards with all stats per subject</li>
                            <li><strong>Table View:</strong> Compact spreadsheet-style view</li>
                            <li><strong>Graph View:</strong> Visual analytics with charts</li>
                            <li><strong>Edit:</strong> Click attendance numbers in any view to update</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📅 5. Weekly Timetable</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>View:</strong> Auto-generated from your subject schedules</li>
                            <li><strong>Drag & Drop:</strong> Rearrange subjects by dragging</li>
                            <li><strong>Period Times:</strong> Configure start/end times for each period</li>
                            <li><strong>Colors:</strong> Subjects color-coded by attendance status</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🏖️ 6. Leave Planner</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Plan Leaves:</strong> Add dates you plan to skip</li>
                            <li><strong>See Impact:</strong> View how leaves affect your attendance</li>
                            <li><strong>Compulsory Events:</strong> Mark events you must attend</li>
                            <li><strong>Max Safe Leave:</strong> Find maximum days you can safely skip</li>
                            <li><strong>Long Weekend Finder:</strong> Discover best leave strategy for extended breaks</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🤔 7. Quick Tools</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Can I Skip Today?:</strong> Quick check if skipping today is safe</li>
                            <li><strong>Per-Subject / Overall Mode:</strong> Toggle calculation mode in settings</li>
                            <li><strong>Min Attendance %:</strong> Set your required percentage (default 75%)</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🔔 8. Notifications</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Daily Reminders:</strong> Get notified to log attendance</li>
                            <li><strong>Custom Time:</strong> Set your preferred reminder time</li>
                            <li><strong>Per-Class Settings:</strong> Configure separately for each class</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">💾 9. Backup & Sync</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Google Sign-in:</strong> Sync data across devices via Google Drive</li>
                            <li><strong>Backup:</strong> Download complete backup as JSON file</li>
                            <li><strong>Restore:</strong> Restore from backup file</li>
                            <li><strong>Export/Import:</strong> Share class setup with friends</li>
                            <li><strong>QR Code:</strong> Share class via scannable QR</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🤖 10. AI Assistant</h3>
                        <ul style="line-height: 1.8; padding-left: 20px;">
                            <li><strong>Ask Questions:</strong> Click the 🤖 button for AI help</li>
                            <li><strong>Smart Advice:</strong> Get personalized leave recommendations</li>
                            <li><strong>API Key:</strong> Set your Gemini API key in API Settings for unlimited use</li>
                        </ul>
                        
                        <div style="background: var(--light-bg); padding: 15px; border-radius: 10px; margin-top: 20px;">
                            <p style="margin: 0; font-size: 0.9rem; color: var(--dark-text);">
                                💬 <strong>Need help?</strong> Contact the developer via WhatsApp button or ask the AI assistant!
                            </p>
                        </div>
                    </div>
                </div>`;
                openModal('helpModal');
            }

            // Privacy Policy Modal
            function openPrivacyPolicy() {
                const modal = document.getElementById('privacyPolicyModal');
                modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
                    <button class="modal-close" onclick="closeModal('privacyPolicyModal')">&times;</button>
                    <div class="modal-header">
                        <h2>🔒 Privacy Policy</h2>
                        <p>Last updated: December 2024</p>
                    </div>
                    
                    <div style="text-align: left; padding: 10px; line-height: 1.8;">
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📱 Data Storage</h3>
                        <p>Bunk it stores all your data <strong>locally on your device</strong>. Your attendance data, class information, and preferences are saved in your browser's local storage.</p>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">☁️ Google Drive Sync (Optional)</h3>
                        <p>If you choose to sign in with Google, your data is synced to <strong>your personal Google Drive</strong> in a private app folder. We never access or store your data on our servers.</p>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📸 Image Processing</h3>
                        <p>When you upload attendance screenshots for OCR:</p>
                        <ul style="padding-left: 20px;">
                            <li>Images are processed by Google's Gemini AI API</li>
                            <li>Images are <strong>not stored</strong> on any server</li>
                            <li>Processing happens in real-time and data is immediately discarded</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🔑 API Keys</h3>
                        <p>Your personal Gemini API key (if provided) is stored locally on your device only. It is never sent to our servers.</p>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🌐 Third-Party Services</h3>
                        <ul style="padding-left: 20px;">
                            <li><strong>Google Sign-in:</strong> For optional cloud sync</li>
                            <li><strong>Google Gemini AI:</strong> For OCR and AI assistant</li>
                            <li><strong>Google Fonts:</strong> For typography</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📊 Analytics & Tracking</h3>
                        <p>Bunk it does <strong>NOT</strong> use any analytics, tracking, or advertising services. We don't collect usage data, personal information, or browsing behavior.</p>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🔒 Data Security</h3>
                        <ul style="padding-left: 20px;">
                            <li>All data transmission uses HTTPS encryption</li>
                            <li>Local data is protected by your device security</li>
                            <li>Google Drive sync uses OAuth 2.0 authentication</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">🗑️ Data Deletion</h3>
                        <p>You can delete all your data at any time by:</p>
                        <ul style="padding-left: 20px;">
                            <li>Clearing browser data/cache</li>
                            <li>Uninstalling the PWA</li>
                            <li>Deleting the app folder from Google Drive (if synced)</li>
                        </ul>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">👶 Children's Privacy</h3>
                        <p>This app is designed for college/university students. We do not knowingly collect information from children under 13.</p>
                        
                        <h3 style="color: var(--primary-grad-start); margin: 20px 0 10px;">📧 Contact</h3>
                        <p>For privacy concerns or questions, contact the developer via WhatsApp: +91 6386854875</p>
                        
                        <div style="background: var(--light-bg); padding: 15px; border-radius: 10px; margin-top: 20px;">
                            <p style="margin: 0; font-size: 0.9rem; color: var(--dark-text);">
                                ✅ <strong>Summary:</strong> Your data stays on your device. We don't collect, store, or sell any personal information. Optional Google sync stores data in YOUR Drive only.
                            </p>
                        </div>
                    </div>
                </div>`;
                openModal('privacyPolicyModal');
            }

            function copyAIPrompt() {
                const promptText = `Generate a JSON structure for a weekly class timetable.

**Global Fields:**
* Include \`lastDate\` (validity as YYYY-MM-DD), a list of \`holidays\` (array of YYYY-MM-DD strings), and a \`qrCode\` string (for export/sharing - use empty string).

**Subjects Array:**
* The structure must **not** include a separate \`timetableArrangement\` object. All scheduling logic belongs inside \`subjects\`.
* Each subject object must contain: \`name\`, \`code\`, \`shortName\`, and \`schedule\`.

**Schedule Logic:**
* The \`schedule\` key must be an array of 7 strings (representing days 0-6, Mon-Sun).
* Use the period number as a string (e.g., \`"1"\`).
* If a subject occupies multiple periods on one day, separate them with commas (e.g., \`"2,3"\`).
* If there is no class, use \`"0"\`.

EXACT JSON STRUCTURE:
{
  "CLASS NAME": {
    "lastDate": "YYYY-MM-DD",
    "qrCode": "",
    "holidays": ["YYYY-MM-DD", "YYYY-MM-DD"],
    "subjects": [
      {
        "name": "Full Subject Name",
        "shortName": "ABBR",
        "code": "SUBJECT-CODE",
        "schedule": ["1", "1,2", "0", "3", "0", "0", "0"]
      }
    ]
  }
}

CRITICAL INSTRUCTIONS:
1. The top-level key MUST be the class name (e.g., "CSE Core - H").
2. 'lastDate' is the single last working day of the semester.
3. 'holidays' is an array of date strings for all holiday dates.
4. For 'shortName', use a short abbreviation (2-5 characters) like "DS&A", "OS", "CO&A".
5. The 'schedule' array represents Mon(0) to Sun(6). Use period numbers as strings.
6. Provide ONLY the JSON code block in your response, with no extra text.`;
                navigator.clipboard.writeText(promptText).then(() => alert('Prompt copied to clipboard!'), () => alert('Failed to copy prompt.'));
            }

            function openExportModal() {
                const className = document.getElementById('classSelector').value;
                if (!className) { alert('Please select a class to export.'); return; }

                const classData = { ...classes[className] };

                // Add qrCode field (empty placeholder)
                classData.qrCode = classData.qrCode || '';

                // Get timetable arrangement and convert to new string schedule format
                const arrangement = getTimetableArrangement(className);

                // Process subjects to include shortName and convert schedule to string format
                if (classData.subjects) {
                    classData.subjects = classData.subjects.map((subject, index) => {
                        // Add shortName if not present
                        const shortName = subject.shortName || getSubjectShortName(subject.name);

                        // Convert schedule to new string format using timetable arrangement
                        let newSchedule = [];
                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                        days.forEach((dayName, dayIndex) => {
                            if (arrangement && arrangement[dayIndex]) {
                                // Find which periods this subject occupies
                                const periods = [];
                                arrangement[dayIndex].forEach((item, periodIndex) => {
                                    const itemCode = (typeof item === 'string') ? item : (item?.code || null);
                                    if (itemCode === subject.code) {
                                        periods.push(periodIndex + 1);
                                    }
                                });
                                newSchedule.push(periods.length > 0 ? periods.join(',') : '0');
                            } else {
                                // Fallback: use count-based format
                                const count = subject.schedule?.[dayIndex] || 0;
                                if (count > 0) {
                                    const periods = Array.from({ length: count }, (_, i) => i + 1);
                                    newSchedule.push(periods.join(','));
                                } else {
                                    newSchedule.push('0');
                                }
                            }
                        });

                        return {
                            name: subject.name,
                            shortName: shortName,
                            code: subject.code,
                            schedule: newSchedule
                        };
                    });
                }

                // Remove timetableArrangement from export (not part of new format)
                delete classData.timetableArrangement;

                const exportObject = { [className]: classData };
                const jsonString = JSON.stringify(exportObject, null, 2);
                document.getElementById('exportJsonTextarea').value = jsonString;
                openModal('exportModal');
            }
            function copyExportJson() { const jsonText = document.getElementById('exportJsonTextarea').value; navigator.clipboard.writeText(jsonText).then(() => { alert('Class JSON copied to clipboard!'); closeModal('exportModal'); }, () => alert('Failed to copy.')); }
            function editSelectedClass() { const selected = document.getElementById('classSelector').value; if (selected) openAddClassModal(selected); else alert("Please select a class to edit first."); }
            function addSubjectEntry(subject = {}) { const container = document.getElementById('subjectsContainer'); if (!container) return; const newIndex = container.children.length + 1; container.insertAdjacentHTML('beforeend', `<div class="subject-entry"><div class="subject-entry-header"><h4>Subject ${newIndex}</h4><button type="button" class="remove-subject-btn" onclick="removeSubjectEntry(this)">Remove</button></div><div class="form-group"><input type="text" placeholder="Subject Name" class="new-subject-name" value="${subject.name || ''}"></div><div class="form-group"><input type="text" placeholder="Subject Code (e.g., 21CSC202J)" class="new-subject-code" value="${subject.code || ''}"></div><label>Weekly Schedule (Mon-Sun)</label><div class="schedule-input">${['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, i) => `<div class="schedule-day"><label>${day}</label><input type="number" class="new-subject-schedule" min="0" value="${(subject.schedule && subject.schedule[i]) ?? 0}"></div>`).join('')}</div></div>`); }
            function removeSubjectEntry(button) { button.closest('.subject-entry').remove(); document.querySelectorAll('#subjectsContainer .subject-entry-header h4').forEach((h4, index) => h4.textContent = `Subject ${index + 1}`); }
            function populateHolidaysInModal(holidays) { const holidayList = document.getElementById('holidayList'); holidayList.innerHTML = ''; holidays.forEach(dateStr => { const li = document.createElement('li'); li.innerHTML = `<span>${dateStr}</span><button type="button" class="remove-holiday-btn" onclick="this.parentElement.remove()">Remove</button>`; holidayList.appendChild(li); }); }
            function addHolidayToModal() { const dateInput = document.getElementById('newHolidayDate'); const dateStr = dateInput.value; if (dateStr) { const holidayList = document.getElementById('holidayList'); if ([...holidayList.querySelectorAll('span')].some(span => span.textContent === dateStr)) { alert("This holiday is already in the list."); return; } const li = document.createElement('li'); li.innerHTML = `<span>${dateStr}</span><button type="button" class="remove-holiday-btn" onclick="this.parentElement.remove()">Remove</button>`; holidayList.appendChild(li); dateInput.value = ''; } }
            let tempTimetableArrangement = null; // Temporary storage for import verification

            function generateDefaultTimetable(subjects) {
                const ta = {};
                const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                days.forEach((day, dayIndex) => {
                    const dailySequence = [];
                    subjects.forEach(subject => {
                        // Handle subject.schedule which might be array or map ? 
                        // The app uses array [Mon, Tue...] usually.
                        const count = (subject.schedule && subject.schedule[dayIndex]) || 0;
                        for (let k = 0; k < count; k++) {
                            dailySequence.push(subject.code);
                        }
                    });
                    ta[day] = dailySequence;
                });
                return ta;
            }

            function submitClassForm() { if (isJsonMode) { submitClassFromJson(); } else { submitClassFromForm(); } }

            function submitClassFromForm() {
                const className = document.getElementById('newClassName').value.trim();
                const lastDate = document.getElementById('newClassLastDate').value;
                if (!className || !lastDate) { alert('Please fill in Class Name and Last Date.'); return; }
                const subjects = [];
                let isValid = true;
                document.querySelectorAll('#subjectsContainer .subject-entry').forEach(entry => {
                    const name = entry.querySelector('.new-subject-name').value.trim();
                    const code = entry.querySelector('.new-subject-code').value.trim();
                    const schedule = Array.from(entry.querySelectorAll('.new-subject-schedule')).map(i => parseInt(i.value) || 0);
                    if (!name || !code) isValid = false;
                    subjects.push({ name, code, schedule });
                });
                if (!isValid || subjects.length === 0) { alert('Please fill all details for each subject.'); return; }
                const holidays = [...document.getElementById('holidayList').querySelectorAll('span')].map(span => span.textContent).sort();

                if (editingClassName && editingClassName !== className) {
                    const keyPrefixes = ['notificationSettings_', 'timetable_arrangement_', 'periodTimes_', 'custom_schedules_'];
                    keyPrefixes.forEach(prefix => {
                        const oldData = localStorage.getItem(`${prefix}${editingClassName}`);
                        if (oldData) {
                            localStorage.setItem(`${prefix}${className}`, oldData);
                            localStorage.removeItem(`${prefix}${editingClassName}`);
                        }
                    });
                    delete classes[editingClassName];
                }

                const existingClass = classes[editingClassName] || classes[className] || {};
                classes[className] = { ...existingClass, lastDate, subjects, holidays };

                // === Handle Pending Imported Timetable ===
                if (tempTimetableArrangement) {
                    localStorage.setItem(`timetable_arrangement_${className}`, JSON.stringify(tempTimetableArrangement));
                    tempTimetableArrangement = null; // Clear after saving
                } else {
                    // Check if existing timetable is valid (not just exists, but has content)
                    const existingTAJson = localStorage.getItem(`timetable_arrangement_${className}`);
                    let isValidTA = false;

                    if (existingTAJson) {
                        try {
                            const parsedTA = JSON.parse(existingTAJson);
                            // Check if it has keys and at least one day is not empty
                            if (parsedTA && Object.keys(parsedTA).length > 0) {
                                const hasContent = Object.values(parsedTA).some(dayArr => Array.isArray(dayArr) && dayArr.length > 0);
                                if (hasContent) isValidTA = true;
                            }
                        } catch (e) {
                            console.warn("Invalid TA JSON found, regenerating...");
                        }
                    }

                    // If missing or invalid, force regeneration
                    if (!isValidTA) {
                        const defaultAT = generateDefaultTimetable(subjects);
                        if (Object.keys(defaultAT).length > 0) {
                            localStorage.setItem(`timetable_arrangement_${className}`, JSON.stringify(defaultAT));
                        }
                    }
                }

                saveToStorage();
                alert(`Class "${className}" saved successfully!`);
                closeModal('addClassModal');
                populateClassSelector();
                document.getElementById('classSelector').value = className;
                onClassChange();
            }

            function submitClassFromJson() {
                const jsonString = document.getElementById('jsonPasteArea').value;
                if (!jsonString) {
                    alert('Please paste the JSON data into the text area.');
                    return;
                }

                try {
                    let data = JSON.parse(jsonString);

                    // === NORMALIZE MINIFIED QR FORMAT ===
                    // QR codes use compressed keys: n=name, l=lastDate, s=subjects, sc=schedule, h=holidays, tt=timetableArrangement
                    const isMinifiedFormat = data.n && data.s && Array.isArray(data.s);

                    if (isMinifiedFormat) {
                        console.log('Detected minified QR format, normalizing...');
                        const className = data.n;
                        const normalizedData = {
                            [className]: {
                                lastDate: data.l || '',
                                qrCode: '',
                                holidays: data.h || [],
                                subjects: (data.s || []).map(sub => ({
                                    name: sub.n || '',
                                    code: sub.c || '',
                                    shortName: sub.sn || '', // If provided
                                    schedule: sub.sc || [0, 0, 0, 0, 0, 0, 0]
                                })),
                                timetableArrangement: data.tt || null
                            }
                        };
                        data = normalizedData;
                    }

                    const className = Object.keys(data)[0];
                    if (!className) throw new Error("JSON is missing the top-level class name key.");
                    const classData = data[className];
                    if (!classData.lastDate || !Array.isArray(classData.holidays) || !Array.isArray(classData.subjects)) {
                        throw new Error("JSON structure is invalid. Missing 'lastDate', 'holidays', or 'subjects'.");
                    }

                    // === DETECT AND CONVERT SCHEDULE FORMAT ===
                    // Check if using new string format (e.g., ["1", "1,2", "0"]) or old integer format (e.g., [1, 2, 0])
                    const isNewFormat = classData.subjects.some(subject => {
                        if (!subject.schedule || !Array.isArray(subject.schedule)) return false;
                        return subject.schedule.some(val => typeof val === 'string' && val !== '0' && val.includes(','));
                    }) || classData.subjects.every(subject => {
                        if (!subject.schedule || !Array.isArray(subject.schedule)) return false;
                        return subject.schedule.every(val => typeof val === 'string');
                    });

                    console.log('Schedule format detected:', isNewFormat ? 'NEW (string-based)' : 'OLD (integer-based)');

                    // Prepare Timetable Arrangement (Use imported or Generate from schedule)
                    let arrangement = classData.timetableArrangement;

                    if (isNewFormat && (!arrangement || Object.keys(arrangement).length === 0)) {
                        // Generate arrangement from new string schedule format
                        arrangement = {};
                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

                        // Calculate max periods per day
                        let maxPeriods = 0;
                        classData.subjects.forEach(subject => {
                            subject.schedule.forEach(daySchedule => {
                                if (daySchedule && daySchedule !== '0') {
                                    const periods = String(daySchedule).split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                                    if (periods.length > 0) {
                                        maxPeriods = Math.max(maxPeriods, Math.max(...periods));
                                    }
                                }
                            });
                        });

                        // Build arrangement from schedule strings
                        days.forEach((dayName, dayIndex) => {
                            arrangement[dayIndex] = Array(maxPeriods).fill(null);

                            classData.subjects.forEach(subject => {
                                if (subject.schedule && subject.schedule[dayIndex] && subject.schedule[dayIndex] !== '0') {
                                    const periods = String(subject.schedule[dayIndex]).split(',')
                                        .map(p => parseInt(p.trim()))
                                        .filter(p => !isNaN(p) && p > 0);

                                    periods.forEach(periodNum => {
                                        if (periodNum > 0 && periodNum <= maxPeriods) {
                                            arrangement[dayIndex][periodNum - 1] = subject.code;
                                        }
                                    });
                                }
                            });

                            // Clean up trailing nulls
                            while (arrangement[dayIndex].length > 0 && arrangement[dayIndex][arrangement[dayIndex].length - 1] === null) {
                                arrangement[dayIndex].pop();
                            }
                        });

                        // Convert subject schedule from string to integer count for internal use
                        classData.subjects = classData.subjects.map(subject => ({
                            ...subject,
                            shortName: subject.shortName || getSubjectShortName(subject.name),
                            schedule: subject.schedule.map(daySchedule => {
                                if (!daySchedule || daySchedule === '0') return 0;
                                return String(daySchedule).split(',').filter(p => p.trim() && p.trim() !== '0').length;
                            })
                        }));
                    } else if (!arrangement || Object.keys(arrangement).length === 0) {
                        // OLD FORMAT: Generate default timetable
                        arrangement = generateDefaultTimetable(classData.subjects);

                        // Ensure shortName exists
                        classData.subjects = classData.subjects.map(subject => ({
                            ...subject,
                            shortName: subject.shortName || getSubjectShortName(subject.name)
                        }));
                    }

                    // Store qrCode if provided
                    if (classData.qrCode) {
                        classData.qrCode = classData.qrCode;
                    }

                    // Ask user if they want to verify before saving
                    const verifyMessage = `⚠️ AI-generated JSON can sometimes have errors, especially in weekly schedules.\n\nDo you want to VERIFY the data before saving?\n\n✅ Click OK to review in form view (recommended for AI-generated JSON)\n❌ Click Cancel to save directly (if copied from a classmate)`;

                    const shouldVerify = confirm(verifyMessage);

                    if (shouldVerify) {
                        // Store arrangement in temp variable for submitClassFromForm to pick up
                        tempTimetableArrangement = arrangement;

                        // Populate form for verification
                        document.getElementById('newClassName').value = className;
                        document.getElementById('newClassLastDate').value = classData.lastDate;

                        // Clear and populate subjects
                        document.getElementById('subjectsContainer').innerHTML = '';
                        classData.subjects.forEach(subject => addSubjectEntry(subject));

                        // Clear and populate holidays
                        const holidayList = document.getElementById('holidayList');
                        holidayList.innerHTML = '';
                        (classData.holidays || []).forEach(dateStr => {
                            const li = document.createElement('li');
                            li.innerHTML = `<span>${dateStr}</span><button type="button" class="remove-holiday-btn" onclick="this.parentElement.remove()">Remove</button>`;
                            holidayList.appendChild(li);
                        });

                        // Switch to form tab for verification
                        switchModalTab('form');
                        alert('✅ Data loaded into form.\n\nPlease VERIFY the Weekly Schedule for each subject, then click "Save Class".');
                    } else {
                        // Save directly without verification
                        const existingClass = classes[className] || {};
                        classes[className] = { ...existingClass, ...classData };

                        // Save timetable arrangement
                        if (arrangement) {
                            localStorage.setItem(`timetable_arrangement_${className}`, JSON.stringify(arrangement));
                        }

                        saveToStorage();
                        alert(`Class "${className}" imported successfully!`);
                        closeModal('addClassModal');
                        populateClassSelector();
                        document.getElementById('classSelector').value = className;
                        onClassChange();
                    }
                } catch (error) {
                    alert(`Error processing JSON: ${error.message}\nPlease ensure the pasted text is valid and matches the required format.`);
                }
            }

            // === AI IMPORT FUNCTIONS ===
            function updateAIFileCount(fileInput) {
                const count = fileInput.files.length;
                const countDiv = document.getElementById('aiFileCount');
                if (count > 0) {
                    countDiv.textContent = `✅ ${count} file${count > 1 ? 's' : ''} selected`;
                } else {
                    countDiv.textContent = '';
                }
            }

            async function handleAIClassImport() {
                const fileInput = document.getElementById('aiImportFiles');
                const textInput = document.getElementById('aiImportText');
                const loadingDiv = document.getElementById('aiImportLoading');

                if (!fileInput.files.length && !textInput.value.trim()) {
                    alert('Please upload at least one image or provide some text details.');
                    return;
                }

                // Show loading
                loadingDiv.style.display = 'block';

                try {
                    // Get API key (personal first, then shared)
                    let apiKey = localStorage.getItem('personalGeminiKey') || '';

                    if (!apiKey) {
                        console.log('Using shared Gemini API key for AI Import');
                        apiKey = SHARED_GEMINI_KEY;
                    }

                    // Prepare the prompt
                    const prompt = `Analyze the provided images (timetable and/or attendance screenshot) and extract class information. ${textInput.value.trim()}

Generate a JSON object following this EXACT structure:
{
  "<CLASS_NAME>": {
    "lastDate": "YYYY-MM-DD",
    "qrCode": "",
    "holidays": ["YYYY-MM-DD"],
    "subjects": [
      {
        "name": "Full Subject Name",
        "shortName": "ABBR",
        "code": "SUBJECT-CODE",
        "schedule": ["1", "1,2", "0", "3", "0", "0", "0"]
      }
    ]
  }
}

CRITICAL RULES:
1. Use the CLASS NAME from the image or the additional text provided.
2. Set lastDate to the semester end date (if not provided, use a reasonable future date).
3. Extract holidays from the text or image if available.
4. For 'shortName', create a short abbreviation (2-5 chars) like "DS&A", "OS", "CO&A".
5. The 'schedule' array represents Mon(0) to Sun(6). For each day, use period numbers as strings.
   - If subject has class in period 1: use "1"
   - If subject has classes in periods 2 and 3: use "2,3"
   - If no class that day: use "0"
6. DO NOT include timetableArrangement - all scheduling is in the schedule array.
7. Provide ONLY the JSON code block, no explanations.`;

                    // Convert images to base64
                    const imageParts = [];
                    for (let i = 0; i < fileInput.files.length; i++) {
                        const file = fileInput.files[i];
                        const base64 = await fileToBase64(file);
                        imageParts.push({
                            inlineData: {
                                data: base64.split(',')[1],
                                mimeType: file.type
                            }
                        });
                    }

                    // Call Gemini API
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [
                                        { text: prompt },
                                        ...imageParts
                                    ]
                                }]
                            })
                        }
                    );


                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMsg = errorData.error?.message || 'Unknown error';

                        if (response.status === 400 && errorMsg.includes('API key not valid')) {
                            throw new Error('Your API key is invalid. Please check your key in OCR Settings and try again.');
                        } else if (response.status === 429) {
                            throw new Error('API quota exceeded. You have used all 10,000 requests for today. Try again tomorrow or use a different API key.');
                        } else {
                            throw new Error(`Gemini API Error (${response.status}): ${errorMsg}`);
                        }
                    }

                    const result = await response.json();
                    const generatedText = result.candidates[0]?.content?.parts[0]?.text;

                    if (!generatedText) {
                        throw new Error('No response from AI');
                    }

                    // Extract JSON from response (handle code blocks)
                    let jsonString = generatedText.trim();
                    if (jsonString.includes('```json')) {
                        jsonString = jsonString.split('```json')[1].split('```')[0].trim();
                    } else if (jsonString.includes('```')) {
                        jsonString = jsonString.split('```')[1].split('```')[0].trim();
                    }

                    // Parse and populate form
                    const data = JSON.parse(jsonString);
                    const className = Object.keys(data)[0];
                    if (!className) throw new Error("AI didn't generate a class name");

                    const classData = data[className];
                    if (!classData.lastDate || !Array.isArray(classData.subjects)) {
                        throw new Error("AI generated invalid data structure");
                    }

                    // Populate the form
                    document.getElementById('newClassName').value = className;
                    document.getElementById('newClassLastDate').value = classData.lastDate;

                    // Clear and populate subjects
                    document.getElementById('subjectsContainer').innerHTML = '';
                    classData.subjects.forEach(subject => {
                        if (typeof window.addSubjectEntry === 'function') {
                            window.addSubjectEntry(subject);
                        }
                    });

                    // Clear and populate holidays
                    const holidayList = document.getElementById('holidayList');
                    holidayList.innerHTML = '';
                    (classData.holidays || []).forEach(dateStr => {
                        const li = document.createElement('li');
                        li.innerHTML = `<span>${dateStr}</span><button type="button" class="remove-holiday-btn" onclick="this.parentElement.remove()">Remove</button>`;
                        holidayList.appendChild(li);
                    });

                    // Switch to form tab for verification
                    switchModalTab('form');
                    alert('✅ AI Import Successful!\\n\\nPlease VERIFY all data (especially weekly schedules) before saving.');

                    // Clear inputs
                    fileInput.value = '';
                    textInput.value = '';
                    document.getElementById('aiFileCount').textContent = '';

                } catch (error) {
                    console.error('AI Import Error:', error);
                    alert(`❌ AI Import Failed: ${error.message}\\n\\nTry adding more details in the text field or use a clearer image.`);
                } finally {
                    loadingDiv.style.display = 'none';
                }
            }

            // Helper function to convert file to base64
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            function generateLeavePlanner() {
                const container = document.getElementById('leavePlannerSection');
                if (!container) return;
                container.innerHTML = `
                <div class="subject-card" style="border-left-color: var(--warning-color);">
                    <div class="subject-title">🗓️ Leave & Event Planner</div>
                    <p>Add planned leaves and compulsory events to get an accurate calculation of your maximum safe leave days.</p>
                    
                    <h4 style="margin-top: 20px;">🏖️ Planned Leaves</h4>
                    <div id="leavePeriodsContainer" style="margin-top: 10px;"></div>
                    <button class="add-leave-period-btn" onclick="addLeavePeriod()">+ Add Leave Period</button>

                    <h4 style="margin-top: 20px;">📌 Compulsory Events</h4>
                     <p style="font-size:0.9rem; color: var(--medium-text);">Add specific dates you absolutely must attend.</p>
                    <div id="compulsoryPeriodsContainer" style="margin-top: 10px;"></div>
                    <button class="add-compulsory-period-btn" onclick="addCompulsoryPeriod()">+ Add Compulsory Period</button>

                    <button class="btn warning-btn" onclick="calculateMaxSafeLeave()" style="margin-top: 25px; display: block; margin-left: auto; margin-right: auto;">Recalculate Max Safe Leave</button>
                    <button class="btn danger-btn" onclick="calculateMaxPossibleBunk()" style="margin-top: 10px; display: block; margin-left: auto; margin-right: auto;">🚫 Max Possible Bunk (Avoid Detention)</button>
                    
                    <div id="leaveImpactResults" style="margin-top: 20px;"></div>
                </div>`;
                addLeavePeriod();
                addCompulsoryPeriod();
            }

            // Add container for max possible bunk results below maxLeaveRecommendation
            // The actual container already exists in HTML at line 2301

            function addLeavePeriod() {
                const container = document.getElementById('leavePeriodsContainer');
                const newPeriod = document.createElement('div');
                newPeriod.className = 'leave-period-entry';

                // Get date constraints
                const minDate = selectedClass?.portalSetup?.semesterStartDate || document.getElementById('currentDate').value;
                const maxDate = document.getElementById('lastDate').value;

                newPeriod.innerHTML = `<label>From:</label><input type="date" class="leave-start-date" min="${minDate}" max="${maxDate}" onchange="syncLeaveEndDate(this); checkForConflicts();"><label>To:</label><input type="date" class="leave-end-date" min="${minDate}" max="${maxDate}" onchange="checkForConflicts();"><button class="remove-leave-period-btn" onclick="this.parentElement.remove(); checkForConflicts();">×</button>`;
                container.appendChild(newPeriod);
            }

            function addCompulsoryPeriod() {
                const container = document.getElementById('compulsoryPeriodsContainer');
                const newPeriod = document.createElement('div');
                newPeriod.className = 'compulsory-period-entry';

                // Get date constraints
                const minDate = selectedClass?.portalSetup?.semesterStartDate || document.getElementById('currentDate').value;
                const maxDate = document.getElementById('lastDate').value;

                newPeriod.innerHTML = `<label>From:</label><input type="date" class="compulsory-start-date" min="${minDate}" max="${maxDate}" onchange="syncLeaveEndDate(this); checkForConflicts();"><label>To:</label><input type="date" class="compulsory-end-date" min="${minDate}" max="${maxDate}" onchange="checkForConflicts();"><button class="remove-compulsory-period-btn" onclick="this.parentElement.remove(); checkForConflicts();">×</button>`;
                container.appendChild(newPeriod);
            }

            function syncLeaveEndDate(startDateInput) { const endDateInput = startDateInput.parentElement.querySelector('[class$="-end-date"]'); if (!endDateInput.value || endDateInput.value < startDateInput.value) { endDateInput.value = startDateInput.value; } }

            function checkForConflicts() {
                const leaveEntries = document.querySelectorAll('.leave-period-entry');
                const compulsoryEntries = document.querySelectorAll('.compulsory-period-entry');
                let conflictFound = false;

                // Reset all leave entries first
                leaveEntries.forEach(l => l.classList.remove('unsafe-leave'));

                compulsoryEntries.forEach(c => {
                    const cStartValue = c.querySelector('.compulsory-start-date').value;
                    const cEndValue = c.querySelector('.compulsory-end-date').value;
                    if (!cStartValue || !cEndValue) return;

                    const cStart = new Date(cStartValue + 'T00:00:00');
                    const cEnd = new Date(cEndValue + 'T23:59:59');

                    leaveEntries.forEach(l => {
                        const lStartValue = l.querySelector('.leave-start-date').value;
                        const lEndValue = l.querySelector('.leave-end-date').value;
                        if (!lStartValue || !lEndValue) return;

                        const lStart = new Date(lStartValue + 'T00:00:00');
                        const lEnd = new Date(lEndValue + 'T23:59:59');

                        // Check for overlap: (StartA <= EndB) and (EndA >= StartB)
                        if (cStart <= lEnd && cEnd >= lStart) {
                            l.classList.add('unsafe-leave');
                            if (!conflictFound) {
                                alert('Warning: A planned leave period overlaps with a compulsory event. This leave is not safe and has been highlighted.');
                                conflictFound = true;
                            }
                        }
                    });
                });
            }

            function calculateLeaveImpact() {
                const resultsDiv = document.getElementById('leaveImpactResults');
                if (currentAnalysisData.length === 0) { alert("Please calculate your attendance first."); return; }

                const leavePeriods = [];
                let lastLeaveDate = null;
                document.querySelectorAll('.leave-period-entry').forEach(p => {
                    const start = p.querySelector('.leave-start-date').value;
                    const end = p.querySelector('.leave-end-date').value;
                    if (start && end && start <= end) {
                        const endDate = new Date(end + 'T00:00:00');
                        leavePeriods.push({ start: new Date(start + 'T00:00:00'), end: endDate });
                        if (!lastLeaveDate || endDate > lastLeaveDate) {
                            lastLeaveDate = endDate;
                        }
                    }
                });

                if (leavePeriods.length === 0) {
                    resultsDiv.innerHTML = '';
                    return;
                }

                const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));
                const currentDate = new Date(document.getElementById('currentDate').value + 'T00:00:00');

                resultsDiv.innerHTML = '<h4>Planned Leave Impact Analysis:</h4>';

                if (isOverallMode()) {
                    const overall = currentAnalysisData.reduce((acc, subject) => {
                        acc.attended += subject.attended;
                        acc.totalHeld += subject.totalHeld;
                        acc.remaining += subject.remaining;
                        subject.schedule.forEach((val, i) => acc.schedule[i] = (acc.schedule[i] || 0) + val);
                        return acc;
                    }, { attended: 0, totalHeld: 0, remaining: 0, schedule: Array(7).fill(0) });

                    let classesMissed = 0;
                    leavePeriods.forEach(period => { classesMissed += countClassesInRange(period.start, period.end, overall.schedule, holidayDates, 'overall'); });

                    const finalTotal = overall.totalHeld + overall.remaining;
                    const newAttended = overall.attended + overall.remaining - classesMissed;
                    const newPercent = finalTotal > 0 ? (newAttended / finalTotal) * 100 : 0;
                    const oldPercent = finalTotal > 0 ? ((overall.attended + overall.remaining) / finalTotal) * 100 : 0;

                    let classesHeldUntilReturn = countClassesInRange(new Date(currentDate.getTime() + 86400000), lastLeaveDate, overall.schedule, holidayDates, 'overall');
                    let classesMissedUntilReturn = 0;
                    leavePeriods.forEach(p => classesMissedUntilReturn += countClassesInRange(p.start, p.end > lastLeaveDate ? lastLeaveDate : p.end, overall.schedule, holidayDates, 'overall'));
                    const totalOnReturn = overall.totalHeld + classesHeldUntilReturn;
                    const attendedOnReturn = overall.attended + classesHeldUntilReturn - classesMissedUntilReturn;
                    const percentOnReturn = totalOnReturn > 0 ? (attendedOnReturn / totalOnReturn) * 100 : 0;

                    resultsDiv.innerHTML += generateImpactHTML("Overall", oldPercent, newPercent, percentOnReturn, newPercent < getMinAttendanceCriteria() * 100);

                } else {
                    currentAnalysisData.forEach(subject => {
                        const { attended, totalHeld, remaining, schedule } = subject;
                        let totalClassesMissed = 0;
                        leavePeriods.forEach(period => { totalClassesMissed += countClassesInRange(period.start, period.end, schedule, holidayDates, subject.code); });

                        const finalTotal = totalHeld + remaining;
                        const newAttended = attended + remaining - totalClassesMissed;
                        const oldPercent = finalTotal > 0 ? (((attended + remaining) / finalTotal) * 100) : 0;
                        const newPercent = finalTotal > 0 ? ((newAttended / finalTotal) * 100) : 0;

                        let classesHeldUntilReturn = countClassesInRange(new Date(currentDate.getTime() + 86400000), lastLeaveDate, schedule, holidayDates, subject.code);
                        let classesMissedUntilReturn = 0;
                        leavePeriods.forEach(p => classesMissedUntilReturn += countClassesInRange(p.start, p.end > lastLeaveDate ? lastLeaveDate : p.end, schedule, holidayDates, subject.code));
                        const totalOnReturn = totalHeld + classesHeldUntilReturn;
                        const attendedOnReturn = attended + classesHeldUntilReturn - classesMissedUntilReturn;
                        const percentOnReturn = totalOnReturn > 0 ? (attendedOnReturn / totalOnReturn) * 100 : 0;

                        resultsDiv.innerHTML += generateImpactHTML(subject.name, oldPercent, newPercent, percentOnReturn, newPercent < getMinAttendanceCriteria() * 100);
                    });
                }

                // Trigger Medical Certificate Recommendation Update
                recommendMedicalCertificates();
            }

            function generateImpactHTML(name, oldP, newP, returnP, isDanger) {
                const minCriteriaPercent = getMinAttendanceCriteria() * 100;
                return `<div class="stat-item" style="display: block; text-align: left; padding: 10px; margin-bottom: 8px;">
                                                <div style="display:flex; justify-content: space-between; align-items: center; font-weight: 600;">
                                                    <span>${name}</span>
                                                    <span>Final: ${oldP.toFixed(1)}% → <strong class="${isDanger ? 'danger' : 'success'}" style="color:${isDanger ? 'var(--danger-color)' : 'var(--success-grad-start)'};">${newP.toFixed(1)}%</strong></span>
                                                </div>
                                                <div style="font-size:0.9rem; margin-top:5px; color: var(--medium-text);">
                                                    On return, your attendance will be <strong>${returnP.toFixed(1)}%</strong>.
                                                    ${newP < minCriteriaPercent ? `<span style="color:var(--danger-color); font-weight:bold;"> (Below ${minCriteriaPercent}%)</span>` : ''}
                                                </div>
                                            </div>`;
            }

            function getPlannedLeaveCost(schedule, subjectCode) {
                const leavePeriods = [];
                document.querySelectorAll('.leave-period-entry').forEach(p => {
                    const start = p.querySelector('.leave-start-date').value;
                    const end = p.querySelector('.leave-end-date').value;
                    if (start && end && start <= end) {
                        leavePeriods.push({ start: new Date(start + 'T00:00:00'), end: new Date(end + 'T00:00:00') });
                    }
                });
                if (leavePeriods.length === 0) return 0;

                const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));
                let totalMissed = 0;
                leavePeriods.forEach(p => {
                    totalMissed += countClassesInRange(p.start, p.end, schedule, holidayDates, subjectCode);
                });
                return totalMissed;
            }

            function recommendMedicalCertificates() {
                const container = document.getElementById('medicalLeaveSection');

                // Always show the section, but display setup messages if needed
                container.style.display = 'block';

                // Check if Portal Mode is active
                if (!selectedClass || !selectedClass.portalSetup || !selectedClass.portalSetup.active) {
                    container.innerHTML = `
                    <div class="subject-card" style="border-left-color: var(--info-color);">
                        <div class="subject-title">💊 Medical Certificate Opportunity</div>
                        <div style="background: rgba(52, 152, 219, 0.1); padding: 20px; border-radius: 8px; border-left: 4px solid var(--info-color); text-align: center;">
                            <p style="color: var(--info-color); font-weight: bold; margin-bottom: 10px;">📋 Portal Mode Recommended</p>
                            <p style="margin-bottom: 15px;">For accurate Medical Certificate recommendations, switch to <strong>Portal Mode</strong> where you can track daily attendance logs.</p>
                            <p style="margin-bottom: 15px; font-size: 0.9rem; color: var(--medium-text);">Standard calculation mode provides instant analysis, but Portal Mode gives you ML recommendations based on your actual attendance history.</p>
                            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                                <button class="btn primary-btn" onclick="openPortalSetup()" style="margin-top: 10px;">🎓 Setup Portal Mode</button>
                                ${document.getElementById('standardModeToggle') ? '<button class="btn secondary-btn" onclick="switchBackToPortal()" style="margin-top: 10px;">↩️ Return to Portal</button>' : ''}
                            </div>
                        </div>
                    </div>`;
                    return;
                }

                const semesterStartDate = selectedClass.portalSetup.semesterStartDate;
                if (!semesterStartDate) {
                    container.innerHTML = `
                    <div class="subject-card" style="border-left-color: var(--warning-color);">
                        <div class="subject-title">💊 Medical Certificate Opportunity</div>
                        <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 8px; border-left: 4px solid var(--warning-color); text-align: center;">
                            <p style="color: var(--warning-color); font-weight: bold; margin-bottom: 10px;">📅 Semester Start Date Required</p>
                            <p style="margin-bottom: 15px;">Please set your <strong>Semester Start Date</strong> in Portal Settings to get Medical Certificate recommendations.</p>
                            <button class="btn warning-btn" onclick="openPortalSetup()" style="margin-top: 10px;">⚙️ Open Portal Settings</button>
                        </div>
                    </div>`;
                    return;
                }

                const isOverall = isOverallMode();
                let activeStats = null;

                if (isOverall) {
                    let totalAttended = 0, totalHeld = 0, totalRemaining = 0, totalPlannedMissed = 0;

                    currentAnalysisData.forEach(sub => {
                        totalAttended += sub.attended;
                        totalHeld += sub.totalHeld;
                        totalRemaining += sub.remaining;
                        totalPlannedMissed += getPlannedLeaveCost(sub.schedule, sub.code);
                    });

                    const finalTotal = totalHeld + totalRemaining;
                    const projectedAttended = totalAttended + totalRemaining - totalPlannedMissed;
                    const maxPossiblePercent = finalTotal > 0 ? (projectedAttended / finalTotal) * 100 : 0;

                    activeStats = {
                        name: "Overall",
                        code: "OVERALL",
                        finalTotal,
                        projectedAttended,
                        maxPossiblePercent
                    };
                } else {
                    // Per-Subject Mode: Find Bottleneck
                    let minMaxPercent = 101;
                    currentAnalysisData.forEach(sub => {
                        const plannedMissed = getPlannedLeaveCost(sub.schedule, sub.code);
                        const finalTotal = sub.totalHeld + sub.remaining;
                        const projectedAttended = sub.attended + sub.remaining - plannedMissed;
                        const maxPossiblePercent = finalTotal > 0 ? (projectedAttended / finalTotal) * 100 : 0;

                        if (maxPossiblePercent < minMaxPercent) {
                            minMaxPercent = maxPossiblePercent;
                            activeStats = {
                                name: sub.name,
                                code: sub.code,
                                finalTotal,
                                projectedAttended,
                                maxPossiblePercent
                            };
                        }
                    });
                }

                if (!activeStats) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                let html = `<div class="subject-card" style="border-left-color: var(--secondary-grad-end);">
                <div class="subject-title">🏥 Medical Certificate Opportunity</div>`;

                const minCriteria = getMinAttendanceCriteria() * 100;
                const condonationThreshold = 65;

                if (activeStats.maxPossiblePercent >= minCriteria) {
                    // CONDITION A: SAFE
                    html += `<p>You don't need a medical certificate. You can meet the requirements by attending regular classes. Your max possible attendance (after planned leaves) is <strong style="color: var(--success-grad-start);">${activeStats.maxPossiblePercent.toFixed(1)}%</strong>.</p>`;
                } else if (activeStats.maxPossiblePercent < condonationThreshold) {
                    // CONDITION C: CRITICAL
                    html += `<p style="color: var(--danger-color);"><strong>🛑 Critical:</strong> Even with Medical Leave condonation, your projected max attendance (after planned leaves) is <strong>${activeStats.maxPossiblePercent.toFixed(1)}%</strong>, which is too low to be saved.</p>`;
                } else {
                    // CONDITION B: CONDONATION NEEDED
                    const targetAttended = Math.ceil((minCriteria / 100) * activeStats.finalTotal);
                    const deficitClasses = targetAttended - activeStats.projectedAttended;

                    html += `<p style="margin-bottom: 15px;">⚠️ <strong>Warning:</strong> After accounting for your <strong>Planned Leaves</strong>, your max possible attendance drops to <strong>${activeStats.maxPossiblePercent.toFixed(1)}%</strong>. You need to apply for Medical Leave (ML) to cross <strong>${minCriteria}%</strong>.</p>`;
                    html += `<p style="margin-bottom: 15px;">You need to cover a deficit of <strong>${deficitClasses} class(es)</strong>.</p>`;

                    // Date Suggestion Algorithm
                    const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                    const start = new Date(semesterStartDate);

                    // Helper to check if a date is a planned leave and get all planned leave periods
                    const plannedLeavePeriods = [];
                    document.querySelectorAll('.leave-period-entry').forEach(p => {
                        const s = p.querySelector('.leave-start-date').value;
                        const e = p.querySelector('.leave-end-date').value;
                        if (s && e) {
                            plannedLeavePeriods.push({
                                start: new Date(s + 'T00:00:00'),
                                end: new Date(e + 'T00:00:00')
                            });
                        }
                    });

                    const isPlannedLeave = (d) => {
                        const time = d.getTime();
                        return plannedLeavePeriods.some(p => time >= p.start.getTime() && time <= p.end.getTime());
                    };

                    // Find the last (most recent) planned leave end date
                    let lastPlannedLeaveEnd = null;
                    plannedLeavePeriods.forEach(p => {
                        if (!lastPlannedLeaveEnd || p.end > lastPlannedLeaveEnd) {
                            lastPlannedLeaveEnd = p.end;
                        }
                    });

                    // Extend end date to include all planned leaves (even future ones)
                    let endDate = new Date(); // Today
                    if (lastPlannedLeaveEnd && lastPlannedLeaveEnd > endDate) {
                        endDate = lastPlannedLeaveEnd;
                    }

                    const validDates = [];

                    for (let d = new Date(start); d <= endDate; d.setDate(d.getDate() + 1)) {
                        const dateStr = formatLocalDate(d);
                        const isPlanned = isPlannedLeave(new Date(d));

                        // Include both logged skipped dates AND planned leave dates
                        if (logs[dateStr] || isPlanned) {
                            let skippedCount = 0;

                            if (isPlanned) {
                                // For planned leave dates, count all classes that would be skipped
                                if (isOverall) {
                                    selectedClass.subjects.forEach(sub => {
                                        const dayOfWeek = d.getDay();
                                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                                        skippedCount += sub.schedule[scheduleIndex] || 0;
                                    });
                                } else {
                                    const subject = selectedClass.subjects.find(s => s.code === activeStats.code);
                                    if (subject) {
                                        const dayOfWeek = d.getDay();
                                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                                        skippedCount += subject.schedule[scheduleIndex] || 0;
                                    }
                                }
                            } else if (logs[dateStr]) {
                                // For logged dates, check actual status
                                const dailyLog = logs[dateStr];

                                if (isOverall) {
                                    selectedClass.subjects.forEach(sub => {
                                        const status = dailyLog[sub.code];
                                        if (status === 'Skipped' || status === 'Absent') {
                                            const dayOfWeek = d.getDay();
                                            const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                                            skippedCount += sub.schedule[scheduleIndex] || 0;
                                        }
                                    });
                                } else {
                                    const status = dailyLog[activeStats.code];
                                    if (status === 'Skipped' || status === 'Absent') {
                                        const dayOfWeek = d.getDay();
                                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                                        const subject = selectedClass.subjects.find(s => s.code === activeStats.code);
                                        skippedCount += subject ? (subject.schedule[scheduleIndex] || 0) : 0;
                                    }
                                }
                            }

                            if (skippedCount > 0) {
                                // Calculate distance from last planned leave end date
                                let distanceFromPlannedLeaveEnd = Infinity;
                                if (lastPlannedLeaveEnd) {
                                    distanceFromPlannedLeaveEnd = Math.abs(d - lastPlannedLeaveEnd) / (1000 * 60 * 60 * 24);
                                }

                                validDates.push({
                                    date: new Date(d),
                                    count: skippedCount,
                                    dateStr,
                                    isPlannedLeave: isPlanned,
                                    distanceFromPlannedEnd: distanceFromPlannedLeaveEnd
                                });
                            }
                        }
                    }

                    // Sort by distance from planned leave end (closer to planned leave end = higher priority)
                    validDates.sort((a, b) => {
                        // First priority: dates closer to last planned leave end date
                        if (a.distanceFromPlannedEnd !== b.distanceFromPlannedEnd) {
                            return a.distanceFromPlannedEnd - b.distanceFromPlannedEnd;
                        }
                        // Second priority: more recent dates
                        return b.date - a.date;
                    });

                    // Find Consecutive Blocks
                    const blocks = [];
                    if (validDates.length > 0) {
                        let currentBlock = [validDates[0]];
                        let currentSum = validDates[0].count;

                        for (let i = 1; i < validDates.length; i++) {
                            const prevDate = validDates[i - 1].date;
                            const currDate = validDates[i].date;
                            const diffDays = Math.abs((currDate - prevDate) / (1000 * 60 * 60 * 24));

                            if (diffDays === 1) {
                                currentBlock.push(validDates[i]);
                                currentSum += validDates[i].count;
                            } else {
                                blocks.push({ dates: currentBlock, total: currentSum });
                                currentBlock = [validDates[i]];
                                currentSum = validDates[i].count;
                            }
                        }
                        blocks.push({ dates: currentBlock, total: currentSum });
                    }

                    // Strategy: Find a single block that satisfies deficit
                    let bestBlock = null;
                    for (const block of blocks) {
                        if (block.total >= deficitClasses) {
                            bestBlock = block;
                            break; // Since blocks are sorted by recency, the first one we find is the most recent sufficient block
                        }
                    }

                    if (bestBlock) {
                        // We found a consecutive block
                        const startDate = bestBlock.dates[bestBlock.dates.length - 1].dateStr;
                        const endDate = bestBlock.dates[0].dateStr;
                        const days = bestBlock.dates.length;
                        html += `<div style="background: var(--light-bg); padding: 15px; border-radius: 8px;">
                        <h4 style="margin-bottom: 10px;">Recommended Dates (Consecutive):</h4>
                        <ul style="list-style-position: inside; padding-left: 0;">
                            <li><strong>${days} Day(s)</strong> from ${startDate} to ${endDate} (Covers ${bestBlock.total} classes)</li>
                        </ul>
                        <p style="font-size: 0.85rem; color: var(--medium-text); margin-top: 10px;">Applying ML for this period will help you reach the target.</p>
                    </div>`;
                    } else {
                        // Fallback: Pick dates (prioritized by distance to planned leave) until deficit is covered
                        let accumulatedClasses = 0;
                        const selectedDates = [];

                        // Keep adding dates until we have enough to cover the deficit
                        for (const item of validDates) {
                            selectedDates.push(item);
                            accumulatedClasses += item.count;

                            // Stop when we have enough
                            if (accumulatedClasses >= deficitClasses) {
                                break;
                            }
                        }

                        if (accumulatedClasses >= deficitClasses) {
                            html += `<div style="background: var(--light-bg); padding: 15px; border-radius: 8px;">
                            <h4 style="margin-bottom: 10px;">Recommended Dates (Strategic):</h4>
                            <ul style="list-style-position: inside; padding-left: 0;">`;
                            selectedDates.forEach(d => {
                                const dateLabel = d.isPlannedLeave ? `${d.dateStr} (${d.count} classes) 📅 Planned Leave` : `${d.dateStr} (${d.count} classes)`;
                                html += `<li>${dateLabel}</li>`;
                            });
                            html += `</ul>
                            <p style="font-size: 0.85rem; color: var(--medium-text); margin-top: 10px;">Applying ML for these dates will cover ${accumulatedClasses} classes. Dates are prioritized near your planned leave periods.</p>
                        </div>`;
                        } else {
                            // Check if logs are incomplete (missing dates)
                            const today = new Date();
                            const semStart = new Date(semesterStartDate);
                            let totalWorkingDays = 0;
                            let loggedDays = 0;

                            for (let d = new Date(semStart); d <= today; d.setDate(d.getDate() + 1)) {
                                const dateStr = formatLocalDate(d);
                                const check = isHolidayOrNoClass(dateStr);

                                if (!check.isHoliday) {
                                    totalWorkingDays++;
                                    if (logs[dateStr]) loggedDays++;
                                }
                            }

                            const logsComplete = loggedDays >= totalWorkingDays * 0.9; // 90% threshold

                            if (!logsComplete) {
                                // Incomplete logs
                                html += `<div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid var(--warning-color);">
                                <p style="color: var(--warning-color); font-weight: bold; margin-bottom: 5px;">⚠️ Incomplete Daily Logs Detected</p>
                                <p><strong>Issue:</strong> You need ${deficitClasses} classes for ML, but only found ${accumulatedClasses} classes from available dates.</p>
                                <p style="margin-top: 10px;"><strong>📊 Log Status:</strong> ${loggedDays} out of ${totalWorkingDays} working days logged (${((loggedDays / totalWorkingDays) * 100).toFixed(0)}%)</p>
                                <p style="margin-top: 10px; font-size: 0.9rem;"><strong>✅ Action Required:</strong></p>
                                <ul style="margin-left: 20px; margin-top: 5px; font-size: 0.9rem;">
                                    <li>Complete your <strong>Daily Logs</strong> from <strong>${semesterStartDate}</strong> to today</li>
                                    <li>Mark days you were absent as "Skipped"</li>
                                    <li>Once complete, the system will find ML dates automatically</li>
                                </ul>
                                <p style="margin-top: 10px; padding: 10px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; font-size: 0.85rem;">
                                    💡 <strong>Tip:</strong> Visit <strong>Edit History</strong> to see your Portal Status and quickly add missing logs.
                                </p>
                            </div>`;
                            } else {
                                // Logs complete but insufficient absents
                                const plannedLeaveCount = validDates.filter(d => d.isPlannedLeave).length;
                                const skippedCount = validDates.filter(d => !d.isPlannedLeave).length;

                                html += `<div style="background: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid var(--danger-color);">
                                <p style="color: var(--danger-color); font-weight: bold; margin-bottom: 5px;">❌ Insufficient Full-Day Absents</p>
                                <p><strong>Issue:</strong> You need ${deficitClasses} classes for ML, but only have ${accumulatedClasses} classes available.</p>
                                <p style="margin-top: 10px;"><strong>📊 Available Dates:</strong></p>
                                <ul style="margin-left: 20px; margin-top: 5px;">
                                    <li><strong>${skippedCount}</strong> past absence dates (${validDates.filter(d => !d.isPlannedLeave).reduce((sum, d) => sum + d.count, 0)} classes)</li>
                                    <li><strong>${plannedLeaveCount}</strong> planned leave dates (${validDates.filter(d => d.isPlannedLeave).reduce((sum, d) => sum + d.count, 0)} classes)</li>
                                    <li><strong>Total: ${accumulatedClasses}</strong> classes (need ${deficitClasses})</li>
                                </ul>
                                <p style="margin-top: 15px; font-size: 0.9rem;"><strong>💡 Possible Solutions:</strong></p>
                                <ul style="margin-left: 20px; margin-top: 5px; font-size: 0.9rem;">
                                    <li><strong>Option 1:</strong> Reduce your planned leaves to lower the attendance requirement</li>
                                    <li><strong>Option 2:</strong> The deficit is too large to be covered by medical certificates alone</li>
                                    <li><strong>Option 3:</strong> Attend more remaining classes to improve your baseline attendance</li>
                                </ul>
                                <p style="margin-top: 10px; padding: 10px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; font-size: 0.85rem;">
                                    ℹ️ <strong>Note:</strong> Medical certificates can only cover full-day absences. Partial attendance days cannot be converted to ML.
                                </p>
                            </div>`;
                            }
                        }
                    }
                }

                html += `</div>`;
                container.innerHTML = html;
            }

            function calculateMaxSafeLeave() {
                calculateLeaveImpact(); // Run impact analysis first
                const container = document.getElementById('maxLeaveRecommendation');

                // Check if any subject's max possible attendance is below minimum required
                const minCriteria = getMinAttendanceCriteria() * 100;
                const unrecoverableSubjects = currentAnalysisData.filter(subject => {
                    const finalTotal = subject.totalHeld + subject.remaining;
                    const maxPossibleAttended = subject.attended + subject.remaining;
                    const maxPossiblePercent = finalTotal > 0 ? (maxPossibleAttended / finalTotal) * 100 : 0;
                    return maxPossiblePercent < minCriteria;
                });

                // If any subject is unrecoverable, show warning with option to exclude those subjects
                if (unrecoverableSubjects.length > 0) {
                    container.style.display = 'block';
                    const subjectNames = unrecoverableSubjects.map(s => s.name).join(', ');
                    const excludeCodes = unrecoverableSubjects.map(s => s.code).join(',');
                    container.innerHTML = `
                        <div class="subject-card" style="border-left-color: var(--danger-color);">
                            <div class="subject-title">⚠️ Max Safe Leave Unavailable</div>
                            <p style="color: var(--danger-color);">
                                <strong>Cannot calculate safe leave dates.</strong><br><br>
                                The following subject(s) cannot reach ${minCriteria}% minimum attendance even if you attend all remaining classes:<br>
                                <strong>${subjectNames}</strong><br><br>
                                Focus on attending all classes for these subjects. Consider applying for medical certificates if eligible.
                            </p>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                                <p style="font-size: 0.9rem; color: var(--medium-text); margin-bottom: 10px;">
                                    💡 Want to see leave days where you <strong>won't miss</strong> these critical subjects?
                                </p>
                                <button class="btn info-btn" onclick="calculateMaxSafeLeaveExcluding('${excludeCodes}')" style="padding: 10px 20px;">
                                    🔍 Show Safe Leave (Excluding ${unrecoverableSubjects.length > 1 ? 'These Subjects' : 'This Subject'})
                                </button>
                            </div>
                        </div>`;
                    return;
                }

                const currentDate = new Date(document.getElementById('currentDate').value + 'T00:00:00');
                const lastDate = new Date(document.getElementById('lastDate').value + 'T00:00:00');
                const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));

                // Get planned leave and compulsory dates
                const leavePeriods = Array.from(document.querySelectorAll('.leave-period-entry')).map(p => ({ start: p.querySelector('.leave-start-date').value, end: p.querySelector('.leave-end-date').value })).filter(d => d.start && d.end);
                const compulsoryPeriods = Array.from(document.querySelectorAll('.compulsory-period-entry')).map(p => ({ start: p.querySelector('.compulsory-start-date').value, end: p.querySelector('.compulsory-end-date').value })).filter(d => d.start && d.end);

                const leaveDateSet = new Set();
                leavePeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { leaveDateSet.add(d.setHours(0, 0, 0, 0)); } });

                const compulsoryDateSet = new Set();
                compulsoryPeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { compulsoryDateSet.add(d.setHours(0, 0, 0, 0)); } });


                let resultHTML = `<div class="subject-card" style="border-left-color: var(--success-grad-end);"><div class="subject-title">✅ Maximum Safe Leave</div>`;

                const futureWorkingDays = [];
                for (let d = new Date(currentDate.getTime() + 86400000); d <= lastDate; d.setDate(d.getDate() + 1)) {
                    const dayTime = new Date(d).setHours(0, 0, 0, 0);
                    if (holidayDates.some(h => h.getTime() === dayTime) || leaveDateSet.has(dayTime) || compulsoryDateSet.has(dayTime)) continue;

                    const dayOfWeek = d.getDay();
                    const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                    let totalClassesOnDay = 0;
                    const costs = {};
                    currentAnalysisData.forEach(subject => {
                        const classesOnDayForSubject = subject.schedule[scheduleIndex];
                        if (classesOnDayForSubject > 0) {
                            costs[subject.code] = classesOnDayForSubject;
                            totalClassesOnDay += classesOnDayForSubject;
                        }
                    });

                    if (totalClassesOnDay > 0) {
                        futureWorkingDays.push({ date: new Date(d), totalClasses: totalClassesOnDay, costs });
                    }
                }

                if (isOverallMode()) {
                    const overall = currentAnalysisData.reduce((acc, subject) => {
                        acc.attended += subject.initialAttended; acc.totalHeld += subject.initialTotal; acc.remaining += subject.remaining;
                        acc.schedule = acc.schedule.map((val, i) => val + subject.schedule[i]);
                        return acc;
                    }, { attended: 0, totalHeld: 0, remaining: 0, schedule: Array(7).fill(0) });

                    let leaveCost = 0;
                    leavePeriods.forEach(p => {
                        leaveCost += countClassesInRange(new Date(p.start), new Date(p.end), overall.schedule, holidayDates, 'overall');
                    });

                    const analysis = getSubjectAnalysis(overall.attended, overall.totalHeld, overall.remaining);
                    let skippableClasses = analysis.stats.maxSkippable - leaveCost;

                    if (skippableClasses < 0) {
                        resultHTML += `<p><strong>Warning:</strong> Your planned leave of ${leavePeriods.length} period(s) makes your attendance fall below the minimum. You are short by <strong>${Math.abs(skippableClasses)}</strong> classes.</p>`;
                    } else {
                        futureWorkingDays.sort((a, b) => a.totalClasses - b.totalClasses);
                        let recommendedLeaveDates = [];
                        for (const day of futureWorkingDays) {
                            if (skippableClasses >= day.totalClasses) {
                                recommendedLeaveDates.push(day.date);
                                skippableClasses -= day.totalClasses;
                            } else { break; }
                        }
                        recommendedLeaveDates.sort((a, b) => a - b);
                        if (recommendedLeaveDates.length > 0) {
                            resultHTML += `<p>After accounting for your planned leaves, you can still safely skip <strong>${recommendedLeaveDates.length} day(s)</strong>:</p>
                                        <ul style="list-style-position: inside; padding: 15px 0;">${recommendedLeaveDates.map(d => `<li>${d.toDateString()}</li>`).join('')}</ul>`;
                        } else {
                            resultHTML += `<p>After accounting for your planned leaves, you cannot afford to miss any more full days.</p>`;
                        }
                    }
                } else {
                    const skippableBudget = {};
                    let bottleneckSubject = { name: '', maxSkippable: Infinity };

                    currentAnalysisData.forEach(subject => {
                        let leaveCost = 0;
                        leavePeriods.forEach(p => {
                            leaveCost += countClassesInRange(new Date(p.start), new Date(p.end), subject.schedule, holidayDates, subject.code);
                        });
                        const analysis = getSubjectAnalysis(subject.initialAttended, subject.initialTotal, subject.remaining);
                        skippableBudget[subject.code] = analysis.stats.maxSkippable - leaveCost;

                        if (skippableBudget[subject.code] < bottleneckSubject.maxSkippable) {
                            bottleneckSubject = { name: subject.name, maxSkippable: skippableBudget[subject.code] };
                        }
                    });

                    if (bottleneckSubject.maxSkippable < 0) {
                        resultHTML += `<p><strong>Warning:</strong> Your planned leaves make your attendance for <strong>${bottleneckSubject.name}</strong> fall below the minimum. You are short by <strong>${Math.abs(bottleneckSubject.maxSkippable)} class(es)</strong>.</p>`;
                    } else {
                        futureWorkingDays.sort((a, b) => a.totalClasses - b.totalClasses);
                        let recommendedLeaveDates = [];
                        for (const day of futureWorkingDays) {
                            let isAffordable = true;
                            for (const subjectCode in day.costs) {
                                if (day.costs[subjectCode] > skippableBudget[subjectCode]) {
                                    isAffordable = false;
                                    break;
                                }
                            }

                            if (isAffordable) {
                                recommendedLeaveDates.push(day.date);
                                for (const subjectCode in day.costs) {
                                    skippableBudget[subjectCode] -= day.costs[subjectCode];
                                }
                            }
                        }
                        recommendedLeaveDates.sort((a, b) => a - b);
                        if (recommendedLeaveDates.length > 0) {
                            resultHTML += `<p>After your planned leave, your leave is limited by <strong>${bottleneckSubject.name}</strong>. You can safely take leave on these <strong>${recommendedLeaveDates.length} day(s)</strong>:</p>
                                        <ul style="list-style-position: inside; padding: 15px 0;">${recommendedLeaveDates.map(d => `<li>${d.toDateString()}</li>`).join('')}</ul>`;
                        } else {
                            resultHTML += `<p>After accounting for your planned leaves, you cannot miss any more full days. Your attendance in <strong>${bottleneckSubject.name}</strong> is the limiting factor.</p>`;
                        }
                    }
                }

                resultHTML += `</div>`;
                container.innerHTML = resultHTML;
            }

            // Calculate max safe leave excluding specified subjects (days without their classes)
            function calculateMaxSafeLeaveExcluding(excludeCodesStr) {
                const excludeCodes = excludeCodesStr.split(',');
                const container = document.getElementById('maxLeaveRecommendation');
                const currentDate = new Date(document.getElementById('currentDate').value + 'T00:00:00');
                const lastDate = new Date(document.getElementById('lastDate').value + 'T00:00:00');
                const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));

                // Get excluded subject names for display
                const excludedSubjectNames = currentAnalysisData
                    .filter(s => excludeCodes.includes(s.code))
                    .map(s => s.name);

                // Get planned leave and compulsory dates
                const leavePeriods = Array.from(document.querySelectorAll('.leave-period-entry')).map(p => ({ start: p.querySelector('.leave-start-date').value, end: p.querySelector('.leave-end-date').value })).filter(d => d.start && d.end);
                const compulsoryPeriods = Array.from(document.querySelectorAll('.compulsory-period-entry')).map(p => ({ start: p.querySelector('.compulsory-start-date').value, end: p.querySelector('.compulsory-end-date').value })).filter(d => d.start && d.end);

                const leaveDateSet = new Set();
                leavePeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { leaveDateSet.add(d.setHours(0, 0, 0, 0)); } });

                const compulsoryDateSet = new Set();
                compulsoryPeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { compulsoryDateSet.add(d.setHours(0, 0, 0, 0)); } });

                // Find days that DON'T have classes for excluded subjects
                const safeDays = [];
                for (let d = new Date(currentDate.getTime() + 86400000); d <= lastDate; d.setDate(d.getDate() + 1)) {
                    const dayTime = new Date(d).setHours(0, 0, 0, 0);
                    if (holidayDates.some(h => h.getTime() === dayTime) || leaveDateSet.has(dayTime) || compulsoryDateSet.has(dayTime)) continue;

                    const dayOfWeek = d.getDay();
                    const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                    // Check if any excluded subject has classes on this day
                    let hasExcludedSubjectClass = false;
                    for (const code of excludeCodes) {
                        const subject = currentAnalysisData.find(s => s.code === code);
                        if (subject && subject.schedule[scheduleIndex] > 0) {
                            hasExcludedSubjectClass = true;
                            break;
                        }
                    }

                    // Only include days where excluded subjects have NO classes
                    if (!hasExcludedSubjectClass) {
                        // Now check if skipping this day is still safe for other subjects
                        let isSafeForOthers = true;
                        let totalClassesOnDay = 0;
                        const costs = {};

                        currentAnalysisData.forEach(subject => {
                            if (!excludeCodes.includes(subject.code)) {
                                const classesOnDay = subject.schedule[scheduleIndex];
                                if (classesOnDay > 0) {
                                    costs[subject.code] = classesOnDay;
                                    totalClassesOnDay += classesOnDay;
                                }
                            }
                        });

                        if (totalClassesOnDay > 0) {
                            safeDays.push({ date: new Date(d), totalClasses: totalClassesOnDay, costs });
                        }
                    }
                }

                // Now calculate which of these safe days you can actually skip
                const skippableBudget = {};
                let bottleneckSubject = { name: '', maxSkippable: Infinity };

                currentAnalysisData.forEach(subject => {
                    if (!excludeCodes.includes(subject.code)) {
                        let leaveCost = 0;
                        leavePeriods.forEach(p => {
                            leaveCost += countClassesInRange(new Date(p.start), new Date(p.end), subject.schedule, holidayDates, subject.code);
                        });

                        const analysis = getSubjectAnalysis(subject.attended, subject.totalHeld, subject.remaining);
                        skippableBudget[subject.code] = analysis.stats.maxSkippable - leaveCost;

                        if (skippableBudget[subject.code] < bottleneckSubject.maxSkippable) {
                            bottleneckSubject = { name: subject.name, maxSkippable: skippableBudget[subject.code] };
                        }
                    }
                });

                let resultHTML = `<div class="subject-card" style="border-left-color: var(--info-color);">
                    <div class="subject-title">🔍 Safe Leave (Excluding Critical Subjects)</div>
                    <p style="margin-bottom: 15px; padding: 10px; background: rgba(231, 76, 60, 0.1); border-radius: 8px;">
                        <strong>⚠️ Important:</strong> These are days where <strong>${excludedSubjectNames.join(', ')}</strong> have NO classes, so taking leave won't affect their attendance.
                    </p>`;

                safeDays.sort((a, b) => a.totalClasses - b.totalClasses);
                let recommendedLeaveDates = [];

                for (const day of safeDays) {
                    let isAffordable = true;
                    for (const subjectCode in day.costs) {
                        if (day.costs[subjectCode] > skippableBudget[subjectCode]) {
                            isAffordable = false;
                            break;
                        }
                    }

                    if (isAffordable) {
                        recommendedLeaveDates.push(day.date);
                        for (const subjectCode in day.costs) {
                            skippableBudget[subjectCode] -= day.costs[subjectCode];
                        }
                    }
                }

                recommendedLeaveDates.sort((a, b) => a - b);

                if (recommendedLeaveDates.length > 0) {
                    resultHTML += `<p>You can safely take leave on these <strong>${recommendedLeaveDates.length} day(s)</strong> without missing <strong>${excludedSubjectNames.join(', ')}</strong> classes:</p>
                        <ul style="list-style-position: inside; padding: 15px 0;">${recommendedLeaveDates.map(d => `<li>${d.toDateString()}</li>`).join('')}</ul>`;
                } else {
                    resultHTML += `<p>Unfortunately, there are no upcoming days where:</p>
                        <ul style="list-style-position: inside; padding: 10px 0;">
                            <li><strong>${excludedSubjectNames.join(', ')}</strong> have no classes, AND</li>
                            <li>You can still afford to skip other subjects' classes</li>
                        </ul>
                        <p>You may need to attend all remaining classes.</p>`;
                }

                resultHTML += `<div style="margin-top: 15px;">
                    <button class="btn secondary-btn" onclick="calculateMaxSafeLeave()" style="padding: 8px 16px;">
                        ↩️ Back to Regular Calculation
                    </button>
                </div></div>`;

                container.innerHTML = resultHTML;
            }

            // Calculate Max Possible Bunk - Skip days at 65% detention threshold + ML suggestions to reach 75%
            function calculateMaxPossibleBunk() {
                calculateLeaveImpact(); // Run impact analysis first
                const container = document.getElementById('maxPossibleBunkResults');
                const currentDate = new Date(document.getElementById('currentDate').value + 'T00:00:00');
                const lastDate = new Date(document.getElementById('lastDate').value + 'T00:00:00');
                const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00'));

                const minCriteria = getMinAttendanceCriteria(); // Usually 0.75 (75%)
                const detentionCriteria = 0.65; // 65% detention threshold

                // Get planned leave and compulsory dates
                const leavePeriods = Array.from(document.querySelectorAll('.leave-period-entry')).map(p => ({ start: p.querySelector('.leave-start-date').value, end: p.querySelector('.leave-end-date').value })).filter(d => d.start && d.end);
                const compulsoryPeriods = Array.from(document.querySelectorAll('.compulsory-period-entry')).map(p => ({ start: p.querySelector('.compulsory-start-date').value, end: p.querySelector('.compulsory-end-date').value })).filter(d => d.start && d.end);

                const leaveDateSet = new Set();
                leavePeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { leaveDateSet.add(d.setHours(0, 0, 0, 0)); } });

                const compulsoryDateSet = new Set();
                compulsoryPeriods.forEach(p => { for (let d = new Date(p.start); d <= new Date(p.end); d.setDate(d.getDate() + 1)) { compulsoryDateSet.add(d.setHours(0, 0, 0, 0)); } });

                // Check if any subject is already below 65% even with all remaining attended
                const unreachable65 = currentAnalysisData.filter(subject => {
                    const finalTotal = subject.totalHeld + subject.remaining;
                    const maxPossible = subject.attended + subject.remaining;
                    const maxPercent = finalTotal > 0 ? (maxPossible / finalTotal) * 100 : 0;
                    return maxPercent < 65;
                });

                if (unreachable65.length > 0) {
                    container.style.display = 'block';
                    const subjectNames = unreachable65.map(s => s.name).join(', ');
                    container.innerHTML = `
                        <div class="subject-card" style="border-left-color: var(--danger-color);">
                            <div class="subject-title">🚫 Detention Risk!</div>
                            <p style="color: var(--danger-color);">
                                <strong>Critical Warning:</strong> The following subject(s) cannot reach 65% even if you attend all remaining classes:<br>
                                <strong>${subjectNames}</strong><br><br>
                                You must focus on these subjects immediately or seek academic help.
                            </p>
                        </div>`;
                    return;
                }

                // Calculate skippable budget at 65% threshold for each subject
                const futureWorkingDays = [];
                for (let d = new Date(currentDate.getTime() + 86400000); d <= lastDate; d.setDate(d.getDate() + 1)) {
                    const dayTime = new Date(d).setHours(0, 0, 0, 0);
                    if (holidayDates.some(h => h.getTime() === dayTime) || leaveDateSet.has(dayTime) || compulsoryDateSet.has(dayTime)) continue;

                    const dayOfWeek = d.getDay();
                    const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                    let totalClassesOnDay = 0;
                    const costs = {};
                    currentAnalysisData.forEach(subject => {
                        const classesOnDay = subject.schedule[scheduleIndex];
                        if (classesOnDay > 0) {
                            costs[subject.code] = classesOnDay;
                            totalClassesOnDay += classesOnDay;
                        }
                    });

                    if (totalClassesOnDay > 0) {
                        futureWorkingDays.push({ date: new Date(d), totalClasses: totalClassesOnDay, costs });
                    }
                }

                // Calculate max skippable at 65% threshold
                const skippableBudget65 = {};
                const skippableBudget75 = {};
                let bottleneckSubject65 = { name: '', maxSkippable: Infinity };

                currentAnalysisData.forEach(subject => {
                    let leaveCost = 0;
                    leavePeriods.forEach(p => {
                        leaveCost += countClassesInRange(new Date(p.start), new Date(p.end), subject.schedule, holidayDates, subject.code);
                    });

                    // Calculate at 65% threshold
                    const finalTotal = subject.totalHeld + subject.remaining;
                    const minRequired65 = Math.ceil(detentionCriteria * finalTotal);
                    const stillNeed65 = Math.max(0, minRequired65 - subject.attended);
                    const maxSkippable65 = Math.max(0, subject.remaining - stillNeed65) - leaveCost;
                    skippableBudget65[subject.code] = maxSkippable65;

                    // Calculate at 75% threshold (for ML suggestions)
                    const minRequired75 = Math.ceil(minCriteria * finalTotal);
                    const stillNeed75 = Math.max(0, minRequired75 - subject.attended);
                    const maxSkippable75 = Math.max(0, subject.remaining - stillNeed75) - leaveCost;
                    skippableBudget75[subject.code] = maxSkippable75;

                    if (maxSkippable65 < bottleneckSubject65.maxSkippable) {
                        bottleneckSubject65 = { name: subject.name, maxSkippable: maxSkippable65 };
                    }
                });

                // Find all bunkable days at 65% threshold
                const tempBudget = { ...skippableBudget65 };
                futureWorkingDays.sort((a, b) => a.totalClasses - b.totalClasses);
                let bunkableDates = [];

                for (const day of futureWorkingDays) {
                    let canBunk = true;
                    for (const subjectCode in day.costs) {
                        if (day.costs[subjectCode] > tempBudget[subjectCode]) {
                            canBunk = false;
                            break;
                        }
                    }

                    if (canBunk) {
                        bunkableDates.push({ date: day.date, costs: day.costs });
                        for (const subjectCode in day.costs) {
                            tempBudget[subjectCode] -= day.costs[subjectCode];
                        }
                    }
                }

                bunkableDates.sort((a, b) => a.date - b.date);

                // Calculate classes needed via ML to go from 65% to 75%
                let mlDatesNeeded = [];
                let totalMLClassesNeeded = 0;

                currentAnalysisData.forEach(subject => {
                    const finalTotal = subject.totalHeld + subject.remaining;
                    const currentPercent = subject.totalHeld > 0 ? (subject.attended / subject.totalHeld) * 100 : 0;

                    // Calculate attendance impact after bunking
                    let bunkClassesForSubject = 0;
                    bunkableDates.forEach(bd => {
                        bunkClassesForSubject += bd.costs[subject.code] || 0;
                    });

                    // Planned leaves impact
                    let plannedLeaveClasses = 0;
                    leavePeriods.forEach(p => {
                        plannedLeaveClasses += countClassesInRange(new Date(p.start), new Date(p.end), subject.schedule, holidayDates, subject.code);
                    });

                    // Final projection: attended + remaining - bunks - planned leaves
                    const projectedAttended = subject.attended + subject.remaining - bunkClassesForSubject - plannedLeaveClasses;
                    const projectedPercent = finalTotal > 0 ? (projectedAttended / finalTotal) * 100 : 0;

                    // If projected < 75%, calculate ML classes needed
                    if (projectedPercent < minCriteria * 100) {
                        const deficit = Math.ceil(minCriteria * finalTotal) - projectedAttended;
                        if (deficit > 0) {
                            mlDatesNeeded.push({ subject: subject.name, code: subject.code, classesNeeded: deficit });
                            totalMLClassesNeeded += deficit;
                        }
                    }
                });

                // Find best ML dates from bunked dates + planned leaves
                let availableMLDates = [];

                // Add bunk dates
                bunkableDates.forEach(bd => {
                    let totalClasses = 0;
                    Object.values(bd.costs).forEach(c => totalClasses += c);
                    availableMLDates.push({ date: bd.date, classes: totalClasses, source: 'bunk' });
                });

                // Add planned leave dates
                leavePeriods.forEach(p => {
                    for (let d = new Date(p.start + 'T00:00:00'); d <= new Date(p.end + 'T00:00:00'); d.setDate(d.getDate() + 1)) {
                        const dayTime = new Date(d).setHours(0, 0, 0, 0);
                        if (holidayDates.some(h => h.getTime() === dayTime)) continue;

                        const dayOfWeek = d.getDay();
                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                        let classesOnDay = 0;
                        currentAnalysisData.forEach(subject => {
                            classesOnDay += subject.schedule[scheduleIndex] || 0;
                        });

                        if (classesOnDay > 0) {
                            availableMLDates.push({ date: new Date(d), classes: classesOnDay, source: 'planned' });
                        }
                    }
                });

                // Sort by classes (descending) - suggest dates with more classes first for ML
                availableMLDates.sort((a, b) => b.classes - a.classes);

                // Select enough ML dates to cover the deficit
                let selectedMLDates = [];
                let coveredClasses = 0;
                for (const mlDate of availableMLDates) {
                    if (coveredClasses >= totalMLClassesNeeded) break;
                    selectedMLDates.push(mlDate);
                    coveredClasses += mlDate.classes;
                }

                // Build results HTML
                container.style.display = 'block';
                let resultHTML = `
                    <div class="subject-card" style="border-left-color: var(--danger-color);">
                        <div class="subject-title">🚫 Max Possible Bunk (Avoid Detention at 65%)</div>
                        <p style="margin-bottom: 15px; padding: 10px; background: rgba(231, 76, 60, 0.1); border-radius: 8px;">
                            <strong>⚠️ Important:</strong> These are dates you can skip without falling below <strong>65%</strong> (detention threshold). Bottleneck: <strong>${bottleneckSubject65.name}</strong>
                        </p>`;

                if (bunkableDates.length > 0) {
                    resultHTML += `
                        <h4 style="margin-top: 15px;">📅 Bunkable Days (${bunkableDates.length} days)</h4>
                        <ul style="list-style-position: inside; padding: 10px 0;">
                            ${bunkableDates.map(d => `<li>${d.date.toDateString()}</li>`).join('')}
                        </ul>`;
                } else {
                    resultHTML += `<p>No additional days can be bunked without going below 65%.</p>`;
                }

                // ML recommendations
                if (mlDatesNeeded.length > 0) {
                    resultHTML += `
                        <div style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border-left: 4px solid var(--info-color);">
                            <h4 style="margin-bottom: 10px;">💊 Medical Certificate Needed to Reach ${(minCriteria * 100).toFixed(0)}%</h4>
                            <p>After bunking all possible days, you'll need ML for these subjects:</p>
                            <ul style="list-style-position: inside; padding: 10px 0;">
                                ${mlDatesNeeded.map(m => `<li><strong>${m.subject}</strong>: ${m.classesNeeded} class(es) needed</li>`).join('')}
                            </ul>
                            <p style="margin-top: 10px;"><strong>Total classes to cover via ML:</strong> ${totalMLClassesNeeded}</p>`;

                    if (selectedMLDates.length > 0 && coveredClasses >= totalMLClassesNeeded) {
                        resultHTML += `
                            <h4 style="margin-top: 15px;">📋 Recommended ML Dates (${selectedMLDates.length} days, ${coveredClasses} classes)</h4>
                            <ul style="list-style-position: inside; padding: 10px 0;">
                                ${selectedMLDates.map(d => `<li>${d.date.toDateString()} (${d.classes} classes) - <em>${d.source === 'bunk' ? 'From Bunk List' : 'From Planned Leave'}</em></li>`).join('')}
                            </ul>`;
                    } else if (selectedMLDates.length > 0) {
                        resultHTML += `
                            <p style="color: var(--warning-color); margin-top: 10px;">
                                ⚠️ Available dates only cover ${coveredClasses} classes. You need ${totalMLClassesNeeded - coveredClasses} more.
                            </p>`;
                    } else {
                        resultHTML += `<p style="margin-top: 10px;">No suitable ML dates available from bunks or planned leaves.</p>`;
                    }

                    resultHTML += `</div>`;
                } else {
                    resultHTML += `
                        <div style="margin-top: 20px; padding: 15px; background: rgba(46, 204, 113, 0.1); border-radius: 8px; border-left: 4px solid var(--success-grad-end);">
                            <h4 style="margin-bottom: 5px;">✅ No Medical Certificate Needed!</h4>
                            <p>Even after bunking all these days, you'll stay above ${(minCriteria * 100).toFixed(0)}% in all subjects.</p>
                        </div>`;
                }

                resultHTML += `</div>`;
                container.innerHTML = resultHTML;
            }

            function findLongWeekends() { const resultsDiv = document.getElementById('longWeekendFinderResult'); const numLeaveDays = parseInt(document.getElementById('numLeaveDays').value); if (!numLeaveDays || numLeaveDays < 1) { resultsDiv.innerHTML = '<p>Please enter a valid number of leave days.</p>'; return; } resultsDiv.innerHTML = `<div class="loading" style="display:block; margin: 10px auto;"><div class="spinner" style="width:30px; height:30px; border-width:3px;"></div><p>Calculating best break...</p></div>`; setTimeout(() => { const currentDate = new Date(document.getElementById('currentDate').value + 'T00:00:00'); const lastDate = new Date(document.getElementById('lastDate').value + 'T00:00:00'); const holidayDates = (selectedClass.holidays || []).map(h => new Date(h + 'T00:00:00')); const totalClassesPerDay = Array(7).fill(0); if (selectedClass && selectedClass.subjects) { selectedClass.subjects.forEach(subject => { subject.schedule.forEach((numClasses, dayIndex) => { totalClassesPerDay[dayIndex] += numClasses; }); }); } const nonWorkingDays = new Set(holidayDates.map(d => d.getTime())); for (let d = new Date(currentDate); d <= lastDate; d.setDate(d.getDate() + 1)) { const dayOfWeek = d.getDay(); const scheduleIndex = (dayOfWeek === 0) ? 6 : dayOfWeek - 1; if (totalClassesPerDay[scheduleIndex] === 0) { nonWorkingDays.add(new Date(d).setHours(0, 0, 0, 0)); } } const timeline = []; for (let d = new Date(currentDate); d <= lastDate; d.setDate(d.getDate() + 1)) { const time = new Date(d).setHours(0, 0, 0, 0); timeline.push({ date: new Date(time), isWorking: !nonWorkingDays.has(time) }); } let bestBreak = { length: 0, startDate: null, endDate: null, leaveDates: [] }; for (let i = 0; i < timeline.length; i++) { let leavesUsed = 0; let currentLength = 0; let leaveDatesInBreak = []; for (let j = i; j < timeline.length; j++) { if (!timeline[j].isWorking) { currentLength++; } else { if (leavesUsed < numLeaveDays) { leavesUsed++; currentLength++; leaveDatesInBreak.push(timeline[j].date); } else { break; } } } if (currentLength > bestBreak.length) { bestBreak = { length: currentLength, startDate: timeline[i].date, endDate: timeline[i + currentLength - 1].date, leaveDates: leaveDatesInBreak }; } } if (bestBreak.length > 0) { let resultHTML = `For the longest break, take <strong>${bestBreak.leaveDates.length} day(s)</strong> of leave on: <ul style="list-style-position: inside; padding: 5px 0;">${bestBreak.leaveDates.map(d => `<li>${d.toDateString()}</li>`).join('')}</ul> This will give you a <strong>${bestBreak.length}-day</strong> break from <strong>${bestBreak.startDate.toDateString()}</strong> to <strong>${bestBreak.endDate.toDateString()}</strong>.`; resultsDiv.innerHTML = resultHTML; } else { resultsDiv.innerHTML = '<p>Could not find an optimal break with the given parameters.</p>'; } }, 50); }

            function checkSkipToday() {
                if (currentAnalysisData.length === 0) {
                    alert("Please calculate attendance first to get current data.");
                    return;
                }

                const today = new Date(document.getElementById('currentDate').value);
                const dayOfWeek = today.getDay();
                const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                const subjectsToday = selectedClass.subjects.filter(s => s.schedule[scheduleIndex] > 0);
                const resultsDiv = document.getElementById('skipTodayResults');

                if (subjectsToday.length === 0) {
                    resultsDiv.innerHTML = `<p style="text-align: center;">No classes scheduled for today. You're free! 🎉</p>`;
                } else {
                    let resultsHTML = '';
                    subjectsToday.forEach(subject => {
                        const data = currentAnalysisData.find(d => d.code === subject.code);
                        if (!data) return;

                        const classesToday = subject.schedule[scheduleIndex];
                        const { stats } = getSubjectAnalysis(data.attended, data.totalHeld, data.remaining);

                        const newFinalAttended = data.attended + data.remaining - classesToday;
                        const finalTotal = data.totalHeld + data.remaining;
                        const newFinalPercent = finalTotal > 0 ? (newFinalAttended / finalTotal) * 100 : 0;

                        const isSafe = newFinalPercent >= (getMinAttendanceCriteria() * 100);
                        resultsHTML += `
                        <div class="dashboard-subject">
                            <span>${subject.name} (${classesToday} hr/s)</span>
                            <span>${stats.projectedMaxPercent.toFixed(1)}% → <strong style="color: ${isSafe ? 'var(--success-grad-start)' : 'var(--danger-color)'}">${newFinalPercent.toFixed(1)}%</strong></span>
                        </div>`;
                    });
                    resultsDiv.innerHTML = resultsHTML;
                }
                openModal('skipTodayModal');
            }

            // Get unique color for a subject based on its index (uses subjectColors from top)
            function getSubjectColor(subjectIndex) {
                return subjectColors[subjectIndex % subjectColors.length];
            }

            // Get short form of subject name
            function getSubjectShortName(name) {
                if (!name) return '';
                const ignoreWords = ['and', 'of', 'the', 'in', 'for', 'to', 'a', 'an'];
                const words = name.split(/\s+/).filter(word => !ignoreWords.includes(word.toLowerCase()));

                if (words.length === 1) {
                    // Single word: return first 3-4 letters
                    return words[0].substring(0, Math.min(4, words[0].length)).toUpperCase();
                } else {
                    // Multiple words: take first letter of each significant word
                    return words.map(word => word[0].toUpperCase()).join('');
                }
            }

            // Get period times from localStorage
            function getPeriodTimes(className) {
                const saved = localStorage.getItem(`period_times_${className}`);
                return saved ? JSON.parse(saved) : null;
            }

            // Save period times to localStorage
            function savePeriodTimes(className, times) {
                localStorage.setItem(`period_times_${className}`, JSON.stringify(times));
            }

            // Get timetable arrangement from localStorage or generate default
            function getTimetableArrangement(className) {
                const saved = localStorage.getItem(`timetable_arrangement_${className}`);
                return saved ? JSON.parse(saved) : null;
            }

            // Save timetable arrangement to localStorage
            function saveTimetableArrangement(className, arrangement) {
                localStorage.setItem(`timetable_arrangement_${className}`, JSON.stringify(arrangement));
            }

            // Open period time configuration modal
            function openPeriodConfigModal() {
                if (!selectedClass) {
                    alert('Please select a class first.');
                    return;
                }

                const className = document.getElementById('classSelector').value;
                const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

                // Calculate max periods
                let maxPeriods = 0;
                dayNames.forEach((day, dayIndex) => {
                    let totalClassesOnDay = 0;
                    selectedClass.subjects.forEach(subject => {
                        totalClassesOnDay += subject.schedule[dayIndex] || 0;
                    });
                    if (totalClassesOnDay > maxPeriods) {
                        maxPeriods = totalClassesOnDay;
                    }
                });

                if (maxPeriods === 0) {
                    alert('No periods to configure. Add subjects with schedules first.');
                    return;
                }

                // Get existing times
                const existingTimes = getPeriodTimes(className) || {};

                // Build modal content
                let modalHTML = `
                    <div class="modal-content">
                        <button class="modal-close" onclick="closeModal('periodConfigModal')">&times;</button>
                        <div class="modal-header">
                            <h2>⏰ Configure Period Times</h2>
                            <p>Set the time slot for each period. Next period must start at or after the previous one ends.</p>
                        </div>
                        <div class="period-config-list">
                `;

                for (let i = 0; i < maxPeriods; i++) {
                    const periodTime = existingTimes[i] || { start: '', end: '' };
                    modalHTML += `
                        <div class="period-config-item">
                            <label><strong>P${i + 1}</strong></label>
                            <input type="time" id="periodStart_${i}" value="${periodTime.start}" 
                                   onchange="validatePeriodTime(${i})" />
                            <span class="time-separator">to</span>
                            <input type="time" id="periodEnd_${i}" value="${periodTime.end}"
                                   onchange="validatePeriodTime(${i})" />
                        </div>
                    `;
                }

                modalHTML += `
                        </div>
                        <div class="form-actions">
                            <button class="btn primary-btn" onclick="savePeriodConfig()">💾 Save Times</button>
                            <button class="btn secondary-btn" onclick="closeModal('periodConfigModal')">Cancel</button>
                        </div>
                    </div>
                `;

                // Create or get the modal
                let modal = document.getElementById('periodConfigModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'periodConfigModal';
                    modal.className = 'modal';
                    document.body.appendChild(modal);
                }
                modal.innerHTML = modalHTML;
                modal.classList.add('active');
            }

            // Validate period times - ensure start < end and sequential ordering
            function validatePeriodTime(periodIndex) {
                const startInput = document.getElementById(`periodStart_${periodIndex}`);
                const endInput = document.getElementById(`periodEnd_${periodIndex}`);

                const startTime = startInput.value;
                const endTime = endInput.value;

                // Check this period's start is before end
                if (startTime && endTime && startTime >= endTime) {
                    alert(`Period ${periodIndex + 1}: End time must be after start time.`);
                    endInput.value = '';
                    return;
                }

                // Check previous period's end time
                if (periodIndex > 0) {
                    const prevEndInput = document.getElementById(`periodEnd_${periodIndex - 1}`);
                    if (prevEndInput && prevEndInput.value && startTime && startTime < prevEndInput.value) {
                        alert(`Period ${periodIndex + 1} cannot start before Period ${periodIndex} ends (${prevEndInput.value}).`);
                        startInput.value = prevEndInput.value;
                    }
                }

                // Update min value for next period
                if (endTime && periodIndex < 20) {
                    const nextStartInput = document.getElementById(`periodStart_${periodIndex + 1}`);
                    if (nextStartInput) {
                        nextStartInput.min = endTime;
                    }
                }
            }

            // Save period configuration
            function savePeriodConfig() {
                const className = document.getElementById('classSelector').value;
                const periodTimes = {};

                let i = 0;
                while (document.getElementById(`periodStart_${i}`)) {
                    const start = document.getElementById(`periodStart_${i}`).value;
                    const end = document.getElementById(`periodEnd_${i}`).value;
                    if (start && end) {
                        periodTimes[i] = { start, end };
                    }
                    i++;
                }

                savePeriodTimes(className, periodTimes);
                closeModal('periodConfigModal');
                generateTimetable(); // Refresh timetable to show times
                alert('✅ Period times saved successfully!');
            }

            // Generate short name / abbreviation from subject name
            function getSubjectShortName(name) {
                if (!name) return '?';
                // Try to create acronym from first letters of each word
                const words = name.split(/\s+/).filter(w => w.length > 0);
                if (words.length > 1) {
                    // Multi-word: take first letter of each significant word
                    return words
                        .filter(w => !['and', 'of', 'the', 'for', 'in', 'to', 'a', 'an'].includes(w.toLowerCase()))
                        .map(w => w[0].toUpperCase())
                        .join('')
                        .substring(0, 5) || name.substring(0, 4).toUpperCase();
                } else {
                    // Single word: take first 4 characters
                    return name.substring(0, 4).toUpperCase();
                }
            }

            // Generate the weekly timetable (ROWS = days, COLUMNS = periods)
            function generateTimetable() {
                const grid = document.getElementById('timetableGrid');
                const section = document.getElementById('timetableSection');

                if (!selectedClass || !selectedClass.subjects || selectedClass.subjects.length === 0) {
                    grid.innerHTML = '<div class="timetable-empty"><p>📭 No subjects configured for this class.</p><p>Add subjects in the class settings.</p></div>';
                    return;
                }

                const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

                // Calculate which days have classes and max periods per day
                let daysWithClasses = [];
                let maxPeriodsPerDay = {};

                dayNames.forEach((day, dayIndex) => {
                    let totalClassesOnDay = 0;
                    selectedClass.subjects.forEach(subject => {
                        totalClassesOnDay += subject.schedule[dayIndex] || 0;
                    });
                    if (totalClassesOnDay > 0) {
                        daysWithClasses.push({ index: dayIndex, name: day });
                        maxPeriodsPerDay[dayIndex] = totalClassesOnDay;
                    }
                });

                if (daysWithClasses.length === 0) {
                    grid.innerHTML = '<div class="timetable-empty"><p>📭 No classes scheduled for any day.</p><p>Update subject schedules in the class settings.</p></div>';
                    return;
                }

                // Build subject color map
                const subjectColorMap = {};
                selectedClass.subjects.forEach((subject, index) => {
                    subjectColorMap[subject.code] = subjectColors[index % subjectColors.length];
                });

                const maxPeriods = Math.max(...Object.values(maxPeriodsPerDay));
                const className = document.getElementById('classSelector').value;

                // Get period times
                const periodTimes = getPeriodTimes(className) || {};

                // Get current day for highlighting (ROWS now)
                const today = new Date();
                const currentDayIndex = today.getDay(); // 0 = Sunday, 1 = Monday, ...
                const adjustedDayIndex = currentDayIndex === 0 ? 6 : currentDayIndex - 1; // Convert to Mon=0, Sun=6

                // Set up grid template: 1 column for day labels + maxPeriods columns
                grid.style.gridTemplateColumns = `50px repeat(${maxPeriods}, 1fr)`;

                // Get saved arrangement or create default
                let arrangement = getTimetableArrangement(className);

                if (!arrangement) {
                    // Create default arrangement from schedule
                    arrangement = {};
                    daysWithClasses.forEach(day => {
                        arrangement[day.index] = [];
                        selectedClass.subjects.forEach(subject => {
                            const classCount = subject.schedule[day.index] || 0;
                            for (let i = 0; i < classCount; i++) {
                                arrangement[day.index].push({
                                    code: subject.code,
                                    name: subject.name,
                                    shortName: subject.shortName || getSubjectShortName(subject.name)
                                });
                            }
                        });
                    });
                    saveTimetableArrangement(className, arrangement);
                }

                // Build HTML
                let html = '';

                // Header row (empty corner + period headers with times)
                html += '<div class="timetable-header"></div>'; // Empty corner
                for (let period = 0; period < maxPeriods; period++) {
                    const timeInfo = periodTimes[period];
                    let timeDisplay = '';
                    if (timeInfo && timeInfo.start && timeInfo.end) {
                        timeDisplay = `<span class="period-time">${timeInfo.start}-${timeInfo.end}</span>`;
                    }
                    html += `<div class="timetable-header">P${period + 1}${timeDisplay}</div>`;
                }

                // Day rows (each row is a day)
                daysWithClasses.forEach(day => {
                    const isCurrentDay = day.index === adjustedDayIndex;
                    const dayArrangement = arrangement[day.index] || [];

                    // Day label
                    html += `<div class="timetable-day-label${isCurrentDay ? ' current-day' : ''}">${day.name}</div>`;

                    // Cells for each period
                    for (let period = 0; period < maxPeriods; period++) {
                        const cellId = `cell_${day.index}_${period}`;
                        const rawSubject = dayArrangement[period];

                        // Normalize subject (Handle both String Codes and Legacy Objects)
                        let subjectAtPeriod = null;
                        if (rawSubject) {
                            if (typeof rawSubject === 'string') {
                                // Format: "SUBCODE"
                                const subObj = selectedClass.subjects.find(s => s.code === rawSubject);
                                if (subObj) {
                                    subjectAtPeriod = {
                                        code: subObj.code,
                                        name: subObj.name,
                                        shortName: subObj.shortName || getSubjectShortName(subObj.name)
                                    };
                                }
                            } else if (typeof rawSubject === 'object' && rawSubject !== null) {
                                // Legacy Format: { code, name, shortName }
                                subjectAtPeriod = rawSubject;
                            }
                        }

                        let cellContent = '';
                        if (subjectAtPeriod) {
                            const subjectColor = subjectColorMap[subjectAtPeriod.code] || '#667eea';

                            // Get attendance status class for current day subjects (only if not a holiday)
                            let statusClass = '';
                            if (isCurrentDay && currentAnalysisData && currentAnalysisData.length > 0) {
                                // Check if today is a holiday
                                const todayStr = formatLocalDate(today);
                                const isHoliday = selectedClass.holidays && selectedClass.holidays.includes(todayStr);

                                if (!isHoliday) {
                                    const subjectData = currentAnalysisData.find(s => s.code === subjectAtPeriod.code);
                                    if (subjectData) {
                                        const { alertClass } = getSubjectAnalysis(subjectData.attended, subjectData.totalHeld, subjectData.remaining);
                                        statusClass = ` status-${alertClass}`;
                                    }
                                }
                            }

                            cellContent = `
                                <div class="subject-chip${statusClass}" 
                                     draggable="true" 
                                     data-code="${subjectAtPeriod.code}"
                                     data-day="${day.index}"
                                     data-period="${period}"
                                     style="background: linear-gradient(135deg, ${subjectColor}, ${adjustColor(subjectColor, -20)})"
                                     title="${subjectAtPeriod.name}">
                                    ${subjectAtPeriod.shortName}
                                </div>
                            `;
                        }

                        html += `
                            <div class="timetable-cell${isCurrentDay ? ' current-day-row' : ''}" 
                                 id="${cellId}"
                                 data-day="${day.index}"
                                 data-period="${period}">
                                ${cellContent}
                            </div>
                        `;
                    }
                });

                grid.innerHTML = html;

                // Add message with configure button
                let existingMessage = section.querySelector('.timetable-message');
                if (existingMessage) {
                    existingMessage.remove();
                }

                // Check if today is a holiday
                const todayStr = formatLocalDate(today);
                const isTodayHoliday = selectedClass.holidays && selectedClass.holidays.includes(todayStr);

                const message = document.createElement('div');
                message.className = 'timetable-message';

                if (isTodayHoliday) {
                    message.innerHTML = '🎉 <strong>Today is a holiday!</strong> Enjoy your day off. <button class="config-btn" onclick="openPeriodConfigModal()">⏰ Configure Period Times</button>';
                    message.style.background = 'rgba(40, 167, 69, 0.15)';
                    message.style.borderLeft = '4px solid #28a745';
                } else {
                    message.innerHTML = '💡 Drag subjects to rearrange. <button class="config-btn" onclick="openPeriodConfigModal()">⏰ Configure Period Times</button>';
                }
                section.appendChild(message);

                // Initialize drag and drop
                initTimetableDragDrop();
            }

            // Adjust color brightness (for gradient effect)
            function adjustColor(hex, amount) {
                let color = hex.replace('#', '');
                if (color.length === 3) {
                    color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
                }
                const num = parseInt(color, 16);
                let r = Math.min(255, Math.max(0, (num >> 16) + amount));
                let g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
                let b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
                return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
            }

            // Initialize drag and drop for timetable
            function initTimetableDragDrop() {
                const chips = document.querySelectorAll('.subject-chip');
                const cells = document.querySelectorAll('.timetable-cell');

                chips.forEach(chip => {
                    chip.addEventListener('dragstart', handleDragStart);
                    chip.addEventListener('dragend', handleDragEnd);
                });

                cells.forEach(cell => {
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);
                });
            }

            let draggedChip = null;

            function handleDragStart(e) {
                draggedChip = e.target;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    code: e.target.dataset.code,
                    day: parseInt(e.target.dataset.day),
                    period: parseInt(e.target.dataset.period)
                }));
            }

            function handleDragEnd(e) {
                e.target.classList.remove('dragging');
                document.querySelectorAll('.timetable-cell').forEach(cell => {
                    cell.classList.remove('drag-over');
                });
                draggedChip = null;
            }

            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                // Only allow drop within same day
                if (draggedChip) {
                    const sourceDay = parseInt(draggedChip.dataset.day);
                    const targetDay = parseInt(e.currentTarget.dataset.day);
                    if (sourceDay === targetDay) {
                        e.currentTarget.classList.add('drag-over');
                    }
                }
            }

            function handleDragLeave(e) {
                e.currentTarget.classList.remove('drag-over');
            }

            function handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');

                if (!draggedChip) return;

                const sourceData = JSON.parse(e.dataTransfer.getData('text/plain'));
                const targetDay = parseInt(e.currentTarget.dataset.day);
                const targetPeriod = parseInt(e.currentTarget.dataset.period);

                // Only allow drops within the same day
                if (sourceData.day !== targetDay) {
                    return;
                }

                const className = document.getElementById('classSelector').value;
                let arrangement = getTimetableArrangement(className);

                if (!arrangement || !arrangement[targetDay]) return;

                // Swap the periods
                const dayArrangement = arrangement[targetDay];
                const sourceItem = dayArrangement[sourceData.period];
                const targetItem = dayArrangement[targetPeriod] || null;

                dayArrangement[sourceData.period] = targetItem;
                dayArrangement[targetPeriod] = sourceItem;

                // Clean up null entries
                arrangement[targetDay] = dayArrangement;

                saveTimetableArrangement(className, arrangement);
                generateTimetable(); // Re-render timetable

                // Refresh period-wise attendance modal if open (syncs with new timetable order)
                const periodModal = document.getElementById('periodAttendanceModal');
                if (periodModal && periodModal.classList.contains('active')) {
                    openPeriodAttendanceModal(); // Re-render with new sequence
                }
            }

            // Keep updateDailyDashboard for backward compatibility but redirect to timetable
            function updateDailyDashboard() {
                generateTimetable();
            }

            function openDailyLog() {
                if (!selectedClass) {
                    alert("Please select a class first.");
                    return;
                }
                const logDateInput = document.getElementById('logDate');
                const today = formatLocalDate(new Date());

                // Set max date to today to prevent future selection
                logDateInput.max = today;
                logDateInput.readOnly = true; // User requested read-only for "Mark Today"

                // Always set to today's date for "Mark Today's Attendance"
                logDateInput.value = today;
                populateDailyLog();
                document.getElementById('dailyLogModal').classList.add('active');
            }

            function cleanupHolidayLogs() {
                // Get all attendance logs
                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                let cleanedCount = 0;

                // Check each date in logs
                Object.keys(logs).forEach(dateStr => {
                    const check = isHolidayOrNoClass(dateStr);

                    // If this date is a holiday, remove all attendance markings
                    if (check.isHoliday) {
                        delete logs[dateStr];
                        cleanedCount++;
                    }
                });

                // Save cleaned logs back
                if (cleanedCount > 0) {
                    localStorage.setItem('attendance_logs', JSON.stringify(logs));
                    console.log(`Cleaned ${cleanedCount} holiday log(s) from imported data`);
                }

                return cleanedCount;
            }

            function saveDailyLog() {
                const dateStr = document.getElementById('logDate').value;
                if (!dateStr) return;

                // Check if date is a holiday - if so, prevent saving
                const check = isHolidayOrNoClass(dateStr);
                if (check.isHoliday) {
                    alert(`Cannot save attendance for ${dateStr}.\n\nThis date is a ${check.reason}.\nAll subjects should remain as "Default" (no attendance marked).`);
                    return; // Don't save anything
                }

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                if (!logs[dateStr]) {
                    logs[dateStr] = {};
                }

                document.querySelectorAll('#dailyLogSubjects select').forEach(select => {
                    const code = select.dataset.code;
                    const status = select.value;
                    if (status === 'Default') {
                        delete logs[dateStr][code];
                    } else {
                        logs[dateStr][code] = status;
                    }
                });

                if (Object.keys(logs[dateStr]).length === 0) {
                    delete logs[dateStr];
                }

                localStorage.setItem('attendance_logs', JSON.stringify(logs));
                // Track last app interaction time for sync comparison
                localStorage.setItem('lastAppInteraction', new Date().toISOString());
                alert('Log saved! Your future calculations will now reflect these changes.');
                closeModal('dailyLogModal');

                // Immediate update without refresh
                if (selectedClass.portalSetup && selectedClass.portalSetup.active) {
                    renderPortalDashboard(); // Refresh notification
                    calculateFromPortal();
                } else {
                    triggerRecalculation();
                }

                // Refresh period-wise view if it's open (keep both views in sync)
                const periodModal = document.getElementById('periodAttendanceModal');
                if (periodModal && periodModal.classList.contains('active')) {
                    openPeriodAttendanceModal();
                }
            }

            function openBackupModal() {
                document.getElementById('backupOptionsModal').classList.add('active');
            }

            function getBackupDataObj() {
                // Gather ALL localStorage data
                const classesData = localStorage.getItem('attendanceClasses_v2') ?
                    JSON.parse(localStorage.getItem('attendanceClasses_v2')) : {};

                // Collect per-class notification settings
                const notificationSettings = {};
                for (const className in classesData) {
                    const key = `notificationSettings_${className}`;
                    const settings = localStorage.getItem(key);
                    if (settings) {
                        notificationSettings[className] = JSON.parse(settings);
                    }
                }

                // Collect timetable arrangements for each class
                const timetableArrangements = {};
                for (const className in classesData) {
                    const key = `timetable_arrangement_${className}`;
                    const arrangement = localStorage.getItem(key);
                    if (arrangement) {
                        timetableArrangements[className] = JSON.parse(arrangement);
                    }
                }

                // Collect period times for each class
                const periodTimes = {};
                for (const className in classesData) {
                    const key = `periodTimes_${className}`;
                    const times = localStorage.getItem(key);
                    if (times) {
                        periodTimes[className] = JSON.parse(times);
                    }
                }

                // Collect custom schedules for each class
                const customSchedules = {};
                for (const className in classesData) {
                    const key = `custom_schedules_${className}`;
                    const schedules = localStorage.getItem(key);
                    if (schedules) {
                        customSchedules[className] = JSON.parse(schedules);
                    }
                }

                return {
                    // Metadata
                    metadata: {
                        version: '3.1',
                        appVersion: '1.0.0', // App version for restore compatibility check
                        timestamp: new Date().toISOString(),
                        appName: 'Bunk it - Smart Attendance Manager',
                        backupType: 'complete'
                    },

                    // Classes data
                    classes: classesData,

                    // Portal/Daily logs
                    attendanceLogs: localStorage.getItem('attendance_logs') ?
                        JSON.parse(localStorage.getItem('attendance_logs')) : {},

                    // Per-class notification settings
                    notificationSettings: notificationSettings,

                    // Timetable arrangements
                    timetableArrangements: timetableArrangements,

                    // Period times
                    periodTimes: periodTimes,

                    // Custom schedules (for specific dates)
                    customSchedules: customSchedules,

                    // Theme preference
                    theme: localStorage.getItem('theme') || 'light',

                    // Last opened class
                    lastOpenedClass: localStorage.getItem('lastOpenedClass') || '',

                    // Default view preference (cards/subjects)
                    defaultView: localStorage.getItem('defaultView') || 'cards',

                    // Statistics
                    stats: {
                        totalClasses: Object.keys(classesData).length,
                        totalLogs: Object.keys(
                            localStorage.getItem('attendance_logs') ?
                                JSON.parse(localStorage.getItem('attendance_logs')) : {}
                        ).length,
                        notificationSettingsCount: Object.keys(notificationSettings).length,
                        timetableArrangementsCount: Object.keys(timetableArrangements).length,
                        customSchedulesCount: Object.keys(customSchedules).length
                    }
                };
            }

            function performBackupDownload() {
                try {
                    const backupData = getBackupDataObj();
                    const jsonString = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    // Create download with timestamp
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const filename = `bunkit_complete_backup_${timestamp}.json`;

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    closeModal('backupOptionsModal');
                    // Success notification
                    alert(`✅ Complete backup created successfully!\n\nFile: ${filename}\n\nIncludes:\n• ${backupData.stats.totalClasses} class(es)\n• ${backupData.stats.totalLogs} attendance log(s)\n• ${backupData.stats.notificationSettingsCount} notification setting(s)\n• ${backupData.stats.timetableArrangementsCount} timetable arrangement(s)\n• Theme preferences`);

                } catch (error) {
                    console.error('Backup failed:', error);
                    alert(`❌ Backup failed: ${error.message}\n\nPlease try again or contact support.`);
                }
            }

            async function performBackupShare() {
                try {
                    const backupData = getBackupDataObj();
                    const jsonString = JSON.stringify(backupData, null, 2);
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const filename = `bunkit_complete_backup_${timestamp}.json`;

                    const file = new File([jsonString], filename, { type: 'application/json' });

                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            files: [file],
                            title: 'Bunk it Backup',
                            text: 'Here is my Bunk it attendance backup file.'
                        });
                        closeModal('backupOptionsModal');
                    } else {
                        throw new Error("Sharing files is not supported on this browser/device.");
                    }
                } catch (error) {
                    console.error('Share failed:', error);
                    alert(`❌ Share failed: ${error.message}\n\nTry downloading the file instead.`);
                }
            }

            async function performBackupCopy() {
                try {
                    const backupData = getBackupDataObj();
                    const jsonString = JSON.stringify(backupData, null, 2);
                    await navigator.clipboard.writeText(jsonString);
                    alert("✅ Backup JSON copied to clipboard!");
                    closeModal('backupOptionsModal');
                } catch (error) {
                    console.error('Copy failed:', error);
                    alert(`❌ Copy failed: ${error.message}`);
                }
            }

            function openRestoreModal() {
                document.getElementById('restoreOptionsModal').classList.add('active');
            }

            function switchRestoreTab(tab) {
                document.getElementById('restoreFileTab').style.display = tab === 'file' ? 'block' : 'none';
                document.getElementById('restorePasteTab').style.display = tab === 'paste' ? 'block' : 'none';
                document.getElementById('restoreFileTabBtn').classList.toggle('active', tab === 'file');
                document.getElementById('restorePasteTabBtn').classList.toggle('active', tab === 'paste');
            }

            function triggerRestore() {
                // Kept for backward compatibility if needed, but now we use openRestoreModal
                openRestoreModal();
            }

            function restoreData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const jsonString = e.target.result;
                        processRestoreData(jsonString);
                        closeModal('restoreOptionsModal'); // Close modal on success
                    } catch (error) {
                        console.error('Restore failed:', error);
                        alert(`❌ Error restoring data: ${error.message}\n\nPlease ensure you're using a valid backup file.`);
                    }
                };
                reader.readAsText(file);
                event.target.value = null;
            }

            function performRestorePaste() {
                const jsonString = document.getElementById('restoreJsonPaste').value;
                if (!jsonString.trim()) {
                    alert("Please paste the backup JSON code first.");
                    return;
                }
                try {
                    processRestoreData(jsonString);
                    closeModal('restoreOptionsModal');
                    document.getElementById('restoreJsonPaste').value = ''; // Clear after success
                } catch (error) {
                    console.error('Restore failed:', error);
                    alert(`❌ Error restoring data: ${error.message}\n\nPlease check if the JSON is valid.`);
                }
            }

            function processRestoreData(jsonString) {
                const backupData = JSON.parse(jsonString);

                // Validate backup data structure
                if (!backupData || typeof backupData !== 'object') {
                    throw new Error("Invalid backup format.");
                }

                // Check if it's a complete backup or old format
                const isCompleteBackup = backupData.metadata && backupData.metadata.backupType === 'complete';

                // Version check - warn if backup is from a newer version
                const currentAppVersion = '1.0.0'; // Update this when releasing new versions
                if (backupData.metadata?.appVersion && backupData.metadata.appVersion > currentAppVersion) {
                    if (!confirm(`⚠️ VERSION MISMATCH WARNING\\n\\nThis backup was created with a newer version of the app (${backupData.metadata.appVersion}).\\n\\nYour current version is ${currentAppVersion}.\\n\\nRestoring may cause unexpected behavior.\\n\\nProceed anyway?`)) {
                        return;
                    }
                }

                if (isCompleteBackup) {
                    // New comprehensive backup format
                    if (!confirm(`⚠️ RESTORE COMPLETE BACKUP?\\n\\nThis will replace ALL current data:\\n\\n• Classes: ${backupData.stats?.totalClasses || 0}\\n• Logs: ${backupData.stats?.totalLogs || 0}\\n• Notification Settings: ${backupData.stats?.notificationSettingsCount || 0}\\n• Timetable Arrangements: ${backupData.stats?.timetableArrangementsCount || 0}\\n• Theme preferences\\n\\nBackup created: ${new Date(backupData.metadata.timestamp).toLocaleString()}\\n\\nContinue?`)) {
                        return;
                    }

                    // Restore all data
                    if (backupData.classes) {
                        localStorage.setItem('attendanceClasses_v2', JSON.stringify(backupData.classes));
                    }

                    if (backupData.attendanceLogs) {
                        localStorage.setItem('attendance_logs', JSON.stringify(backupData.attendanceLogs));
                        // Clean up any holiday logs that may have been imported
                        cleanupHolidayLogs();
                    }

                    if (backupData.theme) {
                        localStorage.setItem('theme', backupData.theme);
                        // Apply theme
                        if (backupData.theme === 'dark') {
                            document.body.classList.add('dark-mode');
                            document.getElementById('theme-checkbox').checked = true;
                        } else {
                            document.body.classList.remove('dark-mode');
                            document.getElementById('theme-checkbox').checked = false;
                        }
                    }

                    // Restore per-class notification settings
                    if (backupData.notificationSettings) {
                        for (const className in backupData.notificationSettings) {
                            if (backupData.notificationSettings.hasOwnProperty(className)) {
                                localStorage.setItem(
                                    `notificationSettings_${className}`,
                                    JSON.stringify(backupData.notificationSettings[className])
                                );
                            }
                        }
                    }

                    // Restore timetable arrangements
                    if (backupData.timetableArrangements) {
                        for (const className in backupData.timetableArrangements) {
                            if (backupData.timetableArrangements.hasOwnProperty(className)) {
                                localStorage.setItem(
                                    `timetable_arrangement_${className}`,
                                    JSON.stringify(backupData.timetableArrangements[className])
                                );
                            }
                        }
                    }

                    // Restore period times
                    if (backupData.periodTimes) {
                        for (const className in backupData.periodTimes) {
                            if (backupData.periodTimes.hasOwnProperty(className)) {
                                localStorage.setItem(
                                    `periodTimes_${className}`,
                                    JSON.stringify(backupData.periodTimes[className])
                                );
                            }
                        }
                    }

                    // Restore custom schedules
                    if (backupData.customSchedules) {
                        for (const className in backupData.customSchedules) {
                            if (backupData.customSchedules.hasOwnProperty(className)) {
                                localStorage.setItem(
                                    `custom_schedules_${className}`,
                                    JSON.stringify(backupData.customSchedules[className])
                                );
                            }
                        }
                    }

                    // Restore last opened class
                    if (backupData.lastOpenedClass) {
                        localStorage.setItem('lastOpenedClass', backupData.lastOpenedClass);
                    }

                    // Restore default view preference
                    if (backupData.defaultView) {
                        localStorage.setItem('defaultView', backupData.defaultView);
                    }

                    // Reload application state
                    loadFromStorage();
                    populateClassSelector();
                    onClassChange();

                    alert("✅ Complete data restore successful!\\n\\nAll your classes, logs, notification settings, timetable arrangements, and preferences have been restored.");

                } else {
                    // Old backup format (classes only)
                    if (!confirm("This appears to be an older backup (classes only). Restore?")) {
                        return;
                    }

                    if (typeof backupData !== 'object' || Array.isArray(backupData) || backupData === null) {
                        throw new Error("Invalid JSON format. Expected a class object.");
                    }

                    localStorage.setItem('attendanceClasses_v2', JSON.stringify(backupData));
                    loadFromStorage();
                    populateClassSelector();
                    onClassChange();
                    alert("✅ Data restored successfully!");
                }
            }

            function updateHistoryDropdown() {
                const dropdown = document.getElementById('historyDropdown');
                if (!dropdown) return; // Element doesn't exist yet
                dropdown.innerHTML = '';
                if (calculationHistory.length === 0) {
                    dropdown.innerHTML = '<a href="#" style="color: var(--medium-text);">No history yet.</a>';
                    return;
                }
                calculationHistory.forEach((item, index) => {
                    const date = new Date(item.timestamp);
                    const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    dropdown.innerHTML += `<a href="#" onclick="restoreFromHistory(${index}); closeNav();">Calculation from ${dateString}</a>`;
                });
                dropdown.innerHTML += `<a href="#" onclick="downloadHistoryPDF(); closeNav();"><strong>Download Full History (PDF)</strong></a>`;
            }

            function restoreFromHistory(index) {
                const snapshot = calculationHistory[index];
                if (!snapshot) return;

                document.getElementById('minAttendanceInput').value = snapshot.settings.minAttendance;
                document.getElementById('overallCriteriaCheckbox').checked = snapshot.settings.overallMode;
                document.getElementById('currentDate').value = snapshot.settings.currentDate;
                document.getElementById('lastDate').value = snapshot.settings.lastDate;

                calculateAttendance(snapshot.results);
                alert(`Restored state from ${new Date(snapshot.timestamp).toLocaleString()}`);
            }

            /**
             * Generates and downloads a PDF report of the current attendance analysis.
             * Uses jsPDF for direct, text-based PDF creation with professional design.
             */
            function downloadCurrentReportPDF() {
                // 1. Pre-computation and validation
                if (!window.jspdf) {
                    alert("PDF generation library is not loaded. Please refresh the page.");
                    return;
                }
                if (currentAnalysisData.length === 0) {
                    alert("No report to download. Please calculate attendance first.");
                    return;
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // 2. Document constants and state variables
                const pageWidth = doc.internal.pageSize.width;
                const pageHeight = doc.internal.pageSize.height;
                const leftMargin = 15;
                const rightMargin = pageWidth - 15;
                let yPos = 15;

                // Color palette
                const colors = {
                    primary: [102, 126, 234],      // #667eea
                    secondary: [118, 75, 162],     // #764BA2
                    success: [34, 197, 94],        // #22c55e
                    warning: [245, 158, 11],       // #f59e0b
                    danger: [239, 68, 68],         // #ef4444
                    text: [55, 65, 81],            // #374151
                    lightText: [107, 114, 128],    // #6b7280
                    white: [255, 255, 255]
                };

                // Helper function for colored rectangles
                const drawRect = (x, y, w, h, color, fill = true) => {
                    doc.setFillColor(...color);
                    doc.setDrawColor(...color);
                    if (fill) doc.rect(x, y, w, h, 'F');
                    else doc.rect(x, y, w, h, 'S');
                };

                // Helper for adding text with page break handling
                const addText = (text, size, options = {}) => {
                    const { bold = false, color = colors.text, x = leftMargin, align = 'left' } = options;
                    if (yPos > pageHeight - 25) {
                        doc.addPage();
                        yPos = 20;
                    }
                    doc.setFontSize(size);
                    doc.setFont(undefined, bold ? 'bold' : 'normal');
                    doc.setTextColor(...color);
                    doc.text(text, x, yPos, { align });
                    yPos += (size * 0.45);
                };

                // 3. Professional Header with gradient-like effect
                drawRect(0, 0, pageWidth, 50, colors.primary);
                drawRect(0, 43, pageWidth, 7, colors.secondary);

                // Branding: Bunk it Logo Text
                doc.setTextColor(...colors.white);
                doc.setFontSize(28);
                doc.setFont(undefined, 'bold');
                doc.text('Bunk it', leftMargin, 20);

                doc.setFontSize(14);
                doc.setFont(undefined, 'normal');
                doc.text('Smart Attendance Manager', leftMargin, 28);

                // Report Title
                doc.setFontSize(22);
                doc.setFont(undefined, 'bold');
                doc.text('Attendance Report', rightMargin, 22, { align: 'right' });

                doc.setFontSize(11);
                doc.setFont(undefined, 'normal');
                const className = document.getElementById('classSelector').value || "N/A";
                doc.text(`Class: ${className}`, rightMargin, 32, { align: 'right' });

                const currentDate = new Date().toLocaleDateString('en-IN', {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
                });
                doc.text(currentDate, rightMargin, 38, { align: 'right' });

                yPos = 65;

                // 4. Settings box
                drawRect(leftMargin, yPos - 5, pageWidth - 30, 18, [243, 244, 246]);
                doc.setTextColor(...colors.text);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                const minAtt = document.getElementById('minAttendanceInput').value;
                const mode = isOverallMode() ? 'Overall Mode' : 'Per-Subject Mode';
                doc.text(`Settings: Minimum ${minAtt}% Attendance Required  |  Analysis Mode: ${mode}`, leftMargin + 5, yPos + 4);
                yPos += 22;

                // 5. Document Body
                if (isOverallMode()) {
                    // Calculate overall stats
                    const overall = currentAnalysisData.reduce((acc, subject) => {
                        acc.attended += subject.attended;
                        acc.totalHeld += subject.totalHeld;
                        acc.remaining += subject.remaining;
                        return acc;
                    }, { attended: 0, totalHeld: 0, remaining: 0 });

                    const { stats } = getSubjectAnalysis(overall.attended, overall.totalHeld, overall.remaining);

                    // Overall percentage card
                    const percentColor = stats.currentPercent >= 75 ? colors.success :
                        stats.currentPercent >= 65 ? colors.warning : colors.danger;

                    drawRect(leftMargin, yPos, pageWidth - 30, 35, percentColor);
                    doc.setTextColor(...colors.white);
                    doc.setFontSize(36);
                    doc.setFont(undefined, 'bold');
                    doc.text(`${stats.currentPercent.toFixed(1)}%`, pageWidth / 2, yPos + 22, { align: 'center' });
                    doc.setFontSize(12);
                    doc.text('Current Attendance', pageWidth / 2, yPos + 30, { align: 'center' });
                    yPos += 45;

                    // Stats grid
                    const stats_items = [
                        { label: 'Classes Attended', value: stats.attended },
                        { label: 'Total Classes', value: stats.totalHeld },
                        { label: 'Remaining', value: stats.remaining },
                        { label: 'Must Attend', value: stats.stillNeed },
                        { label: 'Can Skip', value: stats.maxSkippable },
                        { label: 'Projected Max', value: `${stats.projectedMaxPercent.toFixed(1)}%` }
                    ];

                    const cardWidth = (pageWidth - 40) / 3;
                    stats_items.forEach((item, i) => {
                        const row = Math.floor(i / 3);
                        const col = i % 3;
                        const x = leftMargin + (col * (cardWidth + 5));
                        const y = yPos + (row * 25);

                        drawRect(x, y - 5, cardWidth - 2, 22, [249, 250, 251]);
                        doc.setTextColor(...colors.text);
                        doc.setFontSize(8);
                        doc.text(item.label, x + 3, y + 3);
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text(String(item.value), x + 3, y + 13);
                        doc.setFont(undefined, 'normal');
                    });
                    yPos += 60;

                } else {
                    // Per-Subject Mode
                    addText('Subject-wise Analysis', 16, { bold: true, color: colors.primary });
                    yPos += 5;

                    currentAnalysisData.forEach((subject, index) => {
                        if (yPos > pageHeight - 50) {
                            doc.addPage();
                            yPos = 20;
                        }

                        const { alertMessage, stats } = getSubjectAnalysis(subject.attended, subject.totalHeld, subject.remaining);
                        const percentColor = stats.currentPercent >= 75 ? colors.success :
                            stats.currentPercent >= 65 ? colors.warning : colors.danger;

                        // Subject card
                        drawRect(leftMargin, yPos - 3, pageWidth - 30, 28, [249, 250, 251]);

                        // Percentage badge
                        drawRect(rightMargin - 35, yPos, 30, 12, percentColor);
                        doc.setTextColor(...colors.white);
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.text(`${stats.currentPercent.toFixed(1)}%`, rightMargin - 20, yPos + 8, { align: 'center' });

                        // Subject name
                        doc.setTextColor(...colors.text);
                        doc.setFontSize(12);
                        doc.text(`${index + 1}. ${subject.name}`, leftMargin + 3, yPos + 5);

                        // Subject code
                        doc.setTextColor(...colors.lightText);
                        doc.setFontSize(9);
                        doc.text(`Code: ${subject.code}`, leftMargin + 3, yPos + 12);

                        // Stats
                        doc.setTextColor(...colors.text);
                        doc.setFontSize(9);
                        doc.text(`Attended: ${stats.attended}/${stats.totalHeld} | Remaining: ${stats.remaining} | Must Attend: ${stats.stillNeed} | Can Skip: ${stats.maxSkippable}`, leftMargin + 3, yPos + 20);

                        yPos += 33;
                    });
                }

                // 6. Footer
                yPos = pageHeight - 15;
                doc.setDrawColor(...colors.lightText);
                doc.line(leftMargin, yPos - 5, rightMargin, yPos - 5);
                doc.setTextColor(...colors.lightText);
                doc.setFontSize(8);
                doc.text('Generated by Bunk it - Smart Attendance Manager | bunkitapp.in', pageWidth / 2, yPos, { align: 'center', url: 'https://bunkitapp.in' });

                // 7. Save the document
                const filename = `Attendance_Report_${className.replace(/\\s/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
                doc.save(filename);

                // Celebrate!
                celebrateAchievement('default');
            }

            /**
             * Generates and downloads a multi-page PDF report of all calculations in the history.
             * Uses jsPDF for robust, text-based PDF creation.
             */
            function downloadHistoryPDF() {
                // 1. Validation
                if (!window.jspdf) {
                    alert("PDF generation library is not loaded. Please refresh the page.");
                    return;
                }
                if (calculationHistory.length === 0) {
                    alert("No history available to download.");
                    return;
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // 2. Document constants and state variables
                const pageHeight = doc.internal.pageSize.height;
                const pageWidth = doc.internal.pageSize.width;
                const leftMargin = 15;
                let yPos = 20;
                let pageNum = 1;

                // Helper to add footer with page number
                const addFooter = () => {
                    doc.setFontSize(8);
                    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
                };

                // 3. Document Header
                doc.setFontSize(20);
                doc.setFont(undefined, 'bold');
                doc.text('Full Calculation History', leftMargin, yPos);
                yPos += 15;

                // 4. Loop through history (oldest to newest)
                calculationHistory.slice().reverse().forEach((snapshot, index) => {
                    const requiredSpace = (snapshot.results.length * 10) + 25; // Estimate space needed
                    if (yPos + requiredSpace > pageHeight - 20) {
                        addFooter();
                        doc.addPage();
                        yPos = 20;
                        pageNum++;
                    }

                    const timestamp = new Date(snapshot.timestamp);
                    const settings = snapshot.settings;
                    const mode = settings.overallMode ? 'Overall' : 'Per-Subject';

                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.text(`Report #${index + 1} - ${timestamp.toLocaleString()}`, leftMargin, yPos);
                    yPos += 7;

                    doc.setFontSize(9);
                    doc.setFont(undefined, 'normal');
                    doc.text(`Settings: Min ${settings.minAttendance}% (${mode}) | Current Date: ${settings.currentDate}`, leftMargin, yPos);
                    yPos += 8;

                    // Print each subject's data from the snapshot
                    snapshot.results.forEach(subject => {
                        const minCriteria = (parseFloat(settings.minAttendance) || 75) / 100;
                        const { stats } = getSubjectAnalysis(subject.attended, subject.totalHeld, subject.remaining, minCriteria);

                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.text(`${subject.name} (${subject.code}):`, leftMargin + 2, yPos);
                        yPos += 5;

                        doc.setFontSize(9);
                        doc.setFont(undefined, 'normal');
                        let statsLine = `Current: ${stats.currentPercent.toFixed(1)}% (${subject.attended}/${subject.totalHeld}) | `
                            + `Max Projected: ${stats.projectedMaxPercent.toFixed(1)}% | `
                            + `Can Skip: ${stats.maxSkippable}`;
                        doc.text(statsLine, leftMargin + 4, yPos);
                        yPos += 6;
                    });

                    yPos += 5; // Extra space between history entries
                    doc.line(leftMargin, yPos, pageWidth - leftMargin, yPos); // Separator line
                    yPos += 10;
                });

                // 5. Add footer to the last page and save
                addFooter();
                const filename = `Full_History_Report_${new Date().toISOString().split('T')[0]}.pdf`;
                doc.save(filename);
            }

            function deleteSelectedClass() {
                const selector = document.getElementById('classSelector');
                const className = selector.value;
                if (!className) {
                    alert('Please select a class to delete.');
                    return;
                }

                if (confirm(`Are you sure you want to permanently delete the class "${className}"? This cannot be undone.`)) {
                    delete classes[className];
                    // Clean up associated localStorage keys
                    localStorage.removeItem(`notificationSettings_${className}`);
                    localStorage.removeItem(`timetable_arrangement_${className}`);
                    localStorage.removeItem(`periodTimes_${className}`);
                    localStorage.removeItem(`custom_schedules_${className}`);
                    saveToStorage();
                    populateClassSelector();

                    if (selector.options.length > 1) {
                        selector.selectedIndex = 1;
                    } else {
                        selector.selectedIndex = 0;
                    }
                    handleDropdownChange();
                    alert(`Class "${className}" has been deleted.`);
                }
            }

            function restoreDefaultClass() {
                const className = Object.keys(defaultExampleClass)[0];
                if (classes[className]) {
                    alert(`The example class "${className}" already exists.`);
                    return;
                }
                classes[className] = defaultExampleClass[className];
                saveToStorage();
                populateClassSelector();
                document.getElementById('classSelector').value = className;
                handleDropdownChange();
                showToast('Default example class restored.', 'info');
            }

            // --- PORTAL FEATURE IMPLEMENTATION ---

            function openPortalSetup() {
                if (!selectedClass) { showToast("Please select a class first.", 'error'); return; }

                const modal = document.getElementById('portalSetupModal');
                let html = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('portalSetupModal')">&times;</button>
                    <div class="modal-header"><h2>🎓 Student Portal Setup</h2><p>Set your current attendance baseline to start tracking daily.</p></div>
                    
                    <div class="form-group">
                        <label>Portal Start Date (Baseline Date):</label>
                        <input type="date" id="portalStartDate" value="${new Date().toISOString().split('T')[0]}">
                        <p style="font-size: 0.8rem; color: var(--medium-text);">Enter attendance data as of this date.</p>
                    </div>

                    <div class="form-group">
                        <label>Semester Start Date:</label>
                        <input type="date" id="semesterStartDate" value="${selectedClass.portalSetup?.semesterStartDate || ''}">
                        <p style="font-size: 0.8rem; color: var(--medium-text);">Used for Medical Certificate calculations.</p>
                    </div>

`;

                selectedClass.subjects.forEach(subject => {
                    // Try to pre-fill from current analysis if available, or existing portal data
                    let currentAttended = 0;
                    let currentTotal = 0;

                    if (selectedClass.portalSetup && selectedClass.portalSetup.baselineData && selectedClass.portalSetup.baselineData[subject.code]) {
                        currentAttended = selectedClass.portalSetup.baselineData[subject.code].attended;
                        currentTotal = selectedClass.portalSetup.baselineData[subject.code].total;
                    } else if (currentAnalysisData.length > 0) {
                        const analysis = currentAnalysisData.find(s => s.code === subject.code);
                        if (analysis) {
                            currentAttended = analysis.attended;
                            currentTotal = analysis.totalHeld;
                        }
                    }

                    html += `
                    <div class="subject-input">
                        <h4>${subject.name} (${subject.code})</h4>
                        <div class="manual-input-fields">
                            <div class="input-group">
                                <label style="font-size: 0.8rem;">Total Held</label>
                                <input type="number" id="portal_total_${subject.code}" value="${currentTotal}" min="0">
                            </div>
                            <div class="input-group">
                                <label style="font-size: 0.8rem;">Attended</label>
                                <input type="number" id="portal_attended_${subject.code}" value="${currentAttended}" min="0">
                            </div>
                        </div>
                    </div>`;
                });

                html += `
                    <div class="form-actions">
                        <button class="btn primary-btn" onclick="savePortalSetup()">🚀 Start Portal Mode</button>
                        ${selectedClass.portalSetup ? '<button class="btn danger-btn" onclick="disablePortalMode()">❌ Disable Portal</button>' : ''}
                    </div>
                </div>`;

                modal.innerHTML = html;
                openModal('portalSetupModal');
            }

            function savePortalSetup() {
                const startDateInput = document.getElementById('portalStartDate');
                const semesterStartInput = document.getElementById('semesterStartDate');

                if (!startDateInput || !semesterStartInput) return;

                const startDate = startDateInput.value;
                const semesterStartDate = semesterStartInput.value;

                if (!startDate) { showToast("Please select a start date.", 'error'); return; }
                if (!semesterStartDate) { showToast("Please select a Semester Start Date to enable Portal Mode.", 'error'); return; }

                // Date ordering validation
                if (new Date(semesterStartDate) > new Date(startDate)) {
                    showToast("Semester Start Date cannot be after the Baseline Date.", 'error');
                    return;
                }
                if (selectedClass.lastDate && new Date(startDate) > new Date(selectedClass.lastDate)) {
                    showToast("Baseline Date cannot be after the Class End Date.", 'error');
                    return;
                }

                const baselineData = {};
                let isValid = true;

                selectedClass.subjects.forEach(subject => {
                    const totalInput = document.getElementById(`portal_total_${subject.code}`);
                    const attendedInput = document.getElementById(`portal_attended_${subject.code}`);

                    if (!totalInput || !attendedInput) return;

                    const total = parseInt(totalInput.value) || 0;
                    const attended = parseInt(attendedInput.value) || 0;

                    if (attended > total) {
                        showToast(`Invalid data for ${subject.name}: Attended cannot be greater than Total.`, 'error');
                        isValid = false;
                        return;
                    }
                    baselineData[subject.code] = { total, attended };
                });

                if (!isValid) return;

                selectedClass.portalSetup = {
                    baselineDate: startDate,
                    semesterStartDate: semesterStartDate,
                    baselineData: baselineData,
                    active: true
                };

                classes[selectedClass.name || document.getElementById('classSelector').value] = selectedClass; // Ensure update in main object
                saveToStorage();
                closeModal('portalSetupModal');
                initPortal();
                showToast("Portal Mode Activated! You can now track attendance daily.", 'success');

                // Auto-enable notifications if not already enabled
                autoEnableNotificationsForPortal();

                // Show period-wise view menu item
                if (typeof updatePeriodViewMenuVisibility === 'function') {
                    updatePeriodViewMenuVisibility();
                }
            }

            function disablePortalMode() {
                if (confirm("Are you sure you want to disable Portal Mode? Your baseline data will be removed, but daily logs will remain.")) {
                    delete selectedClass.portalSetup;
                    classes[selectedClass.name || document.getElementById('classSelector').value] = selectedClass;
                    saveToStorage();
                    closeModal('portalSetupModal');
                    initPortal();

                    // Hide period-wise view menu item when portal mode is disabled
                    if (typeof updatePeriodViewMenuVisibility === 'function') {
                        updatePeriodViewMenuVisibility();
                    }
                }
            }

            function initPortal() {
                const portalSection = document.getElementById('portalDashboardSection');
                const uploadSection = document.getElementById('uploadSection');
                const manualInput = document.getElementById('manualInput'); // Hide manual input if portal is active
                const jsonInput = document.getElementById('jsonInput');
                const portalBtn = document.getElementById('portalBtn');

                if (selectedClass && selectedClass.portalSetup && selectedClass.portalSetup.active) {
                    // VALIDATION: Ensure Semester Start Date exists
                    if (!selectedClass.portalSetup.semesterStartDate) {
                        showToast("Action Required: Set Semester Start Date.", 'warning');
                        openPortalSetup();
                        return;
                    }

                    // Portal Active State
                    portalSection.style.display = 'block';
                    uploadSection.style.display = 'none'; // Hide upload in portal mode
                    if (manualInput) manualInput.style.display = 'none';
                    if (jsonInput) jsonInput.style.display = 'none';
                    portalBtn.textContent = "Portal Settings";
                    portalBtn.className = "btn secondary-btn"; // Change style to indicate active/settings

                    renderPortalDashboard();
                    calculateFromPortal(); // Auto-calculate on load
                } else {
                    // Standard Mode
                    portalSection.style.display = 'none';
                    uploadSection.style.display = 'block';
                    if (portalBtn) {
                        portalBtn.textContent = "Student Portal";
                        portalBtn.className = "btn info-btn";
                    }
                }
            }

            function checkIncompleteLogs() {
                if (!selectedClass || !selectedClass.portalSetup || !selectedClass.portalSetup.semesterStartDate) {
                    return { hasGap: false, allComplete: false };
                }

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                const today = new Date();
                const semStart = parseLocalDate(selectedClass.portalSetup.semesterStartDate);

                let lastLogDate = null;

                // Find the most recent log date
                Object.keys(logs).forEach(dateStr => {
                    const logDate = parseLocalDate(dateStr);
                    if (logDate >= semStart && logDate <= today) {
                        if (!lastLogDate || logDate > parseLocalDate(lastLogDate)) {
                            lastLogDate = dateStr;
                        }
                    }
                });

                if (!lastLogDate) {
                    // No logs at all
                    return {
                        hasGap: true,
                        lastLogDate: formatLocalDate(semStart),
                        daysBehind: Math.floor((today - semStart) / (1000 * 60 * 60 * 24)),
                        allComplete: false
                    };
                }

                const lastLog = new Date(lastLogDate);
                const todayStr = formatLocalDate(today);

                // If last log is today, all complete
                if (lastLogDate === todayStr) {
                    return { hasGap: false, allComplete: true };
                }

                // Calculate days behind (excluding today)
                const daysBehind = Math.floor((today - lastLog) / (1000 * 60 * 60 * 24)) - 1;

                if (daysBehind > 0) {
                    return {
                        hasGap: true,
                        lastLogDate,
                        daysBehind,
                        allComplete: false
                    };
                }

                return { hasGap: false, allComplete: true };
            }

            function openStandardCalculation() {
                // Hide portal dashboard
                const portalDashboard = document.getElementById('portalDashboardSection');
                if (portalDashboard) {
                    portalDashboard.style.display = 'none';
                }

                // Show the upload section with calculation options
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) {
                    uploadSection.style.display = 'block';
                }

                // Reset date inputs to current date (today)
                const currentDateInput = document.getElementById('currentDate');
                if (currentDateInput) {
                    currentDateInput.value = new Date().toISOString().split('T')[0];
                }

                // Hide any existing results or input sections
                const manualInput = document.getElementById('manualInput');
                if (manualInput) manualInput.style.display = 'none';

                const jsonInput = document.getElementById('jsonInput');
                if (jsonInput) jsonInput.style.display = 'none';

                const resultsSection = document.getElementById('resultsSection');
                if (resultsSection) resultsSection.style.display = 'none';

                // Hide leave planner and other sections
                const leavePlannerSection = document.getElementById('leavePlannerSection');
                if (leavePlannerSection) leavePlannerSection.style.display = 'none';

                const maxLeaveSection = document.getElementById('maxLeaveRecommendation');
                if (maxLeaveSection) maxLeaveSection.style.display = 'none';

                const medicalLeaveSection = document.getElementById('medicalLeaveSection');
                if (medicalLeaveSection) medicalLeaveSection.style.display = 'none';

                const leaveRecommendationContainer = document.getElementById('leaveRecommendationContainer');
                if (leaveRecommendationContainer) leaveRecommendationContainer.style.display = 'none';

                // Add standard mode toggle (Back button)
                addStandardModeToggle();

                // Scroll to upload section
                setTimeout(() => {
                    if (uploadSection) {
                        uploadSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);

                // Store that we came from portal mode
                sessionStorage.setItem('calculatingFromPortal', 'true');
            }

            function promptPortalUpdate() {
                // Check if we came from portal mode AND are still in the update section
                // We check if portalDashboardSection is HIDDEN to confirm we are in update mode
                const portalDashboard = document.getElementById('portalDashboardSection');
                const isUpdateSection = portalDashboard && portalDashboard.style.display === 'none';

                if (sessionStorage.getItem('calculatingFromPortal') !== 'true' || !isUpdateSection) {
                    return; // Not from portal or not in update section (we are on main dashboard), no update needed
                }

                // Clear the flag
                sessionStorage.removeItem('calculatingFromPortal');

                // Show confirmation dialog with data summary
                if (!currentAnalysisData || currentAnalysisData.length === 0) {
                    alert('No attendance data available to update portal.');
                    return;
                }

                // Validate all subjects are present
                const expectedSubjects = selectedClass.subjects.map(s => s.code);
                const inputSubjects = currentAnalysisData.map(s => s.code);
                const missingSubjects = expectedSubjects.filter(code => !inputSubjects.includes(code));

                if (missingSubjects.length > 0) {
                    // Find subject names for missing codes
                    const missingNames = missingSubjects.map(code => {
                        const subject = selectedClass.subjects.find(s => s.code === code);
                        return subject ? subject.name : code;
                    });

                    alert(
                        `❌ Incomplete Attendance Data\n\n` +
                        `All subjects must be included to update portal.\n\n` +
                        `Missing Subjects (${missingSubjects.length}):\n` +
                        missingNames.map(name => `• ${name}`).join('\n') +
                        `\n\nPlease input attendance for all ${expectedSubjects.length} subjects.`
                    );
                    return; // Don't proceed with update
                }

                // Build summary of input data
                let summary = '📊 Update Portal with This Data?\n\n';
                summary += `Date: ${new Date().toLocaleDateString()}\n\n`;
                summary += 'Attendance Summary:\n';
                currentAnalysisData.forEach(subject => {
                    const percentage = subject.totalHeld > 0
                        ? ((subject.attended / subject.totalHeld) * 100).toFixed(1)
                        : 100;
                    summary += `• ${subject.name}: ${subject.attended}/${subject.totalHeld} (${percentage}%)\n`;
                });
                summary += '\n✓ Update portal baseline to today\n';
                summary += '✓ Create log entry for today\n';
                summary += '\nConfirm to update portal?';

                const confirmed = confirm(summary);

                if (confirmed) {
                    updatePortalWithCurrentData();
                } else {
                    // User cancelled - show options
                    const retry = confirm(
                        '❌ Update Cancelled\n\n' +
                        'What would you like to do?\n\n' +
                        'OK: Stay here to re-input data\n' +
                        'Cancel: Return to Portal without updating'
                    );

                    if (!retry) {
                        // Return to portal without updating
                        switchBackToPortal();
                    }
                    // If retry (OK), stay on current page for re-input
                }
            }

            function updatePortalWithCurrentData() {
                if (!selectedClass || !currentAnalysisData || currentAnalysisData.length === 0) {
                    alert('No attendance data available to update portal.');
                    return;
                }

                // Create baseline data from current input
                const updatedBaseline = {};
                currentAnalysisData.forEach(subject => {
                    updatedBaseline[subject.code] = {
                        attended: subject.attended,
                        total: subject.totalHeld
                    };
                });

                // Update portal setup - UPDATE BASELINE DATA, KEEP BASELINE DATE
                if (!selectedClass.portalSetup) {
                    selectedClass.portalSetup = { active: true };
                }

                // Keep the original baseline date
                const originalBaselineDate = selectedClass.portalSetup.baselineDate || new Date().toISOString().split('T')[0];

                // Update only the baseline data
                selectedClass.portalSetup.baselineDate = originalBaselineDate;
                selectedClass.portalSetup.baselineData = updatedBaseline;

                // Save class data
                const classes = JSON.parse(localStorage.getItem('attendanceClasses_v2')) || {};
                classes[selectedClass.name] = selectedClass;
                localStorage.setItem('attendanceClasses_v2', JSON.stringify(classes));

                alert(
                    `✅ Portal Baseline Updated!\n\n` +
                    `Baseline Date: ${originalBaselineDate}\n` +
                    `Baseline Data Updated: ${Object.keys(updatedBaseline).length} subjects\n\n` +
                    `Note: The portal will use the maximum of baseline data and your logged attendance (from baseline date to semester start) as per portal logic.`
                );

                // Switch back to portal mode
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) uploadSection.style.display = 'none';

                const manualInput = document.getElementById('manualInput');
                if (manualInput) manualInput.style.display = 'none';

                const jsonInput = document.getElementById('jsonInput');
                if (jsonInput) jsonInput.style.display = 'none';

                const portalDashboard = document.getElementById('portalDashboardSection');
                if (portalDashboard) portalDashboard.style.display = 'block';

                removeStandardModeToggle();
                renderPortalDashboard();
                calculateFromPortal(); // Recalculate - will use max(baseline, logs) logic
            }

            function updatePortalFromCalculation() {
                if (!selectedClass || !currentAnalysisData || currentAnalysisData.length === 0) {
                    alert('No calculation data available to update portal.');
                    return;
                }

                // Get the calculation date (today by default, or from user input if available)
                const calculationDate = new Date().toISOString().split('T')[0];

                // Create baseline data from current calculation
                const newBaseline = {};
                currentAnalysisData.forEach(subject => {
                    newBaseline[subject.code] = {
                        attended: subject.attended,
                        total: subject.totalHeld
                    };
                });

                // Update portal setup
                if (!selectedClass.portalSetup) {
                    selectedClass.portalSetup = { active: true };
                }

                selectedClass.portalSetup.baselineDate = calculationDate;
                selectedClass.portalSetup.baselineData = newBaseline;

                // Save to localStorage
                const classes = JSON.parse(localStorage.getItem('attendanceClasses_v2')) || {};
                classes[selectedClass.name] = selectedClass;
                localStorage.setItem('attendanceClasses_v2', JSON.stringify(classes));

                alert(
                    `✅ Portal Updated Successfully!\n\n` +
                    `Baseline Date: ${calculationDate}\n` +
                    `Subjects Updated: ${Object.keys(newBaseline).length}\n\n` +
                    `You can now continue tracking attendance in Portal Mode from this baseline.`
                );

                // Switch back to portal mode
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) uploadSection.style.display = 'none';

                const portalDashboard = document.getElementById('portalDashboardSection');
                if (portalDashboard) portalDashboard.style.display = 'block';

                renderPortalDashboard();
                calculateFromPortal(); // Recalculate with new baseline
            }

            function renderPortalDashboard() {
                const container = document.getElementById('portalDashboardSection');
                const today = formatLocalDate(new Date());

                // Check for incomplete logs
                const incompleteLogs = checkIncompleteLogs();

                let notificationHTML = '';
                if (incompleteLogs.hasGap) {
                    const daysCount = incompleteLogs.daysBehind;
                    const lastLogFormatted = new Date(incompleteLogs.lastLogDate).toLocaleDateString();

                    notificationHTML = `
                    <div style="background: rgba(255, 193, 7, 0.15); border-left: 4px solid var(--warning-color); padding: 15px; margin-bottom: 15px; border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                            <div>
                                <p style="margin: 0; font-weight: bold; color: var(--warning-color);">⚠️ Incomplete Logs Detected</p>
                                <p style="margin: 5px 0 0 0; font-size: 0.9rem;">Last log: <strong>${lastLogFormatted}</strong> - ${daysCount} day(s) behind</p>
                            </div>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <button class="btn secondary-btn" onclick="openHistoryEditor()" style="font-size: 0.85rem; padding: 6px 12px;">📅 Complete Logs</button>
                                <button class="btn primary-btn" onclick="openStandardCalculation()" style="font-size: 0.85rem; padding: 6px 12px;">📊 Update Attendance</button>
                            </div>
                        </div>
                    </div>
                `;
                } else if (incompleteLogs.allComplete) {
                    notificationHTML = `
                    <div style="background: rgba(46, 204, 113, 0.15); border-left: 4px solid var(--success-grad-start); padding: 12px; margin-bottom: 15px; border-radius: 8px;">
                        <p style="margin: 0; color: var(--success-grad-start); font-weight: bold;">✅ All logs up to date!</p>
                    </div>
                `;
                }

                container.innerHTML = `
                <div style="background: var(--card-bg); padding: 15px; margin-bottom: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <h4 style="margin: 0 0 5px 0;">Calculation Mode</h4>
                            <p style="margin: 0; font-size: 0.85rem; color: var(--medium-text);">Switch between Portal tracking and Standard calculation</p>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn primary-btn" onclick="initPortal()" style="font-size: 0.9rem; opacity: 1; pointer-events: none;">
                                🎓 Portal Mode
                            </button>
                            <button class="btn secondary-btn" onclick="switchToStandardMode()" style="font-size: 0.9rem;">
                                🧮 Standard Calculation
                            </button>
                        </div>
                    </div>
                </div>
                ${notificationHTML}
                <div class="settings-section" style="border-left: 5px solid var(--primary-grad-start);">
                    <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:15px;">
                        <div>
                            <h3>🎓 Student Portal Active</h3>
                            <p>Tracking since: <strong>${selectedClass.portalSetup.baselineDate}</strong></p>
                        </div>
                        <div style="display:flex; gap:10px; flex-wrap: wrap;">
                            <button class="btn primary-btn" onclick="openDailyLog()">📅 Mark Today's Attendance</button>
                            <button class="btn secondary-btn" onclick="openHistoryEditor()">📜 Edit History</button>
                        </div>
                    </div>
                </div>
            `;
            }

            function switchToStandardMode() {
                // Hide portal dashboard
                const portalDashboard = document.getElementById('portalDashboardSection');
                if (portalDashboard) {
                    portalDashboard.style.display = 'none';
                }

                // Show upload section for standard calculation
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) {
                    uploadSection.style.display = 'block';
                }

                // Reset date inputs to current date (not last logged date)
                const currentDateInput = document.getElementById('currentDate');
                if (currentDateInput) {
                    currentDateInput.value = formatLocalDate(new Date());
                }

                // Hide existing results - only show after calculation
                const resultsSection = document.getElementById('resultsSection');
                if (resultsSection) {
                    resultsSection.style.display = 'none';
                }

                // Hide leave planner and other sections
                const leavePlannerSection = document.getElementById('leavePlannerSection');
                if (leavePlannerSection) leavePlannerSection.style.display = 'none';

                const maxLeaveSection = document.getElementById('maxLeaveRecommendation');
                if (maxLeaveSection) maxLeaveSection.style.display = 'none';

                const leaveRecommendationContainer = document.getElementById('leaveRecommendationContainer');
                if (leaveRecommendationContainer) leaveRecommendationContainer.style.display = 'none';

                // Hide medical certificate section
                const medicalLeaveSection = document.getElementById('medicalLeaveSection');
                if (medicalLeaveSection) medicalLeaveSection.style.display = 'none';

                // Add mode toggle to standard mode
                addStandardModeToggle();

                // Scroll to upload section
                setTimeout(() => {
                    if (uploadSection) {
                        uploadSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }

            function addStandardModeToggle() {
                // Check if toggle already exists
                if (document.getElementById('standardModeToggle')) {
                    return;
                }

                // Create mode toggle element with back button
                const toggleHTML = `
                <div id="standardModeToggle" style="background: var(--card-bg); padding: 15px; margin-bottom: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <h4 style="margin: 0 0 5px 0;">Update Attendance</h4>
                            <p style="margin: 0; font-size: 0.85rem; color: var(--medium-text);">Use OCR, Manual Entry, or JSON to update today's attendance</p>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn secondary-btn" onclick="switchBackToPortal()" style="font-size: 0.9rem;">
                                ↩️ Back to Portal
                            </button>
                        </div>
                    </div>
                </div>
            `;

                // Insert before upload section
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) {
                    uploadSection.insertAdjacentHTML('beforebegin', toggleHTML);
                }
            }



            function removeStandardModeToggle() {
                const toggle = document.getElementById('standardModeToggle');
                if (toggle) {
                    toggle.remove();
                }
            }

            function switchBackToPortal() {
                // Clear the portal calculation flag so no prompt appears
                sessionStorage.removeItem('calculatingFromPortal');

                // Remove the standard mode toggle
                removeStandardModeToggle();

                // Hide upload section
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) {
                    uploadSection.style.display = 'none';
                }

                // Hide manual input and JSON input sections if they're visible
                const manualInput = document.getElementById('manualInput');
                if (manualInput) {
                    manualInput.style.display = 'none';
                }

                const jsonInput = document.getElementById('jsonInput');
                if (jsonInput) {
                    jsonInput.style.display = 'none';
                }

                // Show portal dashboard
                const portalDashboard = document.getElementById('portalDashboardSection');
                if (portalDashboard) {
                    portalDashboard.style.display = 'block';
                }

                // Refresh portal dashboard and recalculate based on portal data
                renderPortalDashboard();
                calculateFromPortal();

                // Scroll to portal dashboard
                setTimeout(() => {
                    if (portalDashboard) {
                        portalDashboard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }

            function calculateFromPortal() {
                if (!selectedClass || !selectedClass.portalSetup) return;

                const baseline = selectedClass.portalSetup.baselineData;
                const baselineDate = parseLocalDate(selectedClass.portalSetup.baselineDate);
                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};

                // Check for incomplete logs to determine effective "current date"
                const logStatus = checkIncompleteLogs();
                let effectiveCurrentDate;

                if (logStatus.hasGap && logStatus.lastLogDate) {
                    // Use last log date as "current date" for incomplete logs
                    effectiveCurrentDate = logStatus.lastLogDate;
                } else {
                    // Use today if logs are complete
                    effectiveCurrentDate = formatLocalDate(new Date());
                }

                // Update the date inputs to reflect the effective current date
                document.getElementById('currentDate').value = effectiveCurrentDate;

                // Keep lastDate from portal setup or use default
                if (selectedClass.portalSetup.lastWorkingDay) {
                    document.getElementById('lastDate').value = selectedClass.portalSetup.lastWorkingDay;
                }

                // 1. Calculate sums of logs BEFORE or ON baseline date
                const pastLogStats = {};

                Object.keys(logs).forEach(dateStr => {
                    const logDate = parseLocalDate(dateStr);
                    // Check if log is before or on baseline date
                    if (logDate <= baselineDate) {
                        const dayLog = logs[dateStr];
                        Object.keys(dayLog).forEach(key => {
                            // Extract base subject code from Subject_pX or use as-is (legacy)
                            // e.g., "MATH_p1" -> "MATH", "ENG" -> "ENG"
                            const code = key.split('_p')[0];

                            if (!pastLogStats[code]) pastLogStats[code] = { attended: 0, total: 0 };

                            const status = dayLog[key];
                            if (status === 'Attended' || status === 'Duty Leave (OD)' || status === 'Medical Leave (ML)') {
                                pastLogStats[code].attended++;
                                pastLogStats[code].total++;
                            } else if (status === 'Skipped') {
                                pastLogStats[code].total++;
                            }
                            // Cancelled adds nothing
                        });
                    }
                });

                // 2. Determine Effective Baseline
                // "add logic that when people edit history and mark their attendance before the baseline date... 
                // it should not add that attended and held data... until sum attend and held classes of before base line date is more than the attend and held date on the date of baseline date"

                const effectiveStats = {};
                selectedClass.subjects.forEach(subject => {
                    const code = subject.code;
                    const base = baseline[code] || { attended: 0, total: 0 };
                    const past = pastLogStats[code] || { attended: 0, total: 0 };

                    // Logic: If user has logged enough classes to match the baseline total, 
                    // trust the LOGS (Fact) over the BASELINE (Estimate).
                    // This fixes the case where user backfills logs (e.g. 45/100) but baseline was higher (50/100).
                    if (past.total >= base.total && base.total > 0) {
                        effectiveStats[code] = {
                            attended: past.attended,
                            total: past.total
                        };
                    } else {
                        // Otherwise, assume logs are incomplete and trust baseline (or simple max if no baseline)
                        effectiveStats[code] = {
                            attended: Math.max(base.attended, past.attended),
                            total: Math.max(base.total, past.total)
                        };
                    }
                });

                // 3. Add logs AFTER baseline date (but only up to effective current date)
                const effectiveDateObj = parseLocalDate(effectiveCurrentDate);

                Object.keys(logs).forEach(dateStr => {
                    const logDate = parseLocalDate(dateStr);
                    if (logDate > baselineDate && logDate <= effectiveDateObj) {
                        const dayLog = logs[dateStr];
                        Object.keys(dayLog).forEach(code => {
                            if (effectiveStats[code]) {
                                const status = dayLog[code];
                                if (status === 'Attended' || status === 'Duty Leave (OD)' || status === 'Medical Leave (ML)') {
                                    effectiveStats[code].attended++;
                                    effectiveStats[code].total++;
                                } else if (status === 'Skipped') {
                                    effectiveStats[code].total++;
                                }
                            }
                        });
                    }
                });

                // Prepare data for existing calculation engine
                const attendanceData = [];
                selectedClass.subjects.forEach(subject => {
                    const stats = effectiveStats[subject.code] || { attended: 0, total: 0 };
                    attendanceData.push({
                        ...subject,
                        attended: stats.attended,
                        totalHeld: stats.total
                    });
                });

                calculateAttendance(attendanceData);
            }

            // --- MEDICAL LEAVE & HISTORY ENHANCEMENTS ---

            function isHolidayOrNoClass(dateStr) {
                // Check holidays
                if ((selectedClass.holidays || []).includes(dateStr)) return { isHoliday: true, reason: 'Holiday' };

                // Check schedule
                const date = new Date(dateStr);
                const dayOfWeek = date.getDay();
                const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                const hasClasses = selectedClass.subjects.some(s => s.schedule[scheduleIndex] > 0);

                if (!hasClasses) return { isHoliday: true, reason: 'No Classes Scheduled (e.g., Sunday)' };

                return { isHoliday: false };
            }

            function populateDailyLog() {
                const subjectList = document.getElementById('dailyLogSubjects');
                subjectList.innerHTML = '';
                const saveBtn = document.querySelector('#dailyLogModal .primary-btn');

                const dateStr = document.getElementById('logDate').value;
                const check = isHolidayOrNoClass(dateStr);

                if (check.isHoliday) {
                    subjectList.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--medium-text);">
                        <div style="font-size: 3rem; margin-bottom: 10px;">🏖️</div>
                        <h3>No Classes Today</h3>
                        <p>You cannot mark attendance for <strong>${dateStr}</strong> because it is a <strong>${check.reason}</strong>.</p>
                    </div>`;
                    if (saveBtn) saveBtn.style.display = 'none';
                    return;
                }

                if (saveBtn) saveBtn.style.display = 'block';

                // Add Bulk Actions
                const bulkDiv = document.createElement('div');
                bulkDiv.className = 'bulk-actions';
                bulkDiv.style.marginBottom = '15px';
                bulkDiv.style.display = 'flex';
                bulkDiv.style.gap = '5px';
                bulkDiv.style.flexWrap = 'wrap';
                bulkDiv.innerHTML = `
                <span style="width:100%; font-size:0.8rem; color:var(--medium-text); margin-bottom:5px;">Bulk Actions:</span>
                <button class="btn secondary-btn" onclick="applyBulkAction('Attended')" style="padding: 5px 10px; font-size: 0.8rem;">All Present</button>
                <button class="btn secondary-btn" onclick="applyBulkAction('Skipped')" style="padding: 5px 10px; font-size: 0.8rem;">All Absent</button>
                <button class="btn secondary-btn" onclick="applyBulkAction('Medical Leave (ML)')" style="padding: 5px 10px; font-size: 0.8rem;">All ML</button>
                <button class="btn secondary-btn" onclick="applyBulkAction('Duty Leave (OD)')" style="padding: 5px 10px; font-size: 0.8rem;">All OD</button>
                <button class="btn info-btn" onclick="openCustomScheduleModal('${dateStr}')" style="padding: 5px 10px; font-size: 0.8rem; margin-left: auto;" title="Set a different schedule for this date if timetable was different in the past">📅 Custom Schedule</button>
            `;
                subjectList.appendChild(bulkDiv);

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                const dayLog = logs[dateStr] || {};

                // Check for custom schedule for this date
                const customSchedule = getCustomScheduleForDate(dateStr);

                selectedClass.subjects.forEach(subject => {
                    // Check if this subject should be shown and how many times
                    let periodCount = 0;

                    if (customSchedule) {
                        // Custom schedule exists
                        if (Array.isArray(customSchedule)) {
                            // Old format: array of codes (count occurrences)
                            periodCount = customSchedule.filter(code => code === subject.code).length;
                            // Fallback for old format which might have only 1 entry for duplicate subject
                            if (periodCount === 0 && customSchedule.includes(subject.code)) periodCount = 1;
                        } else {
                            // New format: object {code: count}
                            periodCount = customSchedule[subject.code] || 0;
                        }
                    } else {
                        // Use default schedule
                        const date = new Date(dateStr);
                        const dayOfWeek = date.getDay();
                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                        periodCount = subject.schedule[scheduleIndex] || 0;
                    }

                    if (periodCount === 0) return;

                    // Render a dropdown for EACH period of this subject
                    for (let i = 1; i <= periodCount; i++) {
                        // Key for storage: SUBJECT_p1, SUBJECT_p2, etc.
                        // BACKWARD COMPATIBILITY: If _p1 doesn't exist, check base code (legacy data)
                        // If it's the first period, we might have stored it as just "SUBJECT"
                        const periodKey = `${subject.code}_p${i}`;
                        let currentStatus = dayLog[periodKey];

                        if (!currentStatus && i === 1) {
                            // Fallback to legacy key 'SUBJECT' if 'SUBJECT_p1' is missing
                            currentStatus = dayLog[subject.code];
                        }

                        // Default fallback
                        currentStatus = currentStatus || 'Default';

                        const div = document.createElement('div');
                        div.className = 'subject-log-entry';
                        const labelSuffix = periodCount > 1 ? ` (Period ${i})` : '';

                        div.innerHTML = `
                        <label>${subject.name} ${labelSuffix}</label>
                        <select data-code="${periodKey}" data-previous-value="${currentStatus}" onchange="handleStatusChange(this)">
                            <option value="Default" ${currentStatus === 'Default' ? 'selected' : ''}>Default (Held)</option>
                            <option value="Attended" ${currentStatus === 'Attended' ? 'selected' : ''}>Attended</option>
                            <option value="Skipped" ${currentStatus === 'Skipped' ? 'selected' : ''}>Skipped</option>
                            <option value="Cancelled" ${currentStatus === 'Cancelled' ? 'selected' : ''}>Cancelled</option>
                            <option value="Duty Leave (OD)" ${currentStatus === 'Duty Leave (OD)' ? 'selected' : ''}>Duty Leave (OD)</option>
                            <option value="Medical Leave (ML)" ${currentStatus === 'Medical Leave (ML)' ? 'selected' : ''}>Medical Leave (ML)</option>
                        </select>
                    `;
                        subjectList.appendChild(div);
                    }
                });
            }

            // Custom Schedule Functions - for logging past dates with different timetables
            function getCustomScheduleForDate(dateStr) {
                const className = document.getElementById('classSelector')?.value;
                if (!className) return null;
                const customSchedules = JSON.parse(localStorage.getItem(`custom_schedules_${className}`) || '{}');
                return customSchedules[dateStr] || null;
            }

            function openCustomScheduleModal(dateStr) {
                const modal = document.getElementById('customScheduleModal');
                const customSchedule = getCustomScheduleForDate(dateStr);
                const maxPeriods = getMaxPeriods(); // Get max periods from timetable

                // Build subject period inputs
                let subjectHTML = '';
                if (selectedClass?.subjects) {
                    selectedClass.subjects.forEach(subject => {
                        // Get current count from custom schedule (now stored as object {code: count})
                        let currentCount = 0;
                        if (customSchedule && typeof customSchedule === 'object' && !Array.isArray(customSchedule)) {
                            currentCount = customSchedule[subject.code] || 0;
                        } else if (Array.isArray(customSchedule)) {
                            // Backward compatibility: old format was array of codes
                            currentCount = customSchedule.includes(subject.code) ? 1 : 0;
                        }

                        subjectHTML += `
                            <div style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: var(--light-bg);">
                                <label style="flex: 1; font-weight: 500;">${subject.name} <span style="color: var(--medium-text); font-weight: 400;">(${subject.code})</span></label>
                                <input type="number" id="customSched_${subject.code}" value="${currentCount}" min="0" max="${maxPeriods}" 
                                       onchange="updateCustomScheduleTotal()" oninput="updateCustomScheduleTotal()"
                                       style="width: 60px; padding: 8px; text-align: center; border-radius: 6px; border: 1px solid var(--border-color); font-size: 1rem;">
                            </div>`;
                    });
                }

                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px;">
                        <button class="modal-close" onclick="closeModal('customScheduleModal')">&times;</button>
                        <div class="modal-header">
                            <h2>📅 Custom Schedule</h2>
                            <p>Set how many classes each subject had on <strong>${dateStr}</strong></p>
                        </div>
                        <div class="modal-body" style="max-height: 350px; overflow-y: auto;">
                            <div style="background: var(--card-bg); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--border-color);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 0.9rem; color: var(--medium-text);">Total Periods:</span>
                                    <span id="customScheduleTotal" style="font-size: 1.2rem; font-weight: 600;">0 / ${maxPeriods}</span>
                                </div>
                                <div id="customScheduleWarning" style="color: var(--danger-color); font-size: 0.85rem; margin-top: 5px; display: none;">
                                    ⚠️ Total exceeds max periods (${maxPeriods})!
                                </div>
                            </div>
                            <p style="font-size: 0.85rem; color: var(--medium-text); margin-bottom: 15px;">
                                <strong>Tip:</strong> Use this if the timetable was different on this day. Enter the number of classes (periods) for each subject.
                            </p>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                ${subjectHTML}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn secondary-btn" onclick="clearCustomSchedule('${dateStr}')" style="flex: 1;">
                                🗑️ Use Default
                            </button>
                            <button class="btn primary-btn" onclick="saveCustomSchedule('${dateStr}')" style="flex: 1;">
                                💾 Save Schedule
                            </button>
                        </div>
                    </div>`;

                modal.classList.add('active');
                updateCustomScheduleTotal(); // Initialize total
            }

            function updateCustomScheduleTotal() {
                let total = 0;
                const maxPeriods = getMaxPeriods();

                if (selectedClass?.subjects) {
                    selectedClass.subjects.forEach(subject => {
                        const input = document.getElementById(`customSched_${subject.code}`);
                        if (input) {
                            total += parseInt(input.value) || 0;
                        }
                    });
                }

                const totalEl = document.getElementById('customScheduleTotal');
                const warningEl = document.getElementById('customScheduleWarning');

                if (totalEl) {
                    totalEl.textContent = `${total} / ${maxPeriods}`;
                    totalEl.style.color = total > maxPeriods ? 'var(--danger-color)' : 'var(--success-grad-start)';
                }

                if (warningEl) {
                    warningEl.style.display = total > maxPeriods ? 'block' : 'none';
                }
            }

            function saveCustomSchedule(dateStr) {
                const className = document.getElementById('classSelector')?.value;
                if (!className) return;

                const maxPeriods = getMaxPeriods();
                let total = 0;
                const scheduleData = {};

                // Get period counts for each subject
                if (selectedClass?.subjects) {
                    selectedClass.subjects.forEach(subject => {
                        const input = document.getElementById(`customSched_${subject.code}`);
                        if (input) {
                            const count = parseInt(input.value) || 0;
                            if (count > 0) {
                                scheduleData[subject.code] = count;
                            }
                            total += count;
                        }
                    });
                }

                // Validation
                if (total === 0) {
                    alert('Please set at least one class for a subject.');
                    return;
                }

                if (total > maxPeriods) {
                    alert(`Total classes (${total}) exceeds max periods (${maxPeriods}). Please reduce.`);
                    return;
                }

                // Save custom schedule (now as object with counts)
                const customSchedules = JSON.parse(localStorage.getItem(`custom_schedules_${className}`) || '{}');
                customSchedules[dateStr] = scheduleData;
                localStorage.setItem(`custom_schedules_${className}`, JSON.stringify(customSchedules));

                closeModal('customScheduleModal');
                populateDailyLog(); // Refresh the daily log form

                alert(`✅ Custom schedule saved for ${dateStr} (${total} periods)`);
            }

            function clearCustomSchedule(dateStr) {
                const className = document.getElementById('classSelector')?.value;
                if (!className) return;

                const customSchedules = JSON.parse(localStorage.getItem(`custom_schedules_${className}`) || '{}');
                delete customSchedules[dateStr];
                localStorage.setItem(`custom_schedules_${className}`, JSON.stringify(customSchedules));

                closeModal('customScheduleModal');
                populateDailyLog(); // Refresh the daily log form

                alert('✅ Switched to default schedule for ' + dateStr);
            }

            function filterHistoryDate(dateStr) {
                const tableBody = document.getElementById('historyTableBody');
                if (!tableBody) {
                    console.error('historyTableBody element not found');
                    return;
                }

                if (!dateStr) {
                    // If cleared, show all dates again
                    const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                    const sortedDates = Object.keys(logs).sort((a, b) => new Date(b) - new Date(a));
                    tableBody.innerHTML = renderHistoryRows(sortedDates, logs);
                    return;
                }

                const check = isHolidayOrNoClass(dateStr);
                if (check.isHoliday) {
                    alert(`Cannot select ${dateStr}: It is a ${check.reason}.`);
                    document.getElementById('historyDateFilter').value = ''; // Clear selection
                    return;
                }

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};

                if (logs[dateStr]) {
                    // Show only this date
                    const filteredDates = [dateStr];
                    const rowHtml = renderHistoryRows(filteredDates, logs);
                    tableBody.innerHTML = rowHtml;
                } else {
                    // Show inline message with Add Log button
                    tableBody.innerHTML = `
                    <tr>
                        <td colspan="3" style="padding: 30px; text-align: center;">
                            <div style="color: var(--medium-text);">
                                <p style="font-size: 1.1rem; margin-bottom: 10px;">📅 No log found for <strong>${dateStr}</strong></p>
                                <p style="margin-bottom: 20px;">Would you like to add a log for this date?</p>
                                <button class="btn primary-btn" onclick="addLogForDate('${dateStr}')" style="padding: 10px 20px;">📝 Add Log for ${dateStr}</button>
                            </div>
                        </td>
                    </tr>`;
                }
            }

            function addLogForDate(dateStr) {
                closeModal('historyLogModal');
                document.getElementById('logDate').value = dateStr;
                populateDailyLog();
                document.getElementById('dailyLogModal').classList.add('active');
            }

            function openDailyLog() {
                const today = formatLocalDate(new Date());
                document.getElementById('logDate').value = today;
                populateDailyLog();
                document.getElementById('dailyLogModal').classList.add('active');
            }

            function applyBulkAction(status) {
                const allSelects = document.querySelectorAll('#dailyLogSubjects select');
                allSelects.forEach(select => {
                    select.value = status;
                });
                if (status === 'Medical Leave (ML)') {
                    alert("All subjects marked as Medical Leave (ML).");
                }
            }

            function handleStatusChange(selectElement) {
                const status = selectElement.value;
                const subjectCode = selectElement.dataset.code;
                const allSelects = document.querySelectorAll('#dailyLogSubjects select');

                // Check if current subject WAS ML before change
                const wasML = selectElement.dataset.previousValue === 'Medical Leave (ML)';

                if (status === 'Medical Leave (ML)') {
                    // Auto-set all others to ML
                    allSelects.forEach(select => {
                        select.value = 'Medical Leave (ML)';
                        select.dataset.previousValue = 'Medical Leave (ML)';
                    });
                    alert("Medical Leave (ML) selected.\n\nAll subjects for this day have been marked as ML.");
                } else if (wasML && status !== 'Medical Leave (ML)') {
                    // Changing FROM ML to something else - reset all to Default
                    allSelects.forEach(select => {
                        select.value = 'Default';
                        select.dataset.previousValue = 'Default';
                    });
                    alert("ML removed from this day.\n\nAll subjects have been reset to 'Default'.\nPlease mark attendance for each subject individually.");
                } else if (status === 'Attended' || status === 'Skipped' || status === 'Cancelled' || status === 'Duty Leave (OD)') {
                    // Check if OTHER subjects are still ML
                    const hasOtherML = Array.from(allSelects).some(s => s !== selectElement && s.value === 'Medical Leave (ML)');

                    if (hasOtherML) {
                        alert("Cannot mix 'Medical Leave (ML)' with other statuses.\n\nTo edit individual subjects, first change any ML subject to 'Default' to reset all.");
                        selectElement.value = 'Medical Leave (ML)';
                        return;
                    }
                }

                // Update previous value for next change detection
                selectElement.dataset.previousValue = status;
            }

            // === QR SCANNER AND GENERATOR FUNCTIONS (Reference Implementation) ===

            var qrStream = null;
            var qrVideo = null;
            var qrCanvas = null;
            var qrContext = null;
            var qrScanLoop = null;

            function switchModalTab(tabName) {
                // Hide all tabs
                ['form', 'json', 'scan', 'share'].forEach(t => {
                    const el = document.getElementById(t + 'EntryTab');
                    if (el) el.style.display = 'none';
                    const btn = document.getElementById(t + 'TabBtn');
                    if (btn) btn.classList.remove('active');
                });

                // Show selected
                const selectedEl = document.getElementById(tabName + 'EntryTab');
                if (selectedEl) selectedEl.style.display = 'block';
                const selectedBtn = document.getElementById(tabName + 'TabBtn');
                if (selectedBtn) selectedBtn.classList.add('active');

                isJsonMode = (tabName === 'json');

                // Logic for specific tabs
                if (tabName === 'scan') {
                    startTabScanner();
                } else {
                    stopTabScanner();
                }

                if (tabName === 'share') {
                    generateShareQRTab();
                }
            }

            function startTabScanner() {
                const reader = document.getElementById('readerTab');
                if (!reader || qrStream) return;

                // Create video element
                reader.innerHTML = `
                    <div style="position: relative; max-width: 100%; margin: 0 auto;">
                        <video id="qrVideo" style="width: 100%; border-radius: 8px; background: #000;"></video>
                        <div id="qrStatus" style="margin-top: 10px; text-align: center; color: var(--medium-text);">
                            Starting camera...
                        </div>
                    </div>
                `;

                qrVideo = document.getElementById('qrVideo');
                qrCanvas = document.createElement('canvas');
                qrContext = qrCanvas.getContext('2d');

                // Request camera access
                navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                })
                    .then(stream => {
                        qrStream = stream;
                        qrVideo.srcObject = stream;
                        qrVideo.setAttribute('playsinline', true);
                        qrVideo.play();

                        document.getElementById('qrStatus').textContent = 'Point camera at QR code...';

                        // Start scanning loop
                        qrVideo.addEventListener('loadedmetadata', () => {
                            qrCanvas.width = qrVideo.videoWidth;
                            qrCanvas.height = qrVideo.videoHeight;
                            scanQRCode();
                        });
                    })
                    .catch(err => {
                        document.getElementById('qrStatus').innerHTML =
                            '<span style="color: var(--danger-color);">Camera access denied. Please allow camera access and try again.</span>';
                        console.error('Camera error:', err);
                    });
            }

            async function scanQRCode() {
                if (!qrVideo || !qrStream) return;

                // Try Native BarcodeDetector first (Faster & Better)
                if ('BarcodeDetector' in window) {
                    try {
                        const barcodeDetector = new BarcodeDetector({ formats: ['qr_code'] });
                        const barcodes = await barcodeDetector.detect(qrVideo);

                        if (barcodes.length > 0) {
                            onScanSuccessTab(barcodes[0].rawValue);
                            stopTabScanner();
                            return;
                        }
                    } catch (e) {
                        console.warn('BarcodeDetector failed, falling back to jsQR', e);
                    }
                }

                // Fallback to jsQR
                if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                    qrCanvas.width = qrVideo.videoWidth;
                    qrCanvas.height = qrVideo.videoHeight;
                    qrContext.drawImage(qrVideo, 0, 0, qrCanvas.width, qrCanvas.height);

                    const imageData = qrContext.getImageData(0, 0, qrCanvas.width, qrCanvas.height);

                    // Check if jsQR is loaded
                    if (typeof jsQR === 'function') {
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: "dontInvert",
                        });

                        if (code) {
                            onScanSuccessTab(code.data);
                            stopTabScanner();
                            return;
                        }
                    } else {
                        console.error('jsQR library not loaded!');
                    }
                }

                // Keep scanning
                qrScanLoop = requestAnimationFrame(scanQRCode);
            }

            function stopTabScanner() {
                if (qrScanLoop) {
                    cancelAnimationFrame(qrScanLoop);
                    qrScanLoop = null;
                }

                if (qrStream) {
                    qrStream.getTracks().forEach(track => track.stop());
                    qrStream = null;
                }

                if (qrVideo) {
                    qrVideo.srcObject = null;
                    qrVideo = null;
                }

                const reader = document.getElementById('readerTab');
                if (reader) {
                    reader.innerHTML = '';
                }
            }

            function handleQRFileUploadInTab(input) {
                if (input.files.length === 0) return;

                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');

                        // Resize if too large (max 800px) for performance
                        const MAX_SIZE = 800;
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_SIZE) {
                                height *= MAX_SIZE / width;
                                width = MAX_SIZE;
                            }
                        } else {
                            if (height > MAX_SIZE) {
                                width *= MAX_SIZE / height;
                                height = MAX_SIZE;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        context.drawImage(img, 0, 0, width, height);

                        const imageData = context.getImageData(0, 0, width, height);
                        let code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code) {
                            onScanSuccessTab(code.data);
                            input.value = '';
                            return;
                        }

                        // If failed, try inverting colors (for dark mode QRs)
                        console.log("Standard scan failed, trying inverted...");
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = 255 - data[i];     // R
                            data[i + 1] = 255 - data[i + 1]; // G
                            data[i + 2] = 255 - data[i + 2]; // B
                        }
                        context.putImageData(imageData, 0, 0);
                        code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code) {
                            onScanSuccessTab(code.data);
                        } else {
                            alert("Could not read QR code.\n\nTips:\n1. Ensure the image is clear and well-lit.\n2. Crop the image to show ONLY the QR code.\n3. If it's a screenshot, try zooming in before capturing.");
                        }
                        input.value = '';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            function onScanSuccessTab(decodedText) {
                try {
                    const rawData = JSON.parse(decodedText);
                    let classData = {};
                    let timetableArrangement = null;

                    // === NEW MINIFIED FORMAT (v2): t, ld, h, s with sch ===
                    // Format: { t: "ClassName", ld: "260401", h: ["250809"], s: [{n, sn, c, sch: "1|1,2|0|..."}] }
                    const isMinifiedV2 = rawData.t && rawData.s && Array.isArray(rawData.s) &&
                        rawData.s.length > 0 && rawData.s[0].sch !== undefined;

                    if (isMinifiedV2) {
                        console.log('Detected minified QR format v2');

                        // Helper: Convert YYMMDD to YYYY-MM-DD
                        const expandDate = (yymmdd) => {
                            if (!yymmdd || yymmdd.length !== 6) return '';
                            const yy = yymmdd.slice(0, 2);
                            const mm = yymmdd.slice(2, 4);
                            const dd = yymmdd.slice(4, 6);
                            const century = parseInt(yy) > 50 ? '19' : '20';
                            return `${century}${yy}-${mm}-${dd}`;
                        };

                        // Parse subjects
                        const processedSubjects = rawData.s.map(sub => {
                            // Parse pipe-delimited schedule: "1|1,2|0|3|0|0|0" -> [1, 2, 0, 1, 0, 0, 0] (counts)
                            const schParts = (sub.sch || '0|0|0|0|0|0|0').split('|');
                            const schedule = schParts.map(part => {
                                if (!part || part === '0') return 0;
                                return part.split(',').filter(p => p.trim() && p.trim() !== '0').length;
                            });

                            return {
                                name: sub.n,
                                shortName: sub.sn || getSubjectShortName(sub.n),
                                code: sub.c,
                                schedule: schedule
                            };
                        });

                        // Generate timetable arrangement from sch strings
                        timetableArrangement = {};
                        let maxPeriods = 0;

                        // Calculate max periods
                        rawData.s.forEach(sub => {
                            const schParts = (sub.sch || '').split('|');
                            schParts.forEach(part => {
                                if (part && part !== '0') {
                                    const periods = part.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p) && p > 0);
                                    if (periods.length > 0) {
                                        maxPeriods = Math.max(maxPeriods, Math.max(...periods));
                                    }
                                }
                            });
                        });

                        // Build arrangement using day indices (0-6)
                        [0, 1, 2, 3, 4, 5, 6].forEach(dayIndex => {
                            timetableArrangement[dayIndex] = Array(maxPeriods).fill(null);

                            rawData.s.forEach(sub => {
                                const schParts = (sub.sch || '').split('|');
                                const daySchedule = schParts[dayIndex] || '0';

                                if (daySchedule && daySchedule !== '0') {
                                    const periods = daySchedule.split(',')
                                        .map(p => parseInt(p.trim()))
                                        .filter(p => !isNaN(p) && p > 0);

                                    periods.forEach(periodNum => {
                                        if (periodNum > 0 && periodNum <= maxPeriods) {
                                            timetableArrangement[dayIndex][periodNum - 1] = sub.c;
                                        }
                                    });
                                }
                            });

                            // Clean up trailing nulls
                            while (timetableArrangement[dayIndex].length > 0 &&
                                timetableArrangement[dayIndex][timetableArrangement[dayIndex].length - 1] === null) {
                                timetableArrangement[dayIndex].pop();
                            }
                        });

                        classData = {
                            name: rawData.t,
                            lastDate: expandDate(rawData.ld),
                            subjects: processedSubjects,
                            holidays: (rawData.h || []).map(expandDate)
                        };
                    }
                    // === OLD FULL FORMAT: Class name as top-level key ===
                    // Format: { "ClassName": { lastDate, holidays, subjects: [{name, shortName, code, schedule}], qrCode } }
                    else if (Object.keys(rawData).length === 1 &&
                        rawData[Object.keys(rawData)[0]] &&
                        rawData[Object.keys(rawData)[0]].subjects &&
                        Array.isArray(rawData[Object.keys(rawData)[0]].subjects)) {

                        const topLevelKeys = Object.keys(rawData);
                        const className = topLevelKeys[0];
                        const data = rawData[className];

                        // Detect if schedule is string-based (new format) and convert to integer
                        const processedSubjects = data.subjects.map(sub => {
                            let schedule = sub.schedule;

                            // Check if schedule is string array and convert to integer counts
                            if (Array.isArray(schedule) && schedule.length > 0 && typeof schedule[0] === 'string') {
                                schedule = schedule.map(daySchedule => {
                                    if (!daySchedule || daySchedule === '0') return 0;
                                    return String(daySchedule).split(',').filter(p => p.trim() && p.trim() !== '0').length;
                                });
                            }

                            return {
                                name: sub.name,
                                shortName: sub.shortName || getSubjectShortName(sub.name),
                                code: sub.code,
                                schedule: schedule
                            };
                        });

                        // Generate timetable arrangement from string schedules (period positions)
                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                        timetableArrangement = {};

                        // Calculate max periods from string schedules
                        let maxPeriods = 0;
                        data.subjects.forEach(subject => {
                            if (subject.schedule) {
                                subject.schedule.forEach(daySchedule => {
                                    if (daySchedule && daySchedule !== '0') {
                                        const periods = String(daySchedule).split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                                        if (periods.length > 0) {
                                            maxPeriods = Math.max(maxPeriods, Math.max(...periods));
                                        }
                                    }
                                });
                            }
                        });

                        // Build arrangement from string schedules - USE DAY INDEX as key (not name)
                        days.forEach((dayName, dayIndex) => {
                            timetableArrangement[dayIndex] = Array(maxPeriods).fill(null);

                            data.subjects.forEach(subject => {
                                if (subject.schedule && subject.schedule[dayIndex] && subject.schedule[dayIndex] !== '0') {
                                    const periods = String(subject.schedule[dayIndex]).split(',')
                                        .map(p => parseInt(p.trim()))
                                        .filter(p => !isNaN(p) && p > 0);

                                    periods.forEach(periodNum => {
                                        if (periodNum > 0 && periodNum <= maxPeriods) {
                                            timetableArrangement[dayIndex][periodNum - 1] = subject.code;
                                        }
                                    });
                                }
                            });

                            // Clean up trailing nulls
                            while (timetableArrangement[dayIndex].length > 0 &&
                                timetableArrangement[dayIndex][timetableArrangement[dayIndex].length - 1] === null) {
                                timetableArrangement[dayIndex].pop();
                            }
                        });

                        classData = {
                            name: className,
                            lastDate: data.lastDate,
                            subjects: processedSubjects,
                            holidays: data.holidays || []
                        };
                    }
                    // Handle Minified Format (n=name, l=lastDate, s=subjects, h=holidays, ta=timetableArrangement)
                    else if (rawData.n && rawData.s) {
                        classData = {
                            name: rawData.n,
                            lastDate: rawData.l,
                            subjects: rawData.s.map(sub => ({
                                name: sub.n,
                                code: sub.c,
                                schedule: sub.sc
                            })),
                            holidays: rawData.h || []
                        };

                        // Extract timetable arrangement if present
                        if (rawData.ti) {
                            // Reconstruct from Timetable Indices (ti)
                            // Now supporting ARRAY format [MonArray, TueArray...]
                            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                            timetableArrangement = {};

                            // Check if it's an array (new format) or object (old format/backup)
                            if (Array.isArray(rawData.ti)) {
                                rawData.ti.forEach((dayIndices, dayIndex) => {
                                    const dayName = days[dayIndex];
                                    if (dayIndices && dayIndices.length > 0) {
                                        timetableArrangement[dayIndex] = dayIndices.map(index => {
                                            if (index === -1) return null; // Free Period
                                            return classData.subjects[index] ? classData.subjects[index].code : null;
                                        });
                                    }
                                });
                            } else {
                                // Object format (legacy intermediate step)
                                Object.keys(rawData.ti).forEach(day => {
                                    timetableArrangement[day] = rawData.ti[day].map(index => {
                                        if (index === -1) return null;
                                        return classData.subjects[index] ? classData.subjects[index].code : null;
                                    });
                                });
                            }
                        } else if (rawData.ta) {
                            timetableArrangement = rawData.ta;
                        }

                        // === FALLBACK: Generate Default Arrangement if Missing ===
                        // If no arrangement found, generate one from the subject schedule counts - USE INDEX as key
                        if (!timetableArrangement || Object.keys(timetableArrangement).length === 0) {
                            timetableArrangement = {};

                            [0, 1, 2, 3, 4, 5, 6].forEach(dayIndex => {
                                const dailySequence = [];
                                classData.subjects.forEach(subject => {
                                    // Check how many classes this subject has on this day
                                    // Handle array schedule (new format) or mapped schedule
                                    const count = subject.schedule[dayIndex] || 0;
                                    for (let k = 0; k < count; k++) {
                                        dailySequence.push(subject.code);
                                    }
                                });
                                timetableArrangement[dayIndex] = dailySequence;
                            });
                        }
                    } else {
                        // Handle Legacy Format
                        classData = rawData;
                        // Check for timetableArrangement in legacy format
                        if (rawData.timetableArrangement) {
                            timetableArrangement = rawData.timetableArrangement;
                        }
                    }

                    if (!classData.name || !classData.subjects || !Array.isArray(classData.subjects)) {
                        alert("Invalid Class QR Code: Missing name or subjects.");
                        return;
                    }

                    let newName = classData.name;
                    let counter = 1;
                    while (classes[newName]) {
                        newName = `${classData.name} (${counter++})`;
                    }
                    classData.name = newName;

                    // Add to classes
                    classes[newName] = {
                        lastDate: classData.lastDate || '',
                        subjects: classData.subjects,
                        holidays: classData.holidays || []
                    };
                    saveToStorage();

                    // Save timetable arrangement if present, otherwise generate default
                    let validTA = false;
                    if (timetableArrangement && Object.keys(timetableArrangement).length > 0) {
                        try {
                            // Check if it has actual content
                            const hasContent = Object.values(timetableArrangement).some(dayArr => Array.isArray(dayArr) && dayArr.length > 0);
                            if (hasContent) validTA = true;
                        } catch (e) { }
                    }

                    if (validTA) {
                        // Convert day names to indices if needed before saving
                        const convertedTA = {};
                        const dayNameToIndex = { 'Mon': 0, 'Tue': 1, 'Wed': 2, 'Thu': 3, 'Fri': 4, 'Sat': 5, 'Sun': 6 };
                        Object.keys(timetableArrangement).forEach(key => {
                            // If key is a day name, convert to index
                            if (dayNameToIndex[key] !== undefined) {
                                convertedTA[dayNameToIndex[key]] = timetableArrangement[key];
                            } else {
                                convertedTA[key] = timetableArrangement[key];
                            }
                        });
                        localStorage.setItem(`timetable_arrangement_${newName}`, JSON.stringify(convertedTA));
                    } else {
                        // Force generation of default timetable if missing from QR - USE INDEX as key
                        const defaultTA = {};
                        [0, 1, 2, 3, 4, 5, 6].forEach(dayIndex => {
                            const dailySequence = [];
                            classData.subjects.forEach(subject => {
                                const count = (subject.schedule && subject.schedule[dayIndex]) || 0;
                                for (let k = 0; k < count; k++) {
                                    dailySequence.push(subject.code);
                                }
                            });
                            defaultTA[dayIndex] = dailySequence;
                        });
                        if (Object.keys(defaultTA).length > 0) {
                            localStorage.setItem(`timetable_arrangement_${newName}`, JSON.stringify(defaultTA));
                        }
                    }

                    populateClassSelector();

                    // Select the new class
                    document.getElementById('classSelector').value = newName;
                    onClassChange();

                    alert(`Class "${newName}" imported successfully!`);
                    closeModal('addClassModal');
                    stopTabScanner();

                } catch (e) {
                    alert("Error parsing QR code: " + e.message);
                }
            }

            function generateShareQRTab() {
                if (!editingClassName || !classes[editingClassName]) return;

                const classData = classes[editingClassName];
                const qrContainer = document.getElementById('qrcodeTab');

                try {
                    // Get timetable arrangement for accurate period numbers
                    const arrangement = getTimetableArrangement(editingClassName);

                    // === MINIFIED FORMAT for low-density QR ===
                    // t=title, ld=lastDate(YYMMDD), h=holidays, s=subjects
                    // Subject: n=name, sn=shortName, c=code, sch=schedule(pipe-delimited)

                    // Helper: Convert YYYY-MM-DD to YYMMDD
                    const compressDate = (dateStr) => {
                        if (!dateStr) return '';
                        return dateStr.replace(/-/g, '').slice(2); // "2025-08-09" -> "250809"
                    };

                    // Build minified data
                    const minifiedData = {
                        t: editingClassName,
                        ld: compressDate(classData.lastDate),
                        h: (classData.holidays || []).map(compressDate),
                        s: classData.subjects.map((subject) => {
                            // Get shortName
                            const shortName = subject.shortName || getSubjectShortName(subject.name);

                            // Build schedule string (pipe-delimited)
                            let scheduleArr = [];
                            [0, 1, 2, 3, 4, 5, 6].forEach(dayIndex => {
                                if (arrangement && arrangement[dayIndex]) {
                                    // Find which periods this subject occupies
                                    const periods = [];
                                    arrangement[dayIndex].forEach((item, periodIndex) => {
                                        const itemCode = (typeof item === 'string') ? item : (item?.code || null);
                                        if (itemCode === subject.code) {
                                            periods.push(periodIndex + 1);
                                        }
                                    });
                                    scheduleArr.push(periods.length > 0 ? periods.join(',') : '0');
                                } else {
                                    // Fallback: use count-based format
                                    const count = subject.schedule?.[dayIndex] || 0;
                                    if (count > 0) {
                                        const periods = Array.from({ length: count }, (_, i) => i + 1);
                                        scheduleArr.push(periods.join(','));
                                    } else {
                                        scheduleArr.push('0');
                                    }
                                }
                            });

                            return {
                                n: subject.name,
                                sn: shortName,
                                c: subject.code,
                                sch: scheduleArr.join('|') // "1|1,2|1|0|1|1|0"
                            };
                        })
                    };

                    const jsonString = JSON.stringify(minifiedData);
                    qrContainer.innerHTML = '';

                    // Show size info
                    console.log(`QR Data size: ${jsonString.length} chars`);

                    // Check if data is too large for QR (limit ~2.5KB for reliable scanning)
                    if (jsonString.length > 2500) {
                        qrContainer.innerHTML = `<div style="color:var(--warning-color); padding:20px; text-align:center;">
                            <p>⚠️ Class data is too large for QR Code (${jsonString.length} chars).</p>
                            <p style="font-size:0.8rem">Use "Copy JSON" to share via text instead.</p>
                            <button class="btn primary-btn" onclick="copyMinifiedQRData()">📋 Copy JSON</button>
                        </div>`;
                        return;
                    }

                    new QRCode(qrContainer, {
                        text: jsonString,
                        width: 300,
                        height: 300,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.L
                    });

                    // Center the QR code
                    qrContainer.style.display = 'flex';
                    qrContainer.style.flexDirection = 'column';
                    qrContainer.style.alignItems = 'center';
                    qrContainer.style.justifyContent = 'center';
                } catch (error) {
                    console.error("QR Gen Error:", error);
                    qrContainer.innerHTML = `<div style="color:var(--danger-color); padding:20px; text-align:center;">
                        <p>⚠️ Failed to generate QR Code.</p>
                        <p style="font-size:0.8rem">Data might be too large or invalid.</p>
                    </div>`;
                    alert("Error generating QR code. The class data might be too large.");
                }
            }

            // Helper to copy minified QR data
            function copyMinifiedQRData() {
                if (!editingClassName || !classes[editingClassName]) return;
                const classData = classes[editingClassName];
                const arrangement = getTimetableArrangement(editingClassName);

                const compressDate = (dateStr) => dateStr ? dateStr.replace(/-/g, '').slice(2) : '';

                const minifiedData = {
                    t: editingClassName,
                    ld: compressDate(classData.lastDate),
                    h: (classData.holidays || []).map(compressDate),
                    s: classData.subjects.map(subject => ({
                        n: subject.name,
                        sn: subject.shortName || getSubjectShortName(subject.name),
                        c: subject.code,
                        sch: [0, 1, 2, 3, 4, 5, 6].map(dayIndex => {
                            if (arrangement && arrangement[dayIndex]) {
                                const periods = [];
                                arrangement[dayIndex].forEach((item, pi) => {
                                    const code = typeof item === 'string' ? item : item?.code;
                                    if (code === subject.code) periods.push(pi + 1);
                                });
                                return periods.length > 0 ? periods.join(',') : '0';
                            }
                            return '0';
                        }).join('|')
                    }))
                };

                navigator.clipboard.writeText(JSON.stringify(minifiedData))
                    .then(() => alert('Minified JSON copied!'));
            }

            function shareQRImageTab() {
                const qrContainer = document.getElementById('qrcodeTab');
                const canvas = qrContainer.querySelector('canvas');
                const img = qrContainer.querySelector('img');
                const source = canvas || img;

                if (!source) {
                    alert("QR Code not generated yet.");
                    return;
                }

                let dataUrl = source.src || source.toDataURL();

                fetch(dataUrl)
                    .then(res => res.blob())
                    .then(blob => {
                        const file = new File([blob], `${editingClassName}_QR.png`, { type: "image/png" });
                        const shareText = `👋 Hey friends! Check out this amazing app!\n\n📱 Download Bunkit: https://bunkitapp.in\n\n📝 How to set up our ${editingClassName} class:\n\n1. Open the Bunkit app\n2. Enter your name\n3. Tap Add New Class\n4. Hit Scan QR\n5. Scan the class QR code\n6. And boom! Class setup done 🎉\n\n✨ Now we can track attendance together — super smooth and super fun!`;

                        if (navigator.share) {
                            // Step 1: Copy text to clipboard first
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(shareText).then(() => {
                                    // Step 2: Show clear instructions
                                    alert('✅ Message copied to clipboard!\n\n📋 Next steps:\n1. Share the QR code\n2. In WhatsApp, long-press the message box\n3. Tap "Paste" to add the message\n4. Send! 🚀');

                                    // Step 3: Share the QR image
                                    setTimeout(() => {
                                        navigator.share({
                                            files: [file]
                                        }).catch(err => {
                                            if (err.name !== 'AbortError') {
                                                console.error('Share failed:', err);
                                            }
                                        });
                                    }, 500);
                                }).catch(() => {
                                    // Clipboard failed, just share the file
                                    navigator.share({
                                        files: [file]
                                    }).catch(err => {
                                        if (err.name !== 'AbortError') {
                                            console.error('Share failed:', err);
                                        }
                                    });
                                });
                            } else {
                                // No clipboard support, just share file
                                navigator.share({
                                    files: [file]
                                }).catch(err => {
                                    if (err.name !== 'AbortError') {
                                        console.error('Share failed:', err);
                                    }
                                });
                            }
                        } else {
                            alert("Sharing not supported on this browser. Please use Download.");
                        }
                    });
            }

            function downloadQRImageTab() {
                const qrContainer = document.getElementById('qrcodeTab');
                const canvas = qrContainer.querySelector('canvas');
                const img = qrContainer.querySelector('img');
                const source = canvas || img;

                if (!source) return;

                const link = document.createElement('a');
                link.download = `Class_QR_${editingClassName}.png`;
                link.href = source.src || source.toDataURL();
                link.click();
            }

            // Global exports (keeping both naming conventions for compatibility)
            window.startQRScannerInTab = startTabScanner;
            window.startTabScanner = startTabScanner;
            window.stopTabScanner = stopTabScanner;
            window.handleQRFileUploadInTab = handleQRFileUploadInTab;
            window.generateShareQRInTab = generateShareQRTab;
            window.generateShareQRTab = generateShareQRTab;
            window.shareQRImageTab = shareQRImageTab;
            window.downloadQRImageTab = downloadQRImageTab;


            function getMissingLogDates() {
                if (!selectedClass?.portalSetup?.semesterStartDate) return [];

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                const startDate = new Date(selectedClass.portalSetup.semesterStartDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const missingDates = [];

                for (let d = new Date(startDate); d <= today; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    const check = isHolidayOrNoClass(dateStr);

                    // Skip holidays and no-class days
                    if (check.isHoliday) continue;

                    // Check if log exists
                    if (!logs[dateStr]) {
                        missingDates.push(dateStr);
                    }
                }

                return missingDates;
            }

            // ==================== PERIOD-WISE ATTENDANCE VIEW ====================

            // Generate unique colors for subjects - uses same palette as timetable
            function getSubjectColorsForPeriodView() {
                const colors = {};
                if (!selectedClass?.subjects) return colors;
                selectedClass.subjects.forEach((s, i) => {
                    // Use the same getSubjectColor function as timetable
                    const baseColor = getSubjectColor(i);
                    colors[s.code] = {
                        glow: baseColor,
                        name: s.name,
                        index: i
                    };
                });
                return colors;
            }

            // Get timetable for a specific day (0=Mon, 6=Sun)
            function getTimetableForDay(dayIndex) {
                const className = document.getElementById('classSelector')?.value;
                if (!className || !selectedClass?.subjects) return [];

                const arrangement = getTimetableArrangement(className);

                // Check if arrangement exists for this day
                // Arrangement uses numeric day indices (0=Mon, 6=Sun)
                if (arrangement && arrangement[dayIndex]) {
                    // Use saved arrangement (array of objects with code, name, shortName)
                    // Null items represent FREE PERIODS
                    return arrangement[dayIndex].map(item => {
                        // Null = free period, keep it
                        if (!item) return null;
                        // Handle both formats: object {code, name} or just code string
                        const code = typeof item === 'object' ? item.code : item;
                        if (!code) return null; // free period
                        const subject = selectedClass.subjects.find(s => s.code === code);
                        return subject ? { code: subject.code, name: subject.name } : null;
                    }); // No filter - keep nulls for free periods
                } else {
                    // Generate from schedule (fallback)
                    const periods = [];
                    selectedClass.subjects.forEach(subject => {
                        const count = subject.schedule[dayIndex] || 0;
                        for (let i = 0; i < count; i++) {
                            periods.push({ code: subject.code, name: subject.name });
                        }
                    });
                    return periods;
                }
            }

            // Check if date is holiday (using existing function)
            function isDateHoliday(dateStr) {
                if (!selectedClass) return false;
                return (selectedClass.holidays || []).includes(dateStr);
            }

            // Get max periods across all days
            function getMaxPeriods() {
                let max = 0;
                for (let d = 0; d < 7; d++) {
                    const periods = getTimetableForDay(d);
                    if (periods.length > max) max = periods.length;
                }
                return max;
            }

            // Open period-wise attendance modal
            function openPeriodAttendanceModal() {
                if (!selectedClass) {
                    alert('Please select a class first.');
                    return;
                }

                if (!selectedClass.portalSetup?.active) {
                    alert('Period-wise view is only available in Portal Mode.\n\nPlease set up Portal Mode first by clicking "Setup Portal Mode" in the dashboard.');
                    return;
                }

                const className = document.getElementById('classSelector').value;
                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                const subjectColors = getSubjectColorsForPeriodView();
                const maxPeriods = getMaxPeriods();

                if (maxPeriods === 0) {
                    alert('No periods configured. Please set up your weekly timetable first.');
                    return;
                }

                // Get date range (semester start to today)
                const startDate = parseLocalDate(selectedClass.portalSetup.semesterStartDate);
                // Use parseLocalDate with formatLocalDate to get "Today" at midnight local time
                const today = parseLocalDate(formatLocalDate(new Date()));

                // Group dates by month
                const monthGroups = {};
                for (let d = new Date(today); d >= startDate; d.setDate(d.getDate() - 1)) {
                    const monthKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                    const monthName = d.toLocaleString('default', { month: 'long', year: 'numeric' });

                    if (!monthGroups[monthKey]) {
                        monthGroups[monthKey] = { name: monthName, dates: [] };
                    }
                    monthGroups[monthKey].dates.push(new Date(d));
                }

                // Build modal HTML
                let modalHTML = `
                    <div class="modal-content" style="max-width: 95vw; width: 900px;">
                        <button class="modal-close" onclick="closeModal('periodAttendanceModal')">&times;</button>
                        <div class="modal-header">
                            <h2>📊 Period-wise Attendance</h2>
                            <p>View and edit your attendance by period. Click on any cell to change status.</p>
                        </div>
                        
                        <div class="period-legend">
                            <div class="period-legend-item"><div class="period-legend-color" style="background: rgba(200, 200, 200, 0.6); border: 2px dashed #888;"></div> Not Logged (?)</div>
                            <div class="period-legend-item"><div class="period-legend-color" style="background: #4CAF50;"></div> Present (P)</div>
                            <div class="period-legend-item"><div class="period-legend-color" style="background: #f44336;"></div> Absent (A)</div>
                            <div class="period-legend-item"><div class="period-legend-color" style="background: #9e9e9e;"></div> Cancelled (C)</div>
                            <div class="period-legend-item"><div class="period-legend-color" style="background: #2196F3;"></div> Duty Leave (OD)</div>
                            <div class="period-legend-item"><div class="period-legend-color" style="background: #FF9800;"></div> Medical (ML)</div>
                        </div>

                        <div class="period-view-container" style="margin-top: 15px;">`;

                // Render each month
                Object.keys(monthGroups).sort().reverse().forEach((monthKey, idx) => {
                    const month = monthGroups[monthKey];
                    let notLoggedCount = 0;
                    let presentCount = 0;
                    let absentCount = 0;
                    let cancelledCount = 0;
                    let odCount = 0;
                    let mlCount = 0;

                    // Calculate month stats
                    month.dates.forEach(date => {
                        const dateStr = formatLocalDate(date);
                        const dayOfWeek = date.getDay();
                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                        if (!isDateHoliday(dateStr)) {
                            const periods = getTimetableForDay(scheduleIndex);
                            const dayLog = logs[dateStr] || {};

                            periods.forEach(period => {
                                // Skip null/free periods
                                if (!period || !period.code) return;

                                const status = dayLog[period.code];
                                if (!status || status === 'Default') {
                                    notLoggedCount++;
                                } else if (status === 'Attended') {
                                    presentCount++;
                                } else if (status === 'Skipped') {
                                    absentCount++;
                                } else if (status === 'Cancelled') {
                                    cancelledCount++;
                                } else if (status === 'Duty Leave (OD)') {
                                    odCount++;
                                } else if (status === 'Medical Leave (ML)') {
                                    mlCount++;
                                }
                            });
                        }
                    });

                    modalHTML += `
                        <div class="period-month-section ${idx > 0 ? 'collapsed' : ''}">
                            <div class="period-month-header" onclick="togglePeriodMonth(this)">
                                <h4>${month.name}</h4>
                                <div class="period-month-summary">
                                    <span class="period-summary-badge not-logged" title="Not Logged">? ${notLoggedCount}</span>
                                    <span class="period-summary-badge present" title="Present">P ${presentCount}</span>
                                    <span class="period-summary-badge absent" title="Absent">A ${absentCount}</span>
                                    <span class="period-summary-badge cancelled" title="Cancelled">C ${cancelledCount}</span>
                                    <span class="period-summary-badge od" title="Duty Leave">OD ${odCount}</span>
                                    <span class="period-summary-badge ml" title="Medical Leave">ML ${mlCount}</span>
                                    <span class="period-month-toggle">▼</span>
                                </div>
                            </div>
                            <div class="period-month-content">
                                <div class="period-grid-wrapper">
                                    <div class="period-grid" style="grid-template-columns: 90px repeat(${maxPeriods}, 1fr);">
                                        <div class="period-grid-header">
                                            <div>Date</div>`;

                    for (let p = 1; p <= maxPeriods; p++) {
                        modalHTML += `<div>${p}</div>`;
                    }
                    modalHTML += `</div>`;

                    // Render dates in this month
                    month.dates.forEach(date => {
                        const dateStr = formatLocalDate(date);
                        const dayOfWeek = date.getDay();
                        const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                        const isHoliday = isDateHoliday(dateStr);
                        const dayLog = logs[dateStr] || {};

                        // Get subjects for this day - PRESERVE LOGGED DATA
                        // Logged data is NEVER affected by timetable changes - it stays as-is
                        const loggedSubjectCodes = Object.keys(dayLog);
                        const timetablePeriods = getTimetableForDay(scheduleIndex);

                        // Create a combined list with smart ordering
                        let periodsToShow = [];

                        if (loggedSubjectCodes.length > 0) {
                            // LOGGED DATA EXISTS - always show exactly what was logged
                            // Only use timetable for ORDERING, never for filtering

                            // Count classes per subject in timetable (skip null/free periods)
                            const timetableCountBySubject = {};
                            timetablePeriods.forEach(p => {
                                if (p && p.code) {
                                    timetableCountBySubject[p.code] = (timetableCountBySubject[p.code] || 0) + 1;
                                }
                            });

                            // Count classes per subject in logs
                            const logCountBySubject = {};
                            loggedSubjectCodes.forEach(code => {
                                logCountBySubject[code] = (logCountBySubject[code] || 0) + 1;
                            });

                            // Check if any logged subject has MORE classes than timetable
                            // OR if any logged subject is NOT in timetable (timetable changed)
                            let shouldKeepLogOrder = false;
                            for (const code of Object.keys(logCountBySubject)) {
                                const logCount = logCountBySubject[code];
                                const ttCount = timetableCountBySubject[code] || 0;
                                if (logCount > ttCount || ttCount === 0) {
                                    // Extra classes OR subject no longer in timetable
                                    shouldKeepLogOrder = true;
                                    break;
                                }
                            }

                            if (shouldKeepLogOrder) {
                                // Keep log's original order - timetable doesn't match
                                loggedSubjectCodes.forEach(code => {
                                    const subject = selectedClass?.subjects?.find(s => s.code === code);
                                    periodsToShow.push({
                                        code: code,
                                        name: subject?.name || code,
                                        status: dayLog[code]
                                    });
                                });
                                // Timetable matches - use timetable sequence
                                // Null periods = free periods
                                const seenCounts = {};

                                periodsToShow = timetablePeriods.map(p => {
                                    if (!p) return { code: null, name: 'Free', status: 'free' };

                                    // Track which instance of this subject this is (e.g. 1st Math, 2nd Math)
                                    seenCounts[p.code] = (seenCounts[p.code] || 0) + 1;
                                    const instance = seenCounts[p.code];

                                    // Try specific key first (SUBJECT_p1), then legacy key (SUBJECT) for first instance
                                    const specificKey = `${p.code}_p${instance}`;
                                    let status = dayLog[specificKey];

                                    if (!status && instance === 1) {
                                        status = dayLog[p.code];
                                    }

                                    return {
                                        code: p.code,
                                        // Pass the SPECIFIC key (e.g. MATH_p1) as the code for editing
                                        // This ensures we save to the unique slot, not the generic subject
                                        editKey: specificKey,
                                        name: p.name,
                                        status: status || 'Default'
                                    };
                                });
                            }
                        } else {
                            // No log data - show timetable periods as "not logged"
                            // Null periods = free periods
                            const seenCounts = {};

                            periodsToShow = timetablePeriods.map(p => {
                                if (!p) return { code: null, name: 'Free', status: 'free' };

                                seenCounts[p.code] = (seenCounts[p.code] || 0) + 1;
                                const instance = seenCounts[p.code];
                                const specificKey = `${p.code}_p${instance}`;

                                return {
                                    code: p.code,
                                    editKey: specificKey,
                                    name: p.name,
                                    status: 'Default'
                                };
                            });
                        }

                        // Format date display with day name
                        const dayName = date.toLocaleDateString('en-GB', { weekday: 'short' });
                        const dateDisplay = date.toLocaleDateString('en-GB', {
                            day: '2-digit',
                            month: 'short'
                        });

                        modalHTML += `<div class="period-grid-row">
                            <div class="period-date-cell"><strong>${dayName}</strong> ${dateDisplay}</div>`;

                        for (let p = 0; p < maxPeriods; p++) {
                            if (isHoliday) {
                                modalHTML += `<div class="period-cell holiday" title="Holiday">-</div>`;
                            } else if (p < periodsToShow.length) {
                                const period = periodsToShow[p];

                                // Handle null period (shouldn't happen but safety check)
                                if (!period) {
                                    modalHTML += `<div class="period-cell free-period" title="Free Period">-</div>`;
                                    continue;
                                }

                                const status = period.status;
                                const subjectColor = period.code ? subjectColors[period.code] : null;

                                // FREE PERIOD - render without click handler
                                if (status === 'free') {
                                    modalHTML += `<div class="period-cell free-period" title="Free Period">-</div>`;
                                    continue;
                                }

                                let cellClass = 'not-logged';
                                let symbol = '?';

                                // Map status to visual representation
                                if (!status || status === 'Default') {
                                    cellClass = 'not-logged';
                                    symbol = '?';
                                }
                                else if (status === 'Attended') { cellClass = 'present'; symbol = 'P'; }
                                else if (status === 'Skipped') { cellClass = 'absent'; symbol = 'A'; }
                                else if (status === 'Cancelled') { cellClass = 'cancelled'; symbol = 'C'; }
                                else if (status === 'Duty Leave (OD)') { cellClass = 'od'; symbol = 'OD'; }
                                else if (status === 'Medical Leave (ML)') { cellClass = 'ml'; symbol = 'ML'; }

                                // Glow effect using subject color, box color based on status
                                const glowColor = subjectColor ? subjectColor.glow : '#667eea';
                                const glowStyle = `box-shadow: 0 0 8px 2px ${glowColor}40, inset 0 0 0 2px ${glowColor};`;

                                // Use editKey if available (new logic), otherwise fallback to code
                                const codeToUse = period.editKey || period.code;
                                const safeName = period.name.replace(/'/g, "\\'");

                                modalHTML += `<div class="period-cell ${cellClass}" 
                                    style="${glowStyle}"
                                    data-date="${dateStr}" 
                                    data-code="${codeToUse}"
                                    data-period="${p}"
                                    title="${period.name} | ${status}"
                                    onclick="openPeriodEditPopup(event, '${dateStr}', '${codeToUse}', '${safeName}')">${symbol}</div>`;
                            } else {
                                modalHTML += `<div class="period-cell no-class">-</div>`;
                            }
                        }
                        modalHTML += `</div>`;
                    });

                    modalHTML += `</div></div></div></div>`;
                });

                modalHTML += `</div></div>`;

                document.getElementById('periodAttendanceModal').innerHTML = modalHTML;
                document.getElementById('periodAttendanceModal').classList.add('active');
            }

            // Toggle month collapse
            function togglePeriodMonth(header) {
                header.closest('.period-month-section').classList.toggle('collapsed');
            }

            // Open edit popup for a period cell
            function openPeriodEditPopup(event, dateStr, code, subjectName) {
                event.stopPropagation();

                // Remove existing popup
                const existingPopup = document.querySelector('.period-edit-popup');
                if (existingPopup) existingPopup.remove();

                const popup = document.createElement('div');
                popup.className = 'period-edit-popup';
                popup.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid var(--border-color);">
                        ${subjectName}<br>
                        <small style="color: var(--medium-text);">${dateStr}</small>
                    </div>
                    <button style="background: #4CAF50; color: white;" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Attended')">✓ Attended</button>
                    <button style="background: #f44336; color: white;" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Skipped')">✗ Skipped</button>
                    <button style="background: #9e9e9e; color: white;" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Cancelled')">⨯ Cancelled</button>
                    <button style="background: #2196F3; color: white;" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Duty Leave (OD)')">📋 Duty Leave</button>
                    <button style="background: #FF9800; color: white;" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Medical Leave (ML)')">🏥 Medical Leave</button>
                    <button style="background: var(--light-bg); color: var(--dark-text);" onclick="updatePeriodStatus('${dateStr}', '${code}', 'Default')">↺ Default</button>
                `;

                document.body.appendChild(popup);
                popup.style.display = 'block';

                // Position near click
                const rect = event.target.getBoundingClientRect();
                popup.style.left = Math.min(rect.left, window.innerWidth - 200) + 'px';
                popup.style.top = Math.min(rect.bottom + 5, window.innerHeight - 250) + 'px';

                // Close on outside click
                setTimeout(() => {
                    document.addEventListener('click', closePeriodPopup, { once: true });
                }, 100);
            }

            function closePeriodPopup() {
                const popup = document.querySelector('.period-edit-popup');
                if (popup) popup.remove();
            }

            // Update attendance status for a period (synced with attendance history)
            function updatePeriodStatus(dateStr, code, status) {
                closePeriodPopup();

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};

                if (!logs[dateStr]) {
                    logs[dateStr] = {};
                }

                // Get all subjects scheduled for this day from selectedClass.subjects
                const date = new Date(dateStr);
                const dayOfWeek = date.getDay();
                const scheduleIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                // Get ALL subject codes that have classes on this day (not just from timetable arrangement)
                const allSubjectCodes = [];
                if (selectedClass?.subjects) {
                    selectedClass.subjects.forEach(subject => {
                        // Check if subject has any periods on this day
                        if (subject.schedule && subject.schedule[scheduleIndex] > 0) {
                            allSubjectCodes.push(subject.code);
                        }
                    });
                }

                // Fallback to timetable arrangement if no subjects found
                if (allSubjectCodes.length === 0) {
                    const todaySubjects = getTimetableForDay(scheduleIndex);
                    todaySubjects.forEach(s => {
                        if (!allSubjectCodes.includes(s.code)) {
                            allSubjectCodes.push(s.code);
                        }
                    });
                }

                const currentDayLog = logs[dateStr] || {};
                const currentSubjectStatus = currentDayLog[code];

                // Check if this subject is currently ML
                const isCurrentSubjectML = currentSubjectStatus === 'Medical Leave (ML)';

                // Check if any subject is ML
                const hasAnyML = allSubjectCodes.some(subCode =>
                    currentDayLog[subCode] === 'Medical Leave (ML)'
                );

                // ML SYNC LOGIC: If setting ML, mark ALL subjects as ML
                if (status === 'Medical Leave (ML)') {
                    allSubjectCodes.forEach(subCode => {
                        logs[dateStr][subCode] = 'Medical Leave (ML)';
                    });
                    localStorage.setItem('attendance_logs', JSON.stringify(logs));
                    alert("Medical Leave (ML) selected.\n\nAll subjects for this day have been marked as ML.");
                    refreshPeriodAndHistoryViews();
                    return;
                }

                // If changing FROM ML to something else - reset all and prompt
                if (isCurrentSubjectML && status !== 'Medical Leave (ML)') {
                    // Reset all subjects to Default (delete their entries)
                    allSubjectCodes.forEach(subCode => {
                        delete logs[dateStr][subCode];
                    });

                    // Clean up empty date
                    if (Object.keys(logs[dateStr]).length === 0) {
                        delete logs[dateStr];
                    }

                    localStorage.setItem('attendance_logs', JSON.stringify(logs));

                    alert("ML removed from this day.\n\nAll subjects have been reset to 'Not Logged'.\nPlease mark attendance for each subject individually.");

                    refreshPeriodAndHistoryViews();
                    return;
                }

                // Check if OTHER subjects are still ML - prevent mixing
                const hasOtherML = allSubjectCodes.some(subCode =>
                    subCode !== code && currentDayLog[subCode] === 'Medical Leave (ML)'
                );

                if (hasOtherML && status !== 'Default') {
                    alert("Cannot mix 'Medical Leave (ML)' with other statuses.\n\nAll subjects for this day are on ML. To edit, first click any cell and change to 'Default' to reset the day.");
                    return;
                }

                // Normal status update
                if (status === 'Default') {
                    delete logs[dateStr][code];
                    if (Object.keys(logs[dateStr]).length === 0) {
                        delete logs[dateStr];
                    }
                } else {
                    logs[dateStr][code] = status;
                }

                localStorage.setItem('attendance_logs', JSON.stringify(logs));

                // Refresh all views
                refreshPeriodAndHistoryViews();
            }

            // Helper function to refresh both period-wise and history views
            function refreshPeriodAndHistoryViews() {
                // Refresh the period modal
                openPeriodAttendanceModal();

                // Also refresh portal dashboard if visible
                if (selectedClass?.portalSetup?.active) {
                    calculateFromPortal();
                }

                // Refresh history modal if it's open (keep both views in sync)
                const historyModal = document.getElementById('historyLogModal');
                if (historyModal && historyModal.classList.contains('active')) {
                    openHistoryEditor();
                }
            }

            // Update period view menu visibility based on portal mode
            function updatePeriodViewMenuVisibility() {
                const menuItem = document.getElementById('periodViewMenuItem');
                if (menuItem) {
                    if (selectedClass?.portalSetup?.active) {
                        menuItem.style.display = 'block';
                    } else {
                        menuItem.style.display = 'none';
                    }
                }
            }

            // ==================== END PERIOD-WISE ATTENDANCE VIEW ====================

            function openHistoryEditor() {
                // Clean up any holiday logs before displaying
                cleanupHolidayLogs();

                const logs = JSON.parse(localStorage.getItem('attendance_logs')) || {};
                const sortedDates = Object.keys(logs).sort((a, b) => new Date(b) - new Date(a));
                const missingDates = getMissingLogDates();

                const modal = document.getElementById('historyLogModal');
                let html = `
                <div class="modal-content">
                    <button class="modal-close" onclick="closeModal('historyLogModal')">&times;</button>
                    <div class="modal-header"><h2>📜 Attendance History</h2><p>View and edit your past daily logs.</p></div>`;

                // Portal Status Section (only show if portal is active)
                if (selectedClass?.portalSetup?.active && selectedClass?.portalSetup?.semesterStartDate) {
                    const statusColor = missingDates.length === 0 ? 'var(--success-grad-start)' : 'var(--warning-color)';
                    const statusIcon = missingDates.length === 0 ? '✅' : '⚠️';

                    html += `
                <div class="settings-section" style="border-left: 5px solid ${statusColor}; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">${statusIcon} Portal Status</h3>
                        <p style="margin-bottom: 10px;">
                            <strong>Missing Logs:</strong> 
                            <span style="color: ${statusColor}; font-size: 1.2rem; font-weight: bold;">${missingDates.length}</span> 
                            ${missingDates.length === 1 ? 'date' : 'dates'}
                        </p>`;

                    if (missingDates.length > 0) {
                        html += `
                            <p style="color: var(--medium-text); font-size: 0.9rem; margin-bottom: 15px;" >
                            💡 <strong>Tip:</strong> Complete your logs from the semester start date to improve Medical Leave recommendations.
                        </p>
                            <div style="max-height: 150px; overflow-y: auto; background: var(--light-bg); padding: 10px; border-radius: 8px; margin-bottom: 15px;">
                                <strong style="display: block; margin-bottom: 8px;">Missing Dates:</strong>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">`;

                        // Show up to 10 most recent missing dates
                        const recentMissing = missingDates.slice(-10).reverse();
                        recentMissing.forEach(date => {
                            html += `<button class="btn secondary-btn" onclick="addLogForDate('${date}')" style="padding: 5px 10px; font-size: 0.8rem;">${date}</button>`;
                        });

                        if (missingDates.length > 10) {
                            html += `<span style="color: var(--medium-text); font-size: 0.85rem; align-self: center;">...and ${missingDates.length - 10} more</span>`;
                        }

                        html += `
                                </div>
                            </div>`;
                    } else {
                        html += `<p style="color: var(--success-grad-start); font-weight: bold;">🎉 All dates are logged! Great job!</p>`;
                    }

                    html += `</div>`;
                }

                html += `
                <div class="form-group">
                        <label>Jump to Date:</label>
                        <input type="date" id="historyDateFilter" onchange="filterHistoryDate(this.value)" 
                               min="${selectedClass.portalSetup?.semesterStartDate || ''}" 
                               max="${formatLocalDate(new Date())}">
                    </div>

                    <div id="historyListContainer" style="max-height: 400px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--light-bg); text-align: left;">
                                    <th style="padding: 10px; border-bottom: 2px solid var(--border-color);">Date</th>
                                    <th style="padding: 10px; border-bottom: 2px solid var(--border-color);">Status</th>
                                    <th style="padding: 10px; border-bottom: 2px solid var(--border-color);">Action</th>
                                </tr>
                            </thead>
                            <tbody id="historyTableBody">`;

                html += renderHistoryRows(sortedDates, logs);

                html += `</tbody>
                        </table>
                    </div>
                </div>`;

                modal.innerHTML = html;
                modal.classList.add('active');
            }

            function renderHistoryRows(dates, logs) {
                if (dates.length === 0) {
                    return `<tr><td colspan="3" style="padding: 20px; text-align: center;">No logs found.</td></tr>`;
                }
                return dates.map(date => {
                    const dayLog = logs[date];
                    const summary = Object.entries(dayLog).map(([code, status]) => {
                        // Shorten status for display
                        let shortStatus = status;
                        if (status === 'Medical Leave (ML)') shortStatus = 'ML';
                        if (status === 'Duty Leave (OD)') shortStatus = 'OD';
                        return `${code}: ${shortStatus} `;
                    }).join(', ');

                    return `
                            <tr id="history-row-${date}" style="border-bottom: 1px solid var(--border-color);" >
                        <td style="padding: 10px;">${date}</td>
                        <td style="padding: 10px; font-size: 0.9rem; color: var(--medium-text);">${summary.substring(0, 50)}${summary.length > 50 ? '...' : ''}</td>
                        <td style="padding: 10px;">
                            <button class="btn secondary-btn" style="padding: 5px 10px; font-size: 0.8rem;" onclick="editLogDate('${date}')">Edit</button>
                        </td>
                    </tr>`;
                }).join('');
            }



            function editLogDate(dateStr) {
                closeModal('historyLogModal');
                document.getElementById('logDate').value = dateStr;
                populateDailyLog();
                document.getElementById('dailyLogModal').classList.add('active');
            }



        </script>
        <!-- Share Class Modal -->
        <div id="shareClassModal" class="modal">
            <div class="modal-content" style="text-align: center;">
                <button class="modal-close" onclick="closeModal('shareClassModal')">&times;</button>
                <div class="modal-header">
                    <h2>📤 Share Class</h2>
                    <p>Scan this QR code to import this class setup on another device.</p>
                </div>
                <div id="qrcode" style="display: inline-block; padding: 20px; background: white; margin: 20px 0;">
                </div>
                <p style="font-size: 0.9rem; color: var(--medium-text); margin-bottom: 20px;">Includes subjects and
                    holidays. Does not include your personal attendance logs.</p>

                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn success-btn" onclick="shareQRImage()">📱 Share via App</button>
                    <button class="btn secondary-btn" onclick="downloadQRImage()">⬇️ Download QR</button>
                </div>
            </div>
        </div>

        <!-- Scan Class Modal -->
        <div id="scanClassModal" class="modal">
            <div class="modal-content">
                <button class="modal-close" onclick="closeScanModal()">&times;</button>
                <div class="modal-header">
                    <h2>📷 Scan Class QR</h2>
                    <p>Point your camera at a class QR code OR upload a QR image.</p>
                </div>

                <!-- File Upload Option -->
                <div style="margin-bottom: 20px; text-align: center;">
                    <input type="file" id="qrInputFile" accept="image/*" style="display: none;"
                        onchange="handleQRFileUploadInTab(this)">
                    <button class="btn secondary-btn" onclick="document.getElementById('qrInputFile').click()">📂
                        Upload
                        QR
                        Image</button>
                </div>

                <script>
                    // ========== HYBRID OCR SYSTEM ==========

                    // Gemini API Key - Uses personal key or backend proxy
                    // Get your own key from: https://aistudio.google.com/app/apikey
                    const GEMINI_API_KEY = localStorage.getItem('personalGeminiKey') || '';
                    const GEMINI_DAILY_LIMIT = 10000;


                    // Test shared API key (for debugging)
                    async function testSharedAPIKey() {
                        console.log('🧪 Testing Shared Gemini API Key...');
                        console.log('🔑 Key:', GEMINI_API_KEY);

                        try {
                            // First, list available models to see what's valid
                            console.log('📋 Listing available models...');
                            const listResponse = await
                                fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${GEMINI_API_KEY}`);

                            if (listResponse.ok) {
                                const listData = await listResponse.json();
                                console.log('✅ Available Models:', listData);
                                const flashModel = listData.models?.find(m => m.name.includes('flash'));
                                if (flashModel) {
                                    console.log('✨ Found Flash Model:', flashModel.name);
                                } else {
                                    console.warn('⚠️ No "flash" model found in list!');
                                }
                            } else {
                                console.error('❌ Failed to list models:', await listResponse.text());
                            }

                            // Now try the generation
                            const response = await
                                fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`,
                                    {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            contents: [{ parts: [{ text: 'Hello, please respond with "Success"' }] }]
                                        })
                                    });

                            console.log('📡 Generate Response Status:', response.status);

                            if (response.ok) {
                                const data = await response.json();
                                console.log('✅ API Test SUCCESS!', data);
                                alert('✅ Shared API Key is working!\n\nGemini API is functional.');
                                return true;
                            } else {
                                const errorText = await response.text();
                                console.error('❌ API Test FAILED:', errorText);
                                alert(`❌ API Key Error: ${response.status}\n\n${errorText}\n\nCheck console for available models.`);
                                return false;
                            }
                        } catch (error) {
                            console.error('❌ API Test Exception:', error);
                            alert(`❌ Network/API Error:\n${error.message}`);
                            return false;
                        }
                    }

                    // Make testSharedAPIKey available globally for console testing
                    window.testSharedAPIKey = testSharedAPIKey;

                    // === QUOTA TRACKING (Updated for Personal Keys) ===
                    function getGeminiQuota(type = 'shared') {
                        const quotaData = JSON.parse(localStorage.getItem(`geminiQuota_${type}`) || '{}');
                        const today = new Date().toDateString();

                        if (quotaData.date !== today) {
                            // New day, reset quota
                            return { date: today, count: 0, limit: GEMINI_DAILY_LIMIT };
                        }

                        return quotaData;
                    }

                    function incrementGeminiQuota(type = 'shared') {
                        const quota = getGeminiQuota(type);
                        quota.count += 1;
                        localStorage.setItem(`geminiQuota_${type}`, JSON.stringify(quota));
                        console.log(`📊 ${type} quota: ${quota.count}/${quota.limit}`);
                        return quota;
                    }

                    function hasGeminiQuotaRemaining(type = 'shared', apiKey = null) {
                        if (!apiKey || apiKey === 'YOUR_GEMINI_API_KEY_HERE') {
                            console.log(`⚠️ No ${type} API key configured`);
                            return false;
                        }
                        const quota = getGeminiQuota(type);
                        return quota.count < quota.limit;
                    }

                    // === GEMINI API PROCESSOR ===
                    async function processImageWithGemini(imageFile, apiKey) {
                        console.log('🤖 Processing with Gemini API...');

                        // Convert image to base64
                        const base64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                const base64data = reader.result.split(',')[1];
                                resolve(base64data);
                            };
                            reader.readAsDataURL(imageFile);
                        });

                        // Construct subject list for context
                        let subjectContext = "";
                        if (selectedClass && selectedClass.subjects) {
                            subjectContext = selectedClass.subjects.map(s => `- "${s.code}": ${s.name}`).join('\n');
                        }

                        const prompt = `Analyze this university/college attendance screenshot and extract the attendance
                    data.

                    CONTEXT - The student is enrolled in these specific subjects:
                    ${subjectContext}

                    IMPORTANT: Return ONLY a valid JSON object in this exact format (no markdown, no explanations):
                    {
                    "SUBJECT-CODE-1": { "total": 50, "present": 45 },
                    "SUBJECT-CODE-2": { "total": 48, "present": 40 }
                    }

                    Rules:
                    1. Keys MUST be the exact subject codes from the list above.
                    2. "total" = total classes held
                    3. "present" = classes attended
                    4. If a subject code in the image is slightly different (e.g., missing a letter), map it to the
                    closest matching code from the list above.
                    5. Return ONLY the JSON, nothing else`;

                        const response = await
                            fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{
                                            parts: [
                                                { text: prompt },
                                                {
                                                    inline_data: {
                                                        mime_type: imageFile.type,
                                                        data: base64
                                                    }
                                                }
                                            ]
                                        }]
                                    })
                                });

                        console.log('📡 Gemini API Response Status:', response.status);

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('❌ Gemini API Error Response:', errorText);

                            // Check for common errors
                            if (response.status === 400) {
                                throw new Error(`Invalid API request. Check if API key is correct.`);
                            } else if (response.status === 403) {
                                throw new Error(`API key denied. Please verify your key at Google AI Studio.`);
                            } else if (response.status === 429) {
                                console.warn('⚠️ Gemini Quota Exceeded (429)');
                                throw new Error(`Quota exceeded. Daily limit: 10,000 requests.`);
                            } else {
                                throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
                            }
                        }

                        const data = await response.json();
                        console.log('📦 Gemini API Raw Response:', data);

                        // Check if response has expected structure
                        if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                            console.error('❌ Unexpected response structure:', data);
                            throw new Error('Invalid response from Gemini API');
                        }

                        const textResponse = data.candidates[0].content.parts[0].text;
                        console.log('📝 Gemini Text Response:', textResponse);

                        // Extract JSON from response (in case it's wrapped in markdown)
                        const jsonMatch = textResponse.match(/\{[\s\S]*\}/);
                        if (!jsonMatch) {
                            console.error('❌ No JSON found in response:', textResponse);
                            throw new Error('No JSON found in Gemini response');
                        }

                        const attendanceData = JSON.parse(jsonMatch[0]);
                        console.log('✅ Gemini extraction successful:', attendanceData);

                        return attendanceData;
                    }

                    // === TESSERACT FALLBACK ===
                    async function processImageWithTesseract(imageFile) {
                        console.log('📄 Processing with Tesseract (offline)...');

                        const { data: { text } } = await Tesseract.recognize(imageFile, 'eng', {
                            logger: m => console.log(m)
                        });

                        console.log('OCR Text:', text);

                        // Parse text to extract attendance data
                        const lines = text.split('\n').filter(line => line.trim());
                        const attendanceData = {};

                        // Simple parsing: look for patterns like "CODE 45/50" or "CODE 45 50"
                        for (const line of lines) {
                            // Pattern: SUBJECT-CODE followed by numbers
                            const match = line.match(/([A-Z0-9-]+)\s+(\d+)\s*[\/\s]\s*(\d+)/);
                            if (match) {
                                const [, code, present, total] = match;
                                attendanceData[code] = {
                                    total: parseInt(total),
                                    present: parseInt(present)
                                };
                            }
                        }

                        if (Object.keys(attendanceData).length === 0) {
                            throw new Error('Could not extract attendance data from text');
                        }

                        console.log('✅ Tesseract extraction successful:', attendanceData);
                        return attendanceData;
                    }

                    // === HYBRID PROCESSOR (Main Entry Point) - 3-Tier Fallback ===
                    async function processAttendanceImage(imageFile, showProgress = true) {
                        try {
                            // TIER 1: Try Personal Gemini API Key (if available)
                            const personalKey = localStorage.getItem('personalGeminiKey');
                            if (personalKey && hasGeminiQuotaRemaining('personal', personalKey)) {
                                const personalQuota = getGeminiQuota('personal');
                                if (showProgress) {
                                    console.log(`🤖 Processing with YOUR Gemini API (${personalQuota.count}/${personalQuota.limit}
                    today)...`);
                                }

                                try {
                                    const result = await processImageWithGemini(imageFile, personalKey);
                                    incrementGeminiQuota('personal');
                                    return { data: result, method: 'Your Gemini AI', success: true };
                                } catch (geminiError) {
                                    console.error('Personal Gemini failed:', geminiError);
                                    // Continue to Tier 2
                                }
                            }

                            // TIER 2: Try Shared Gemini API Key
                            // Always try shared key if personal key didn't work, unless explicitly out of quota
                            const sharedQuota = getGeminiQuota('shared');
                            const hasQuota = hasGeminiQuotaRemaining('shared', GEMINI_API_KEY);

                            console.log(`🤖 Checking Shared Gemini: Quota ${sharedQuota.count}/${sharedQuota.limit}, HasQuota:
                    ${hasQuota}`);

                            if (hasQuota) {
                                if (showProgress) {
                                    console.log(`🤖 Processing with Shared Gemini AI (${sharedQuota.count}/${sharedQuota.limit}
                    today)...`);
                                }

                                try {
                                    const result = await processImageWithGemini(imageFile, GEMINI_API_KEY);
                                    incrementGeminiQuota('shared');
                                    return { data: result, method: 'Shared Gemini AI', success: true };
                                } catch (geminiError) {
                                    console.error('❌ Shared Gemini failed:', geminiError);
                                    // Continue to Tier 3
                                }
                            } else {
                                console.warn('⚠️ Shared Gemini quota exceeded or key missing. Falling back to Tesseract.');
                            }

                            // TIER 3: Use Tesseract Fallback
                            if (showProgress) {
                                console.log('📄 Using offline OCR (Tesseract)...');
                            }

                            const result = await processImageWithTesseract(imageFile);
                            return { data: result, method: 'Offline OCR', success: true };

                        } catch (error) {
                            console.error('❌ ALL OCR methods failed:', error);

                            // Show error with option to add personal key
                            const personalKey = localStorage.getItem('personalGeminiKey');
                            if (!personalKey) {
                                const addKey = confirm(`❌ OCR Processing Failed\n\n${error.message}\n\nBoth shared AI quota and
                    offline OCR failed.\n\nWould you like to add your FREE personal Gemini API key?\n(10,000
                    requests/day, completely free)`);

                                if (addKey) {
                                    openOCRSettings();
                                }
                            } else {
                                // Call the portal error handler
                                showPortalImageError(error.message);
                            }

                            return { data: null, method: null, success: false, error: error.message };
                        }
                    }

                    // Portal Image Processing Error Handler
                    function showPortalImageError(errorMessage) {
                        const message = `❌ Unable to process attendance portal image.

                    ${errorMessage || 'The OCR model could not extract attendance data from your screenshot.'}

                    📸 Help us improve!
                    Please share your attendance portal screenshot with the developer so we can train the OCR model for
                    your college/school portal.

                    Would you like to contact the developer now via WhatsApp?`;

                        const userWantsToContact = confirm(message);

                        if (userWantsToContact) {
                            // Open WhatsApp chat with developer
                            const whatsappUrl =
                                'https://wa.me/916386854875?text=Hi!%20I%20need%20help%20with%20OCR%20processing%20in%20Bunk%20it%20app.%20My%20portal%20screenshot%20could%20not%20be%20processed.';
                            window.open(whatsappUrl, '_blank', 'noopener,noreferrer');
                        }

                        // Optional: Auto-highlight WhatsApp button temporarily
                        const whatsappBtn = document.querySelector('.whatsapp-float');
                        if (whatsappBtn) {
                            whatsappBtn.style.animation = 'pulse 2s 3';
                            setTimeout(() => {
                                whatsappBtn.style.animation = '';
                            }, 6000);
                        }
                    }
                    // === AI CLASS IMPORT FEATURE ===

                    function updateAIFileCount(input) {
                        const count = input.files.length;
                        const display = document.getElementById('aiFileCount');
                        if (count > 0) {
                            display.textContent = `✅ ${count} file(s) selected`;
                        } else {
                            display.textContent = '';
                        }
                    }

                    async function handleAIClassImport() {
                        const fileInput = document.getElementById('aiImportFiles');
                        const textInput = document.getElementById('aiImportText').value;
                        const loadingDiv = document.getElementById('aiImportLoading');

                        if (fileInput.files.length === 0 && !textInput.trim()) {
                            alert("Please upload a file or enter some text details.");
                            return;
                        }

                        loadingDiv.style.display = 'block';

                        try {
                            // 1. Prepare Images
                            const imageParts = [];
                            for (const file of fileInput.files) {
                                const base64 = await new Promise((resolve) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                                    reader.readAsDataURL(file);
                                });
                                imageParts.push({
                                    inlineData: {
                                        data: base64,
                                        mimeType: file.type
                                    }
                                });
                            }

                            // 2. Prepare Prompt
                            const promptText = `
                    Analyze the attached images (timetable, attendance screenshot, etc.) and the text below to extract
                    class details.

                    USER NOTES: "${textInput}"

                    IMPORTANT: Return ONLY a valid JSON object in this exact format:
                    {
                    "className": "Extracted Class Name",
                    "lastDate": "YYYY-MM-DD",
                    "holidays": ["YYYY-MM-DD", "YYYY-MM-DD"],
                    "subjects": [
                    {
                    "name": "Subject Name",
                    "code": "Subject Code",
                    "schedule": [0, 1, 0, 2, 0, 0, 0]
                    }
                    ]
                    }

                    Rules:
                    1. "schedule": Array of 7 integers (Monday to Sunday). Each number is the count of classes for that
                    subject on that day.
                    2. "lastDate": If not found, estimate end of current semester (e.g., Dec 20 or May 20).
                    3. "holidays": Extract any specific dates mentioned.
                    4. "subjects": Extract all subjects found in timetable or attendance list.
                    5. **IMPORTANT**: Only include subjects that are VISIBLE in the attendance detail screenshot. Do NOT add subjects that are not present in the image.
                    6. Return ONLY JSON.
                    `;

                            // 3. Call Gemini API
                            // Use personal key if available, else shared key
                            const personalKey = localStorage.getItem('personalGeminiKey');
                            const apiKey = (personalKey && hasGeminiQuotaRemaining('personal', personalKey)) ? personalKey :
                                GEMINI_API_KEY;

                            const requestBody = {
                                contents: [{
                                    parts: [
                                        { text: promptText },
                                        ...imageParts
                                    ]
                                }]
                            };

                            const response = await
                                fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                                    {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(requestBody)
                                    });

                            const data = await response.json();

                            if (!response.ok) throw new Error(data.error?.message || 'API Error');

                            const textResponse = data.candidates[0].content.parts[0].text;
                            const jsonMatch = textResponse.match(/\{[\s\S]*\}/);

                            if (!jsonMatch) throw new Error("Could not parse JSON from AI response.");

                            const classData = JSON.parse(jsonMatch[0]);

                            // 4. Populate Form
                            populateClassFormFromJSON(classData);

                            // 5. Switch to Form Tab & Notify
                            loadingDiv.style.display = 'none';
                            switchModalTab('form');
                            alert("✨ Class Setup Generated!\\n\\nPlease VERIFY the 'Weekly Schedule' for each subject carefully before saving.");

                        } catch (error) {
                            console.error("AI Import Error:", error);
                            loadingDiv.style.display = 'none';
                            alert(`AI Import Failed: ${error.message}`);
                        }
                    }

                    function populateClassFormFromJSON(data) {
                        if (data.className) document.getElementById('newClassName').value = data.className;
                        if (data.lastDate) document.getElementById('newClassLastDate').value = data.lastDate;

                        // Clear existing subjects
                        document.getElementById('subjectsContainer').innerHTML = '';

                        if (data.subjects && Array.isArray(data.subjects)) {
                            data.subjects.forEach(sub => {
                                addSubjectEntry({ name: sub.name, code: sub.code, schedule: sub.schedule });
                            });
                        }

                        // Add holidays
                        const holidayList = document.getElementById('holidayList');
                        holidayList.innerHTML = ''; // Clear existing
                        if (data.holidays && Array.isArray(data.holidays)) {
                            data.holidays.forEach(date => {
                                const li = document.createElement('li');
                                li.innerHTML = `${formatDate(date)} <span class="remove-holiday"
                        onclick="this.parentElement.remove()">×</span>`;
                                li.dataset.date = date;
                                holidayList.appendChild(li);
                            });
                        }
                    }

                    // === CHATBOT API - Uses Backend Proxy ===
                    // Chatbot now uses backend proxy with key rotation
                    // Personal key takes priority if set

                    // Stub functions for backward compatibility
                    function getExhaustedChatbotKeys() {
                        return { date: new Date().toDateString(), keys: [] };
                    }

                    function markChatbotKeyExhausted(keyIndex) {
                        console.log('Chatbot keys handled by backend proxy');
                    }

                    function getNextAvailableChatbotKey() {
                        // Backend proxy handles all shared key rotation
                        return { key: null, index: -1, useProxy: true };
                    }

                    // Key is now loaded from js/env-config.js (generated at build time)
                    // If file is missing (dev mode), window.SHARED_CHATBOT_KEY will be undefined.



                    // === AI CHATBOT FUNCTIONS ===

                    // Check if personal API key exists and show/hide chatbot button
                    function toggleChatbotVisibility() {
                        // Always show chatbot - everyone gets 10 questions/day with shared key
                        const chatbotBtn = document.getElementById('aiChatbotButton');
                        if (chatbotBtn) {
                            chatbotBtn.style.display = 'flex';
                        }
                    }

                    // Call on page load
                    window.addEventListener('load', toggleChatbotVisibility);

                    // Open AI Chatbot (closes all modals first during onboarding)
                    window.openAIChatbot = function () {
                        try {
                            // Remove glow from bot icon and HIDE it
                            const botBtn = document.getElementById('aiChatbotButton');
                            if (botBtn) {
                                botBtn.classList.remove('glowing-pulse');
                                botBtn.style.display = 'none';  // Hide when panel opens
                            }

                            // Close any bunkmate tutorial cloud messages (Priority)
                            const tutorialOverlay = document.getElementById('bunkmateTutorialOverlay');
                            if (tutorialOverlay) tutorialOverlay.remove();

                            // Close onboarding/other modals
                            const onboardingModal = document.getElementById('onboardingClassModal');
                            if (onboardingModal && onboardingModal.classList.contains('active') && typeof closeModal === 'function') {
                                closeModal('onboardingClassModal');
                            }

                            document.querySelectorAll('.modal.active').forEach(modal => {
                                modal.classList.remove('active');
                            });

                            // Open chatbot panel - FORCE visibility with inline styles
                            const panel = document.getElementById('aiChatPanel');
                            if (panel) {
                                panel.classList.add('active');
                                panel.style.right = '0';
                                panel.style.display = 'flex';
                                panel.style.zIndex = '2147483647';
                            }

                            // Show backdrop overlay to block background interactions
                            const backdrop = document.getElementById('appBackdrop');
                            if (backdrop) {
                                backdrop.classList.add('active');
                            }
                            document.body.classList.add('backdrop-active');
                        } catch (err) {
                            console.error('Error opening chatbot:', err);
                            // Fallback: force open the panel
                            const panel = document.getElementById('aiChatPanel');
                            if (panel) {
                                panel.classList.add('active');
                                panel.style.right = '0';
                                panel.style.display = 'flex';
                                panel.style.zIndex = '2147483647';
                            }
                        }
                    }

                    // Close AI Chatbot
                    function closeAIChatbot() {
                        const panel = document.getElementById('aiChatPanel');
                        if (panel) {
                            panel.classList.remove('active');
                            panel.style.right = '';  // Reset to CSS default
                            panel.style.zIndex = '';  // Reset to CSS default
                        }
                        // Show the floating button again
                        const botBtn = document.getElementById('aiChatbotButton');
                        if (botBtn) botBtn.style.display = 'flex';

                        // Hide backdrop overlay
                        const backdrop = document.getElementById('appBackdrop');
                        if (backdrop) {
                            backdrop.classList.remove('active');
                        }
                        document.body.classList.remove('backdrop-active');
                    }

                    // Close all panels (called when backdrop is clicked)
                    function closeAllPanels() {
                        // Close chatbot
                        closeAIChatbot();

                        // Close side navigation
                        if (typeof closeNav === 'function') {
                            closeNav();
                        }

                        // Close all modals
                        document.querySelectorAll('.modal.active').forEach(modal => {
                            modal.classList.remove('active');
                        });

                        // Hide backdrop
                        const backdrop = document.getElementById('appBackdrop');
                        if (backdrop) {
                            backdrop.classList.remove('active');
                        }
                        document.body.classList.remove('backdrop-active');
                    }

                    // Expose chatbot functions globally for onclick handlers
                    window.openAIChatbot = openAIChatbot;
                    window.closeAIChatbot = closeAIChatbot;
                    window.closeAllPanels = closeAllPanels;

                    // Add direct event listener for bot icon (works even after DOM move)
                    // Uses both getElementById and stored reference for reliability
                    document.addEventListener('click', function (e) {
                        // Try stored reference first (guaranteed to be the visible one)
                        const botBtn = window._bunkmateBot || document.getElementById('aiChatbotButton');
                        if (!botBtn) return;

                        // Get bot button position and check if click is within its bounds
                        const rect = botBtn.getBoundingClientRect();
                        const clickX = e.clientX;
                        const clickY = e.clientY;

                        // Skip if rect has no size (element not visible/positioned)
                        if (rect.width === 0 || rect.height === 0) {
                            return;
                        }

                        const isWithinBotBtn = (
                            clickX >= rect.left &&
                            clickX <= rect.right &&
                            clickY >= rect.top &&
                            clickY <= rect.bottom
                        );

                        if (isWithinBotBtn) {
                            e.preventDefault();
                            e.stopPropagation();
                            openAIChatbot();
                        }
                    }, true);

                    // Ask FAQ question
                    function askFAQ(question) {
                        const input = document.getElementById('chatInput');
                        input.value = question;
                        sendChatMessage();
                    }

                    // Send chat message
                    // Send chat message
                    async function sendChatMessage() {
                        console.log("Submit button clicked");
                        let input = document.getElementById('chatInput');
                        if (!input) input = document.getElementById('aiChatInput'); // Try alternate ID
                        if (!input) input = document.querySelector('.chat-input-container input'); // Try class selector

                        if (!input) {
                            console.error("Chat input not found! Check IDs.");
                            alert("Error: Chat input field not found. Please reload.");
                            return;
                        }

                        const message = input.value.trim();
                        console.log("Sending message:", message);

                        if (!message) return;

                        // Add user message to chat
                        addChatMessage(message, 'user');
                        input.value = '';

                        // Show thinking indicator
                        addChatMessage('Thinking...', 'system');

                        try {
                            // Get AI response
                            const response = await getAIResponse(message);

                            // Remove thinking indicator
                            removeLastSystemMessage();

                            // Add AI response
                            addChatMessage(response, 'bot');
                        } catch (error) {
                            removeLastSystemMessage();
                            addChatMessage('Sorry, I encountered an error. Please try again.', 'bot');
                            console.error('Chat error:', error);
                        }

                        // Scroll to bottom
                        scrollChatToBottom();
                    }

                    // Send AI chat message (from AI Chat Panel with separate input)
                    async function sendAIChatMessage() {
                        const aiInput = document.getElementById('aiChatInput');
                        const chatInput = document.getElementById('chatInput');

                        // Copy value to main chatInput for the existing function to use
                        if (aiInput && chatInput) {
                            chatInput.value = aiInput.value;
                            aiInput.value = '';
                        }

                        // Call the existing function
                        sendChatMessage();
                    }

                    // Add message to chat
                    function addChatMessage(text, type) {
                        const messagesDiv = document.getElementById('chatMessages');
                        const messageDiv = document.createElement('div');
                        messageDiv.className = `chat-message ${type}`;
                        messageDiv.textContent = text;
                        messagesDiv.appendChild(messageDiv);
                    }

                    // Remove last system message
                    function removeLastSystemMessage() {
                        const messagesDiv = document.getElementById('chatMessages');
                        const systemMessages = messagesDiv.querySelectorAll('.chat-message.system');
                        if (systemMessages.length > 1) {
                            systemMessages[systemMessages.length - 1].remove();
                        }
                    }

                    // Scroll chat to bottom
                    function scrollChatToBottom() {
                        const messagesDiv = document.getElementById('chatMessages');
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    }

                    // Expose chatbot functions globally for onclick handlers
                    window.sendChatMessage = sendChatMessage;
                    window.askFAQ = askFAQ;

                    // Shared key quota tracking (10 questions/day)
                    function getSharedQuota() {
                        const quotaData = JSON.parse(localStorage.getItem('sharedChatbotQuota') || '{}');
                        const today = new Date().toDateString();

                        if (quotaData.date !== today) {
                            return { date: today, count: 0, limit: 10 };
                        }
                        return quotaData;
                    }

                    function updateSharedQuota() {
                        const quota = getSharedQuota();
                        quota.count++;
                        localStorage.setItem('sharedChatbotQuota', JSON.stringify(quota));
                        return quota;
                    }

                    function hasSharedQuotaRemaining() {
                        const quota = getSharedQuota();
                        return quota.count < quota.limit;
                    }

                    // Get AI response using Gemini API (10 questions/day)
                    function getSharedQuota() {
                        const quotaData = JSON.parse(localStorage.getItem('sharedChatbotQuota') || '{}');
                        const today = new Date().toDateString();

                        if (quotaData.date !== today) {
                            return { date: today, count: 0, limit: 10 };
                        }
                        return quotaData;
                    }

                    function updateSharedQuota() {
                        const quota = getSharedQuota();
                        quota.count++;
                        localStorage.setItem('sharedChatbotQuota', JSON.stringify(quota));
                        return quota;
                    }

                    function hasSharedQuotaRemaining() {
                        const quota = getSharedQuota();
                        return quota.count < quota.limit;
                    }

                    // Get AI response using Gemini API (10 questions/day)
                    function getSharedQuota() {
                        const quotaData = JSON.parse(localStorage.getItem('sharedChatbotQuota') || '{}');
                        const today = new Date().toDateString();

                        if (quotaData.date !== today) {
                            return { date: today, count: 0, limit: 10 };
                        }
                        return quotaData;
                    }

                    function updateSharedQuota() {
                        const quota = getSharedQuota();
                        quota.count++;
                        localStorage.setItem('sharedChatbotQuota', JSON.stringify(quota));
                        return quota;
                    }

                    function hasSharedQuotaRemaining() {
                        const quota = getSharedQuota();
                        return quota.count < quota.limit;
                    }

                    // Shared key quota tracking (10 questions/day)
                    function getSharedQuota() {
                        const quotaData = JSON.parse(localStorage.getItem('sharedChatbotQuota') || '{}');
                        const today = new Date().toDateString();

                        if (quotaData.date !== today) {
                            return { date: today, count: 0, limit: 10 };
                        }
                        return quotaData;
                    }

                    function updateSharedQuota() {
                        const quota = getSharedQuota();
                        quota.count++;
                        localStorage.setItem('sharedChatbotQuota', JSON.stringify(quota));
                        return quota;
                    }

                    // Get AI response using Gemini API - Uses backend proxy with key rotation
                    async function getAIResponse(userQuestion) {
                        const personalKey = localStorage.getItem('personalGeminiKey');

                        // Get current date info
                        const today = new Date();
                        const todayStr = formatLocalDate(today);
                        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        const currentDayName = dayNames[today.getDay()];

                        // Get comprehensive user data
                        const attendanceLogs = JSON.parse(localStorage.getItem('attendance_logs') || '{}');
                        const notificationSettings = JSON.parse(localStorage.getItem('notificationSettings') || '{"enabled":true,"time":"16:30"}');
                        const className = document.getElementById('classSelector')?.value || '';

                        // Portal mode info
                        const portalSetup = selectedClass?.portalSetup || null;
                        const isPortalMode = portalSetup?.active === true;

                        // Today's schedule
                        const scheduleIndex = today.getDay() === 0 ? 6 : today.getDay() - 1;
                        let todaysClasses = [];
                        if (selectedClass?.subjects) {
                            selectedClass.subjects.forEach(sub => {
                                const classCount = sub.schedule?.[scheduleIndex] || 0;
                                if (classCount > 0) {
                                    todaysClasses.push({ name: sub.name, code: sub.code, periods: classCount });
                                }
                            });
                        }

                        // Check if today is a holiday
                        const isHoliday = selectedClass?.holidays?.includes(todayStr);
                        const loggedDays = Object.keys(attendanceLogs).length;
                        const todaysLog = attendanceLogs[todayStr];
                        const periodTimes = className ? JSON.parse(localStorage.getItem(`period_times_${className}`) || 'null') : null;

                        // Calculate total periods today
                        let totalTodayPeriods = 0;
                        todaysClasses.forEach(c => totalTodayPeriods += c.periods);

                        // Calculate overall attendance
                        let overallAttended = 0, overallTotal = 0;
                        currentAnalysisData?.forEach(a => {
                            overallAttended += a.attended || 0;
                            overallTotal += a.totalHeld || 0;
                        });
                        const overallPercent = overallTotal > 0 ? ((overallAttended / overallTotal) * 100).toFixed(1) : 0;

                        // Find subjects in danger (below minimum)
                        const minCriteria = parseFloat(document.getElementById('minAttendanceInput')?.value) || 75;
                        const subjectsInDanger = currentAnalysisData?.filter(a => {
                            const percent = a.totalHeld > 0 ? (a.attended / a.totalHeld) * 100 : 100;
                            return percent < minCriteria;
                        }).map(a => a.code) || [];

                        // Find subjects safe to skip
                        const subjectsSafeToSkip = currentAnalysisData?.filter(a => a.maxSkippable > 0)
                            .map(a => ({ code: a.code, canSkip: a.maxSkippable })) || [];

                        // Prepare comprehensive app context
                        const appContext = {
                            appName: "Bunk it - Smart Attendance Manager",
                            currentDate: todayStr,
                            currentDayName: currentDayName,
                            selectedClassName: className || 'None selected',
                            subjects: selectedClass?.subjects?.map(s => ({
                                name: s.name, code: s.code, schedule: s.schedule
                            })) || [],
                            currentAttendance: currentAnalysisData?.map(a => ({
                                code: a.code, name: a.name,
                                currentPercent: ((a.attended / a.totalHeld) * 100).toFixed(1),
                                attended: a.attended, totalHeld: a.totalHeld,
                                remaining: a.remaining, stillNeed: a.stillNeed, maxSkippable: a.maxSkippable
                            })) || [],
                            overallAttendance: { attended: overallAttended, total: overallTotal, percent: overallPercent },
                            subjectsInDanger: subjectsInDanger,
                            subjectsSafeToSkip: subjectsSafeToSkip,
                            minPercentage: minCriteria,
                            lastWorkingDate: selectedClass?.lastDate || 'Not set',
                            holidays: selectedClass?.holidays || [],
                            isHolidayToday: isHoliday,
                            portalMode: { active: isPortalMode, semesterStartDate: portalSetup?.semesterStartDate || null },
                            todaysClasses: isHoliday ? [] : todaysClasses,
                            totalTodayPeriods: isHoliday ? 0 : totalTodayPeriods,
                            periodTimes: periodTimes,
                            logs: { totalDays: loggedDays, todayLogged: !!todaysLog },
                            notifications: notificationSettings
                        };

                        // Comprehensive system prompt with ALL features
                        const systemPrompt = `You are "Bunkmate", the friendly AI assistant for "Bunk it - Smart Attendance Manager" app.

🔒 RULES:
1. Only answer questions about this app
2. Use provided data for personalized responses
3. LANGUAGE MATCHING: Match the user's language:
   - If user types in English → Reply in English
   - If user types in Hindi (हिंदी) → Reply in Hindi (हिंदी में जवाब दें)
   - If user types in Hinglish (mix of Hindi & English just like indian genz people type on whatsapp) → Reply in Hinglish (same style use karo)

📊 USER'S CURRENT DATA:
• Today: ${appContext.currentDate} (${appContext.currentDayName})
• Class: ${appContext.selectedClassName}
• Min Required: ${appContext.minPercentage}%
• Last Date: ${appContext.lastWorkingDate}
• Holiday Today: ${appContext.isHolidayToday ? 'YES!' : 'No'}
• Portal Mode: ${appContext.portalMode.active ? 'Active' : 'Inactive'}
• Today's Classes: ${appContext.isHolidayToday ? 'None (holiday)' : (appContext.todaysClasses.length > 0 ? JSON.stringify(appContext.todaysClasses) : 'None today')}
• Total Periods Today: ${appContext.totalTodayPeriods}
• Subjects: ${JSON.stringify(appContext.subjects.map(s => ({ name: s.name, code: s.code })))}
• Attendance: ${appContext.currentAttendance.length > 0 ? JSON.stringify(appContext.currentAttendance) : 'Not calculated yet'}
• Overall Attendance: ${appContext.overallAttendance.percent}% (${appContext.overallAttendance.attended}/${appContext.overallAttendance.total})
• Subjects in DANGER (below ${appContext.minPercentage}%): ${appContext.subjectsInDanger.length > 0 ? appContext.subjectsInDanger.join(', ') : 'None - all safe!'}
• Subjects SAFE to Skip: ${appContext.subjectsSafeToSkip.length > 0 ? JSON.stringify(appContext.subjectsSafeToSkip) : 'None - attend all!'}
• Total Holidays: ${appContext.holidays.length}
• Days Logged: ${appContext.logs.totalDays}
• Today Logged: ${appContext.logs.todayLogged ? 'Yes' : 'No'}
• Notifications: ${appContext.notifications.enabled ? 'On at ' + appContext.notifications.time : 'Off'}

📱 ALL APP FEATURES (explain when asked):

1️⃣ CLASS SETUP (4 methods):
• Form: Manual entry - Add Class → fill name, last date, subjects with schedules
• JSON: Paste JSON structure {"ClassName":{lastDate,holidays[],subjects[]}}
• AI Import: Upload timetable/attendance images → AI fills form automatically
• QR Scan: Scan classmate's QR to import their class setup

2️⃣ ATTENDANCE INPUT (3 methods):
• Image Upload: OCR extracts attendance from screenshots
• Manual Input: Enter total/attended per subject
• JSON Paste: {"CODE":{total,present}}

3️⃣ MODES:
• Portal Mode: Daily logging, ML recommendations, semester tracking (Settings → Portal Setup)
• Standard Mode: Quick one-time calculation without daily logs

4️⃣ LEAVE PLANNER:
• Add planned leave dates → see impact on attendance
• Compulsory events marking → warns about conflicts
• Medical Certificate recommendations → suggests optimal ML dates
• Max Safe Leave → shows days you can skip safely
• Long Weekend Finder → finds best leave strategy

5️⃣ TIMETABLE:
• Visual weekly schedule with drag-drop
• Period time configuration
• Current day highlighting with attendance status colors (green=safe, yellow=warning, red=danger)

6️⃣ NOTIFICATIONS:
• Daily reminders at custom time
• Only during semester period
• Enable in Settings → Notification Settings

7️⃣ ANALYSIS:
• Current %, Max possible %, Min possible %
• Still Need (must attend), Can Skip (safe to miss)
• Overall vs Per-Subject mode toggle

8️⃣ SETTINGS:
• Minimum attendance % (default 75%)
• Dark mode toggle
• API Settings for personal Gemini key
• Export/Backup class as JSON or QR

📊 MAX SAFE LEAVE FEATURE:
• Calculates exact dates you can skip entirely
• Considers your planned leaves + compulsory events
• Shows which subject is the bottleneck limiting safe leaves

🚫 MAX POSSIBLE BUNK (Avoid Detention):
• Calculates maximum skippable days at 65% DETENTION threshold (not 75%)
• Shows all dates you can bunk without getting detained
• MEDICAL CERTIFICATE SUGGESTIONS after bunking

🤔 CAN I SKIP TODAY? FEATURE:
• Quick check for today's impact
• Shows what happens if you skip all today's classes
• Per-subject impact analysis

👤 ABOUT THE DEVELOPER:
• Name: Faisal Khan
• Role: Solo Developer & Creator of Bunk it
• Buy Me a Coffee: https://buymeacoffee.com/Faisalkhan119
• The app is 100% free, ad-free, and open for donations

📝 RESPONSE FORMAT:
• Use numbered steps (1, 2, 3...) enter next line after every steps for how-to questions
• Use emojis for visual clarity
• Keep responses concise but helpful
• End with a helpful tip when relevant

🧠 SMART RESPONSES: When asked about skipping/leave, check their attendance data and give specific advice based on maxSkippable values and subject buffers.

Answer helpfully using this context.`;


                        try {
                            // Determine which keys to use
                            const keysToUse = [];
                            if (personalKey) {
                                // Priority 1: Personal Key (User entered in Settings)
                                keysToUse.push(...personalKey.split(',').map(k => k.trim()).filter(k => k));
                                console.log('🤖 Chatbot: Using Personal Key(s)');
                            } else if (window.SHARED_CHATBOT_KEY && window.SHARED_CHATBOT_KEY.length > 5) {
                                // Priority 2: Injected Shared Keys (From Build/Env)
                                keysToUse.push(...window.SHARED_CHATBOT_KEY.split(',').map(k => k.trim()).filter(k => k));
                                console.log('🤖 Chatbot: Using Injected Shared Keys');
                            } else {
                                // Priority 3: Fallback Shared Keys (Obfuscated)
                                // Decode base64 obfuscated keys
                                const obfuscatedKeys = [
                                    'QUl6YVN5Q1F6ck9yVG5NUjFlbGFlZUNNcmxubUttSzdnaGtxZXRv',
                                    'QUl6YVN5QjFxQk8xMzNHMnBoWVgwOVBTMFdPSjZ4WnFxY1Bydlo0'
                                ];
                                try {
                                    keysToUse.push(...obfuscatedKeys.map(k => atob(k)).filter(k => k.startsWith('AIza')));
                                    console.log('🤖 Chatbot: Using Fallback Shared Keys');
                                } catch (e) {
                                    console.error('Failed to decode fallback keys:', e);
                                }
                            }

                            if (keysToUse.length > 0) {
                                // === DIRECT API CALL WITH ROTATION ===
                                let lastError = null;

                                for (let i = 0; i < keysToUse.length; i++) {
                                    const currentKey = keysToUse[i];
                                    try {
                                        console.log(`🤖 Chatbot: Attempting key ${i + 1}/${keysToUse.length}`);

                                        response = await fetch(
                                            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${currentKey}`,
                                            {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({
                                                    contents: [{
                                                        parts: [
                                                            { text: systemPrompt },
                                                            { text: `User question: ${userQuestion}` }
                                                        ]
                                                    }]
                                                })
                                            }
                                        );

                                        if (response.ok) {
                                            console.log('🤖 Chatbot: Success!');
                                            const result = await response.json();
                                            return result.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I could not generate a response.';
                                        }

                                        // If Quota Exceeded (429), try next key
                                        if (response.status === 429) {
                                            console.warn(`🤖 Chatbot: Key ${i + 1} exhausted (429). Rotating...`);
                                            lastError = `Quota exceeded for key ${i + 1}`;
                                            continue;
                                        }

                                        // Other errors - throw immediately
                                        const errorData = await response.json().catch(() => ({}));
                                        throw new Error(`API Error ${response.status}: ${errorData.error?.message || 'Unknown'}`);

                                    } catch (err) {
                                        console.error(`🤖 Chatbot: Key ${i + 1} failed:`, err);
                                        lastError = err.message;
                                        // If last key, don't continue loop effectively, just fall through
                                    }
                                }

                                // If we get here, all keys failed
                                throw new Error(`All API keys failed. Last error: ${lastError}`);

                            } else {
                                // === FALLBACK: BACKEND PROXY ===
                                // Priority 3: Vercel Proxy (if no keys found in frontend)
                                console.log('🤖 Chatbot: Using backend proxy');
                                response = await fetch('/api/gemini', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'chat',
                                        systemPrompt: systemPrompt,
                                        prompt: `User question: ${userQuestion}`
                                    })
                                });

                                if (!response.ok) {
                                    const errorData = await response.json().catch(() => ({}));
                                    throw new Error(`Proxy Error ${response.status}: ${errorData.error || 'Unknown'}`);
                                }

                                const result = await response.json();
                                return result.candidates?.[0]?.content?.parts?.[0]?.text || 'Sorry, I could not generate a response.';
                            }

                        } catch (error) {
                            console.error('Gemini API error:', error);
                            return `❌ Connection Error: ${error.message}\n\nCheck your internet connection and try again.`;
                        }
                    }



                    // API Settings function (renamed from openOCRSettings)
                    // Test API key
                    async function testAPIKey() {
                        const key = document.getElementById('personalGeminiKey').value.trim();

                        if (!key) {
                            showToast('Please enter an API key first.', 'warning');
                            return;
                        }

                        try {
                            const response = await fetch(
                                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${key}`,
                                {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        contents: [{ parts: [{ text: 'Test' }] }]
                                    })
                                }
                            );

                            if (response.ok) {
                                showToast('API key is valid and working!', 'success');
                            } else if (response.status === 400) {
                                showToast('Invalid API key. Please check and try again.', 'error');
                            } else if (response.status === 429) {
                                showToast('API key is valid but quota exceeded.', 'warning');
                            } else {
                                showToast(`Error ${response.status}. Please try again.`, 'error');
                            }
                        } catch (error) {
                            showToast('Connection error. Please check your internet connection.', 'error');
                        }
                    }



                    // API Settings function (renamed from openOCRSettings)
                    function openAPISettings() {
                        const modal = document.getElementById('ocrSettingsModal');

                        // Populate the modal content
                        modal.innerHTML = `
                    <div class="modal-content">
                        <button class="modal-close" onclick="closeModal('ocrSettingsModal')">&times;</button>
                        <div class="modal-header">
                            <h2>🔑 API Settings</h2>
                            <p>Configure your Gemini API key for OCR and AI Assistant features</p>
                        </div>
                        <div class="form-group">
                            <label for="personalGeminiKey">Personal Gemini API Key:</label>
                            <input type="text" id="personalGeminiKey" placeholder="AIzaSy...">
                            <p style="font-size: 0.85rem; color: var(--medium-text); margin-top: 8px;">
                                💡 Your API key enables OCR scanning and AI chatbot features.
                            </p>
                        </div>

                        <div
                            style="background: var(--light-bg); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px; font-size: 1rem;">🔑 How to Get Free API Key:</h4>
                            <ol style="margin: 0; padding-left: 20px; color: var(--dark-text);">
                                <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank"
                                        rel="noopener noreferrer" style="color: var(--primary-grad-start);">Google AI
                                        Studio</a></li>
                                <li>Click <strong>"Get API Key"</strong> or <strong>"Create API Key"</strong></li>
                                <li>Copy the key (starts with <code>AIzaSy...</code>)</li>
                                <li>Paste it above and click <strong>Save</strong></li>
                            </ol>
                        </div>

                        <div class="form-actions">
                            <button class="btn primary-btn" onclick="saveAPISettings()">💾 Save Settings</button>
                            <button class="btn secondary-btn" onclick="testAPIKey()">🧪 Test My Key</button>
                        </div>
                    </div>
                    `;

                        // Load saved settings
                        const personalKey = localStorage.getItem('personalGeminiKey') || '';
                        setTimeout(() => {
                            const personalKeyInput = document.getElementById('personalGeminiKey');
                            if (personalKeyInput) {
                                personalKeyInput.value = personalKey;
                            }
                        }, 10);

                        openModal('ocrSettingsModal');
                    }

                    // Save API Settings
                    function saveAPISettings() {
                        const keyInput = document.getElementById('personalGeminiKey');
                        const personalKey = keyInput ? keyInput.value.trim() : '';

                        if (personalKey) {
                            localStorage.setItem('personalGeminiKey', personalKey);
                            showToast('API key saved successfully!', 'success');
                        } else {
                            localStorage.removeItem('personalGeminiKey');
                            showToast('API key cleared.', 'info');
                        }

                        // Toggle chatbot button visibility
                        if (typeof toggleChatbotVisibility === 'function') {
                            toggleChatbotVisibility();
                        }

                        // Toggle chatbot button visibility
                        if (typeof toggleChatbotVisibility === 'function') {
                            toggleChatbotVisibility();
                        }
                        closeModal('ocrSettingsModal');
                    }

                </script>

                <style>
                    /* AI Chat Panel Active State */
                    #aiChatPanel.active {
                        right: 0;
                    }

                    /* Chat Message Styles */
                    .chat-message {
                        padding: 12px;
                        border-radius: 12px;
                        font-size: 0.9rem;
                        max-width: 85%;
                        word-wrap: break-word;
                    }

                    .chat-message.user {
                        background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
                        color: white;
                        margin-left: auto;
                        border-bottom-right-radius: 4px;
                    }

                    .chat-message.bot {
                        background: var(--card-bg);
                        color: var(--dark-text);
                        border: 1px solid var(--border-color);
                        border-bottom-left-radius: 4px;
                    }

                    .chat-message.system {
                        background: var(--light-bg);
                        color: var(--medium-text);
                        font-style: italic;
                        font-size: 0.85rem;
                        text-align: center;
                        margin: 0 auto;
                    }

                    /* Dark Mode Specific Overrides */
                    .dark-mode #aiChatbotButton {
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
                    }

                    .dark-mode #aiChatPanel {
                        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.8);
                    }

                    /* Light Mode FAQ Button Styles */
                    #aiChatPanel .faq-btn,
                    #aiChatPanel .btn {
                        background: var(--light-bg);
                        color: var(--dark-text);
                        border: 1px solid var(--border-color);
                        transition: background 0.2s ease;
                    }

                    #aiChatPanel .faq-btn:hover,
                    #aiChatPanel .btn:hover {
                        background: rgba(0, 0, 0, 0.05);
                    }

                    /* Dark Mode FAQ Button - Greyish black with white text */
                    body.dark-mode #aiChatPanel .faq-btn,
                    .dark-mode #aiChatPanel .faq-btn,
                    body.dark-mode #aiChatPanel .btn,
                    .dark-mode #aiChatPanel .btn {
                        background: #2a2a2a !important;
                        color: #ffffff !important;
                        border: 1px solid #404040 !important;
                    }

                    body.dark-mode #aiChatPanel .faq-btn:hover,
                    .dark-mode #aiChatPanel .faq-btn:hover,
                    body.dark-mode #aiChatPanel .btn:hover,
                    .dark-mode #aiChatPanel .btn:hover {
                        background: #353535 !important;
                        color: #ffffff !important;
                    }

                    /* Responsive Design */
                    @media (max-width: 768px) {
                        #aiChatPanel {
                            width: 100%;
                            right: -100%;
                        }

                        /* AI button uses same position on all devices */
                    }

                    /* Scrollbar Styling for Chat */
                    #chatMessages::-webkit-scrollbar {
                        width: 6px;
                    }

                    #chatMessages::-webkit-scrollbar-track {
                        background: var(--light-bg);
                    }

                    #chatMessages::-webkit-scrollbar-thumb {
                        background: var(--border-color);
                        border-radius: 3px;
                    }

                    #chatMessages::-webkit-scrollbar-thumb:hover {
                        background: var(--medium-text);
                    }

                    /* Toast Notifications */
                    #toast-container {
                        position: fixed;
                        bottom: 30px;
                        left: 50%;
                        transform: translateX(-50%);
                        z-index: 9999;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        pointer-events: none;
                        width: max-content;
                        max-width: 90%;
                    }

                    .toast {
                        background: var(--card-bg);
                        color: var(--dark-text);
                        padding: 12px 24px;
                        border-radius: 50px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
                        border: 1px solid var(--border-color);
                        font-family: 'Outfit', sans-serif;
                        font-weight: 500;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        opacity: 1;
                        pointer-events: auto;
                        animation: toastIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        backdrop-filter: blur(12px);
                        -webkit-backdrop-filter: blur(12px);
                    }

                    .toast.hide {
                        animation: toastOut 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
                    }

                    @keyframes toastIn {
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }

                    @keyframes toastOut {
                        to {
                            opacity: 0;
                            transform: translateY(20px) scale(0.9);
                        }
                    }

                    .toast.success {
                        border-left: 4px solid var(--success-grad-start);
                    }

                    .toast.error {
                        border-left: 4px solid var(--danger-color);
                    }

                    .toast.warning {
                        border-left: 4px solid var(--warning-color);
                    }

                    /* View Transitions (Animation on Display) */
                    @keyframes fadeInSlideUp {
                        from {
                            opacity: 0;
                            transform: translateY(15px) scale(0.98);
                        }

                        to {
                            opacity: 1;
                            transform: translateY(0) scale(1);
                        }
                    }

                    /* AI Chat Panel Active State */
                    #aiChatPanel.active {
                        right: 0 !important;
                    }

                    #resultsSection,
                    #portalDashboardSection,
                    #uploadSection,
                    #manualInput,
                    #jsonInput,
                    #leavePlannerSection,
                    #analysisResults,
                    #tabularAnalysisSection,
                    #graphAnalysisSection,
                    .section-view {
                        animation: fadeInSlideUp 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
                    }

                    .fade-out {
                        opacity: 0 !important;
                    }

                    .fade-in {
                        opacity: 1 !important;
                    }

                    @keyframes glowingPulse {
                        0% {
                            box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7);
                        }

                        70% {
                            box-shadow: 0 0 0 15px rgba(102, 126, 234, 0);
                        }

                        100% {
                            box-shadow: 0 0 0 0 rgba(102, 126, 234, 0);
                        }
                    }

                    .glowing-pulse {
                        animation: glowingPulse 2s infinite !important;
                    }
                </style>
                <script>
                    // Global Haptic Feedback for all buttons
                    document.addEventListener('click', function (e) {
                        const target = e.target.closest('button, .btn, .fixed-ui-button, select, input[type="checkbox"], input[type="radio"]');
                        if (target && navigator.vibrate) {
                            navigator.vibrate(15);
                        }
                    });

                    // Toast Notification Helper
                    window.showToast = function (message, type = 'info') {
                        let container = document.getElementById('toast-container');
                        if (!container) {
                            container = document.createElement('div');
                            container.id = 'toast-container';
                            document.body.appendChild(container);
                        }

                        const toast = document.createElement('div');
                        toast.className = `toast ${type}`;

                        let icon = 'ℹ️';
                        if (type === 'success') icon = '✅';
                        if (type === 'error') icon = '❌';
                        if (type === 'warning') icon = '⚠️';

                        toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;

                        container.appendChild(toast);

                        if (navigator.vibrate) navigator.vibrate(20);

                        setTimeout(() => {
                            toast.classList.add('hide');
                            toast.addEventListener('animationend', () => {
                                if (toast.parentElement) toast.remove();
                            });
                        }, 3000);
                    };

                    // Initialize Slider - Duplicate content for seamless scrolling
                    // Initialize Slider - Duplicate content for seamless scrolling
                    window.addEventListener('DOMContentLoaded', () => {
                        const track = document.querySelector('.slider-track');
                        if (track) {
                            // Clone items to ensure seamless loop
                            if (track.children.length > 0) {
                                track.innerHTML += track.innerHTML;
                            }
                            // Force styles via JS to ensure visibility
                            track.style.display = 'flex';
                            track.style.width = 'max-content';
                        }

                        // DEBUG & FIX CHATBOT
                        setTimeout(() => {
                            const buttons = Array.from(document.querySelectorAll('button'));
                            const sendBtn = buttons.find(b => b.innerText.trim() === 'Send' || b.textContent.trim() === 'Send');

                            if (sendBtn) {
                                // Override click handler
                                sendBtn.onclick = function (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    if (window.sendChatMessage) window.sendChatMessage();
                                    else alert("Global sendChatMessage not found!");
                                };
                            }
                        }, 1000); // Delay to ensure DOM is fully ready
                    });
                </script>
</body>

</html>